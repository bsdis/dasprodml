#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Apr 26 16:56:53 2017 by generateDS.py version 2.25a.
#
# Command line options:
#   ('-o', 'dasprodml/DasAcquisition.py')
#   ('-s', 'dasprodml/DasAcquisitionSub.py')
#   ('--super', 'DasAcquisition')
#   ('-m', '')
#
# Command line arguments:
#   ./energistics/prodml/v2.0/xsd_schemas/DasAcquisition.xsd
#
# Command line:
#   generateDS.py -o "dasprodml/DasAcquisition.py" -s "dasprodml/DasAcquisitionSub.py" --super="DasAcquisition" -m ./energistics/prodml/v2.0/xsd_schemas/DasAcquisition.xsd
#
# Current working directory (os.getcwd()):
#   dasprodml
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name, pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0, optional=0):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class DasCalibration(GeneratedsSuper):
    """This object contains a mapping of loci-to-fiber distance along the
    optical path for the DAS acquisition. The actual calibration
    points are provided in an array of DasCalibrationPoint
    structures consisting of three elements: a locus index, the
    corresponding fiber distance, and a description of the
    calibration type. Provide as many calibration points as
    necessary."""
    subclass = None
    superclass = None
    def __init__(self, CalibrationIndex=None, NumberOfCalibrationPoints=None, CalibrationDescription=None, CalibrationOpticalPathDistanceUnit=None, CalibrationFacilityLengthUnit=None, CalibrationDatum=None, FacilityName=None, FacilityKind=None, CalibrationDataPoints=None):
        self.original_tagname_ = None
        self.CalibrationIndex = CalibrationIndex
        self.validate_NonNegativeLong(self.CalibrationIndex)
        self.NumberOfCalibrationPoints = NumberOfCalibrationPoints
        self.validate_NonNegativeLong(self.NumberOfCalibrationPoints)
        self.CalibrationDescription = CalibrationDescription
        self.validate_String2000(self.CalibrationDescription)
        self.CalibrationOpticalPathDistanceUnit = CalibrationOpticalPathDistanceUnit
        self.validate_String64(self.CalibrationOpticalPathDistanceUnit)
        self.CalibrationFacilityLengthUnit = CalibrationFacilityLengthUnit
        self.validate_String64(self.CalibrationFacilityLengthUnit)
        self.CalibrationDatum = CalibrationDatum
        self.validate_WellboreDatumReference(self.CalibrationDatum)
        self.FacilityName = FacilityName
        self.validate_String64(self.FacilityName)
        self.FacilityKind = FacilityKind
        self.validate_FacilityKind(self.FacilityKind)
        if CalibrationDataPoints is None:
            self.CalibrationDataPoints = []
        else:
            self.CalibrationDataPoints = CalibrationDataPoints
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DasCalibration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DasCalibration.subclass:
            return DasCalibration.subclass(*args_, **kwargs_)
        else:
            return DasCalibration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CalibrationIndex(self): return self.CalibrationIndex
    def set_CalibrationIndex(self, CalibrationIndex): self.CalibrationIndex = CalibrationIndex
    CalibrationIndexProp = property(get_CalibrationIndex, set_CalibrationIndex)
    def get_NumberOfCalibrationPoints(self): return self.NumberOfCalibrationPoints
    def set_NumberOfCalibrationPoints(self, NumberOfCalibrationPoints): self.NumberOfCalibrationPoints = NumberOfCalibrationPoints
    NumberOfCalibrationPointsProp = property(get_NumberOfCalibrationPoints, set_NumberOfCalibrationPoints)
    def get_CalibrationDescription(self): return self.CalibrationDescription
    def set_CalibrationDescription(self, CalibrationDescription): self.CalibrationDescription = CalibrationDescription
    CalibrationDescriptionProp = property(get_CalibrationDescription, set_CalibrationDescription)
    def get_CalibrationOpticalPathDistanceUnit(self): return self.CalibrationOpticalPathDistanceUnit
    def set_CalibrationOpticalPathDistanceUnit(self, CalibrationOpticalPathDistanceUnit): self.CalibrationOpticalPathDistanceUnit = CalibrationOpticalPathDistanceUnit
    CalibrationOpticalPathDistanceUnitProp = property(get_CalibrationOpticalPathDistanceUnit, set_CalibrationOpticalPathDistanceUnit)
    def get_CalibrationFacilityLengthUnit(self): return self.CalibrationFacilityLengthUnit
    def set_CalibrationFacilityLengthUnit(self, CalibrationFacilityLengthUnit): self.CalibrationFacilityLengthUnit = CalibrationFacilityLengthUnit
    CalibrationFacilityLengthUnitProp = property(get_CalibrationFacilityLengthUnit, set_CalibrationFacilityLengthUnit)
    def get_CalibrationDatum(self): return self.CalibrationDatum
    def set_CalibrationDatum(self, CalibrationDatum): self.CalibrationDatum = CalibrationDatum
    CalibrationDatumProp = property(get_CalibrationDatum, set_CalibrationDatum)
    def get_FacilityName(self): return self.FacilityName
    def set_FacilityName(self, FacilityName): self.FacilityName = FacilityName
    FacilityNameProp = property(get_FacilityName, set_FacilityName)
    def get_FacilityKind(self): return self.FacilityKind
    def set_FacilityKind(self, FacilityKind): self.FacilityKind = FacilityKind
    FacilityKindProp = property(get_FacilityKind, set_FacilityKind)
    def get_CalibrationDataPoints(self): return self.CalibrationDataPoints
    def set_CalibrationDataPoints(self, CalibrationDataPoints): self.CalibrationDataPoints = CalibrationDataPoints
    def add_CalibrationDataPoints(self, value): self.CalibrationDataPoints.append(value)
    def insert_CalibrationDataPoints_at(self, index, value): self.CalibrationDataPoints.insert(index, value)
    def replace_CalibrationDataPoints_at(self, index, value): self.CalibrationDataPoints[index] = value
    CalibrationDataPointsProp = property(get_CalibrationDataPoints, set_CalibrationDataPoints)
    def validate_NonNegativeLong(self, value):
        # Validate type NonNegativeLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeLong' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_WellboreDatumReference(self, value):
        # Validate type WellboreDatumReference, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ground level', 'kelly bushing', 'mean sea level', 'derrick floor', 'casing flange', 'crown valve', 'rotary bushing', 'rotary table', 'sea floor', 'lowest astronomical tide', 'mean higher high water', 'mean high water', 'mean lower low water', 'mean low water', 'mean tide level', 'kickoff point']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WellboreDatumReference' % {"value" : value.encode("utf-8")} )
    def validate_FacilityKind(self, value):
        # Validate type FacilityKind, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['generic', 'pipeline', 'well']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FacilityKind' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CalibrationIndex is not None or
            self.NumberOfCalibrationPoints is not None or
            self.CalibrationDescription is not None or
            self.CalibrationOpticalPathDistanceUnit is not None or
            self.CalibrationFacilityLengthUnit is not None or
            self.CalibrationDatum is not None or
            self.FacilityName is not None or
            self.FacilityKind is not None or
            self.CalibrationDataPoints
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DasCalibration', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DasCalibration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DasCalibration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DasCalibration'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DasCalibration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CalibrationIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCalibrationIndex>%s</%sCalibrationIndex>%s' % (namespace_, self.gds_format_integer(self.CalibrationIndex, input_name='CalibrationIndex'), namespace_, eol_))
        if self.NumberOfCalibrationPoints is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberOfCalibrationPoints>%s</%sNumberOfCalibrationPoints>%s' % (namespace_, self.gds_format_integer(self.NumberOfCalibrationPoints, input_name='NumberOfCalibrationPoints'), namespace_, eol_))
        if self.CalibrationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCalibrationDescription>%s</%sCalibrationDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CalibrationDescription), input_name='CalibrationDescription')), namespace_, eol_))
        if self.CalibrationOpticalPathDistanceUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCalibrationOpticalPathDistanceUnit>%s</%sCalibrationOpticalPathDistanceUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CalibrationOpticalPathDistanceUnit), input_name='CalibrationOpticalPathDistanceUnit')), namespace_, eol_))
        if self.CalibrationFacilityLengthUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCalibrationFacilityLengthUnit>%s</%sCalibrationFacilityLengthUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CalibrationFacilityLengthUnit), input_name='CalibrationFacilityLengthUnit')), namespace_, eol_))
        if self.CalibrationDatum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCalibrationDatum>%s</%sCalibrationDatum>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CalibrationDatum), input_name='CalibrationDatum')), namespace_, eol_))
        if self.FacilityName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFacilityName>%s</%sFacilityName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FacilityName), input_name='FacilityName')), namespace_, eol_))
        if self.FacilityKind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFacilityKind>%s</%sFacilityKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FacilityKind), input_name='FacilityKind')), namespace_, eol_))
        for CalibrationDataPoints_ in self.CalibrationDataPoints:
            CalibrationDataPoints_.export(outfile, level, namespace_, name_='CalibrationDataPoints', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CalibrationIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CalibrationIndex')
            self.CalibrationIndex = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.CalibrationIndex)
        elif nodeName_ == 'NumberOfCalibrationPoints':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfCalibrationPoints')
            self.NumberOfCalibrationPoints = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.NumberOfCalibrationPoints)
        elif nodeName_ == 'CalibrationDescription':
            CalibrationDescription_ = child_.text
            CalibrationDescription_ = self.gds_validate_string(CalibrationDescription_, node, 'CalibrationDescription')
            self.CalibrationDescription = CalibrationDescription_
            # validate type String2000
            self.validate_String2000(self.CalibrationDescription)
        elif nodeName_ == 'CalibrationOpticalPathDistanceUnit':
            CalibrationOpticalPathDistanceUnit_ = child_.text
            CalibrationOpticalPathDistanceUnit_ = self.gds_validate_string(CalibrationOpticalPathDistanceUnit_, node, 'CalibrationOpticalPathDistanceUnit')
            self.CalibrationOpticalPathDistanceUnit = CalibrationOpticalPathDistanceUnit_
            # validate type String64
            self.validate_String64(self.CalibrationOpticalPathDistanceUnit)
        elif nodeName_ == 'CalibrationFacilityLengthUnit':
            CalibrationFacilityLengthUnit_ = child_.text
            CalibrationFacilityLengthUnit_ = self.gds_validate_string(CalibrationFacilityLengthUnit_, node, 'CalibrationFacilityLengthUnit')
            self.CalibrationFacilityLengthUnit = CalibrationFacilityLengthUnit_
            # validate type String64
            self.validate_String64(self.CalibrationFacilityLengthUnit)
        elif nodeName_ == 'CalibrationDatum':
            CalibrationDatum_ = child_.text
            CalibrationDatum_ = self.gds_validate_string(CalibrationDatum_, node, 'CalibrationDatum')
            self.CalibrationDatum = CalibrationDatum_
            # validate type WellboreDatumReference
            self.validate_WellboreDatumReference(self.CalibrationDatum)
        elif nodeName_ == 'FacilityName':
            FacilityName_ = child_.text
            FacilityName_ = self.gds_validate_string(FacilityName_, node, 'FacilityName')
            self.FacilityName = FacilityName_
            # validate type String64
            self.validate_String64(self.FacilityName)
        elif nodeName_ == 'FacilityKind':
            FacilityKind_ = child_.text
            FacilityKind_ = self.gds_validate_string(FacilityKind_, node, 'FacilityKind')
            self.FacilityKind = FacilityKind_
            # validate type FacilityKind
            self.validate_FacilityKind(self.FacilityKind)
        elif nodeName_ == 'CalibrationDataPoints':
            obj_ = DasCalibrationPoint.factory()
            obj_.build(child_)
            self.CalibrationDataPoints.append(obj_)
            obj_.original_tagname_ = 'CalibrationDataPoints'
# end class DasCalibration


class DasCalibrationPoint(GeneratedsSuper):
    """This object contains calibration points in the array"""
    subclass = None
    superclass = None
    def __init__(self, CalibrationLocusIndex=None, CalibrationOpticalPathDistance=None, CalibrationFacilityLength=None, CalibrationType=None):
        self.original_tagname_ = None
        self.CalibrationLocusIndex = CalibrationLocusIndex
        self.validate_NonNegativeLong(self.CalibrationLocusIndex)
        self.CalibrationOpticalPathDistance = CalibrationOpticalPathDistance
        self.CalibrationFacilityLength = CalibrationFacilityLength
        self.CalibrationType = CalibrationType
        self.validate_DasCalibrationTypeExt(self.CalibrationType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DasCalibrationPoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DasCalibrationPoint.subclass:
            return DasCalibrationPoint.subclass(*args_, **kwargs_)
        else:
            return DasCalibrationPoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CalibrationLocusIndex(self): return self.CalibrationLocusIndex
    def set_CalibrationLocusIndex(self, CalibrationLocusIndex): self.CalibrationLocusIndex = CalibrationLocusIndex
    CalibrationLocusIndexProp = property(get_CalibrationLocusIndex, set_CalibrationLocusIndex)
    def get_CalibrationOpticalPathDistance(self): return self.CalibrationOpticalPathDistance
    def set_CalibrationOpticalPathDistance(self, CalibrationOpticalPathDistance): self.CalibrationOpticalPathDistance = CalibrationOpticalPathDistance
    CalibrationOpticalPathDistanceProp = property(get_CalibrationOpticalPathDistance, set_CalibrationOpticalPathDistance)
    def get_CalibrationFacilityLength(self): return self.CalibrationFacilityLength
    def set_CalibrationFacilityLength(self, CalibrationFacilityLength): self.CalibrationFacilityLength = CalibrationFacilityLength
    CalibrationFacilityLengthProp = property(get_CalibrationFacilityLength, set_CalibrationFacilityLength)
    def get_CalibrationType(self): return self.CalibrationType
    def set_CalibrationType(self, CalibrationType): self.CalibrationType = CalibrationType
    CalibrationTypeProp = property(get_CalibrationType, set_CalibrationType)
    def validate_NonNegativeLong(self, value):
        # Validate type NonNegativeLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeLong' % {"value" : value} )
    def validate_DasCalibrationTypeExt(self, value):
        # Validate type DasCalibrationTypeExt, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.CalibrationLocusIndex is not None or
            self.CalibrationOpticalPathDistance is not None or
            self.CalibrationFacilityLength is not None or
            self.CalibrationType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DasCalibrationPoint', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DasCalibrationPoint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DasCalibrationPoint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DasCalibrationPoint'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DasCalibrationPoint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CalibrationLocusIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCalibrationLocusIndex>%s</%sCalibrationLocusIndex>%s' % (namespace_, self.gds_format_integer(self.CalibrationLocusIndex, input_name='CalibrationLocusIndex'), namespace_, eol_))
        if self.CalibrationOpticalPathDistance is not None:
            self.CalibrationOpticalPathDistance.export(outfile, level, namespace_, name_='CalibrationOpticalPathDistance', pretty_print=pretty_print)
        if self.CalibrationFacilityLength is not None:
            self.CalibrationFacilityLength.export(outfile, level, namespace_, name_='CalibrationFacilityLength', pretty_print=pretty_print)
        if self.CalibrationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCalibrationType>%s</%sCalibrationType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CalibrationType), input_name='CalibrationType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CalibrationLocusIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CalibrationLocusIndex')
            self.CalibrationLocusIndex = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.CalibrationLocusIndex)
        elif nodeName_ == 'CalibrationOpticalPathDistance':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.CalibrationOpticalPathDistance = obj_
            obj_.original_tagname_ = 'CalibrationOpticalPathDistance'
        elif nodeName_ == 'CalibrationFacilityLength':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.CalibrationFacilityLength = obj_
            obj_.original_tagname_ = 'CalibrationFacilityLength'
        elif nodeName_ == 'CalibrationType':
            CalibrationType_ = child_.text
            CalibrationType_ = self.gds_validate_string(CalibrationType_, node, 'CalibrationType')
            self.CalibrationType = CalibrationType_
            # validate type DasCalibrationTypeExt
            self.validate_DasCalibrationTypeExt(self.CalibrationType)
# end class DasCalibrationPoint


class DasCustom(GeneratedsSuper):
    """This object contains serviceâ€“provider-specific customization
    parameters. Service providers can define the contents of this
    data element as required. This data object has intentionally not
    been described in detail to allow for flexibility. Note that
    this object is optional and if used, the service provider needs
    to provide a description of the data elements to the customer."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DasCustom)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DasCustom.subclass:
            return DasCustom.subclass(*args_, **kwargs_)
        else:
            return DasCustom(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DasCustom', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DasCustom')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DasCustom', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DasCustom'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DasCustom', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DasCustom


class DasFbe(GeneratedsSuper):
    """This object contains the attributes of FBE processed data. This
    includes the FBE data unit, location of the FBE data along the
    fiber optical path, information about times, (optional) filter
    related parameters, and UUIDs of the original raw and/or spectra
    files from which the files were processed. Note that the actual
    FBE data samples and times arrays are not present in the XML
    files but only in the HDF5 files because of their size. The XML
    files only contain references to locate the corresponding HDF
    files containing the actual FBE samples and times.A universally
    unique identifier (UUID) of an instance of FBE DAS data."""
    subclass = None
    superclass = None
    def __init__(self, uuid=None, FbeIndex=None, FbeDescription=None, FbeDataUnit=None, OutputDataRate=None, StartLocusIndex=None, NumberOfLoci=None, SpatialSamplingInterval=None, SpatialSamplingIntervalUnit=None, FilterType=None, WindowSize=None, WindowOverlap=None, WindowFunction=None, TransformType=None, TransformSize=None, RawReference=None, SpectraReference=None, FbeData=None, FbeDataTime=None, Custom=None):
        self.original_tagname_ = None
        self.uuid = _cast(None, uuid)
        self.FbeIndex = FbeIndex
        self.validate_NonNegativeLong(self.FbeIndex)
        self.FbeDescription = FbeDescription
        self.validate_String2000(self.FbeDescription)
        self.FbeDataUnit = FbeDataUnit
        self.validate_String64(self.FbeDataUnit)
        self.OutputDataRate = OutputDataRate
        self.StartLocusIndex = StartLocusIndex
        self.validate_NonNegativeLong(self.StartLocusIndex)
        self.NumberOfLoci = NumberOfLoci
        self.validate_NonNegativeLong(self.NumberOfLoci)
        self.SpatialSamplingInterval = SpatialSamplingInterval
        self.SpatialSamplingIntervalUnit = SpatialSamplingIntervalUnit
        self.validate_String64(self.SpatialSamplingIntervalUnit)
        self.FilterType = FilterType
        self.validate_String64(self.FilterType)
        self.WindowSize = WindowSize
        self.validate_NonNegativeLong(self.WindowSize)
        self.WindowOverlap = WindowOverlap
        self.validate_NonNegativeLong(self.WindowOverlap)
        self.WindowFunction = WindowFunction
        self.validate_String64(self.WindowFunction)
        self.TransformType = TransformType
        self.validate_String64(self.TransformType)
        self.TransformSize = TransformSize
        self.validate_NonNegativeLong(self.TransformSize)
        self.RawReference = RawReference
        self.validate_UuidString(self.RawReference)
        self.SpectraReference = SpectraReference
        self.validate_UuidString(self.SpectraReference)
        if FbeData is None:
            self.FbeData = []
        else:
            self.FbeData = FbeData
        self.FbeDataTime = FbeDataTime
        self.Custom = Custom
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DasFbe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DasFbe.subclass:
            return DasFbe.subclass(*args_, **kwargs_)
        else:
            return DasFbe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FbeIndex(self): return self.FbeIndex
    def set_FbeIndex(self, FbeIndex): self.FbeIndex = FbeIndex
    FbeIndexProp = property(get_FbeIndex, set_FbeIndex)
    def get_FbeDescription(self): return self.FbeDescription
    def set_FbeDescription(self, FbeDescription): self.FbeDescription = FbeDescription
    FbeDescriptionProp = property(get_FbeDescription, set_FbeDescription)
    def get_FbeDataUnit(self): return self.FbeDataUnit
    def set_FbeDataUnit(self, FbeDataUnit): self.FbeDataUnit = FbeDataUnit
    FbeDataUnitProp = property(get_FbeDataUnit, set_FbeDataUnit)
    def get_OutputDataRate(self): return self.OutputDataRate
    def set_OutputDataRate(self, OutputDataRate): self.OutputDataRate = OutputDataRate
    OutputDataRateProp = property(get_OutputDataRate, set_OutputDataRate)
    def get_StartLocusIndex(self): return self.StartLocusIndex
    def set_StartLocusIndex(self, StartLocusIndex): self.StartLocusIndex = StartLocusIndex
    StartLocusIndexProp = property(get_StartLocusIndex, set_StartLocusIndex)
    def get_NumberOfLoci(self): return self.NumberOfLoci
    def set_NumberOfLoci(self, NumberOfLoci): self.NumberOfLoci = NumberOfLoci
    NumberOfLociProp = property(get_NumberOfLoci, set_NumberOfLoci)
    def get_SpatialSamplingInterval(self): return self.SpatialSamplingInterval
    def set_SpatialSamplingInterval(self, SpatialSamplingInterval): self.SpatialSamplingInterval = SpatialSamplingInterval
    SpatialSamplingIntervalProp = property(get_SpatialSamplingInterval, set_SpatialSamplingInterval)
    def get_SpatialSamplingIntervalUnit(self): return self.SpatialSamplingIntervalUnit
    def set_SpatialSamplingIntervalUnit(self, SpatialSamplingIntervalUnit): self.SpatialSamplingIntervalUnit = SpatialSamplingIntervalUnit
    SpatialSamplingIntervalUnitProp = property(get_SpatialSamplingIntervalUnit, set_SpatialSamplingIntervalUnit)
    def get_FilterType(self): return self.FilterType
    def set_FilterType(self, FilterType): self.FilterType = FilterType
    FilterTypeProp = property(get_FilterType, set_FilterType)
    def get_WindowSize(self): return self.WindowSize
    def set_WindowSize(self, WindowSize): self.WindowSize = WindowSize
    WindowSizeProp = property(get_WindowSize, set_WindowSize)
    def get_WindowOverlap(self): return self.WindowOverlap
    def set_WindowOverlap(self, WindowOverlap): self.WindowOverlap = WindowOverlap
    WindowOverlapProp = property(get_WindowOverlap, set_WindowOverlap)
    def get_WindowFunction(self): return self.WindowFunction
    def set_WindowFunction(self, WindowFunction): self.WindowFunction = WindowFunction
    WindowFunctionProp = property(get_WindowFunction, set_WindowFunction)
    def get_TransformType(self): return self.TransformType
    def set_TransformType(self, TransformType): self.TransformType = TransformType
    TransformTypeProp = property(get_TransformType, set_TransformType)
    def get_TransformSize(self): return self.TransformSize
    def set_TransformSize(self, TransformSize): self.TransformSize = TransformSize
    TransformSizeProp = property(get_TransformSize, set_TransformSize)
    def get_RawReference(self): return self.RawReference
    def set_RawReference(self, RawReference): self.RawReference = RawReference
    RawReferenceProp = property(get_RawReference, set_RawReference)
    def get_SpectraReference(self): return self.SpectraReference
    def set_SpectraReference(self, SpectraReference): self.SpectraReference = SpectraReference
    SpectraReferenceProp = property(get_SpectraReference, set_SpectraReference)
    def get_FbeData(self): return self.FbeData
    def set_FbeData(self, FbeData): self.FbeData = FbeData
    def add_FbeData(self, value): self.FbeData.append(value)
    def insert_FbeData_at(self, index, value): self.FbeData.insert(index, value)
    def replace_FbeData_at(self, index, value): self.FbeData[index] = value
    FbeDataProp = property(get_FbeData, set_FbeData)
    def get_FbeDataTime(self): return self.FbeDataTime
    def set_FbeDataTime(self, FbeDataTime): self.FbeDataTime = FbeDataTime
    FbeDataTimeProp = property(get_FbeDataTime, set_FbeDataTime)
    def get_Custom(self): return self.Custom
    def set_Custom(self, Custom): self.Custom = Custom
    CustomProp = property(get_Custom, set_Custom)
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    uuidProp = property(get_uuid, set_uuid)
    def validate_NonNegativeLong(self, value):
        # Validate type NonNegativeLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeLong' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_UuidString(self, value):
        # Validate type UuidString, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_UuidString_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_UuidString_patterns_, ))
    validate_UuidString_patterns_ = [['^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$']]
    def hasContent_(self):
        if (
            self.FbeIndex is not None or
            self.FbeDescription is not None or
            self.FbeDataUnit is not None or
            self.OutputDataRate is not None or
            self.StartLocusIndex is not None or
            self.NumberOfLoci is not None or
            self.SpatialSamplingInterval is not None or
            self.SpatialSamplingIntervalUnit is not None or
            self.FilterType is not None or
            self.WindowSize is not None or
            self.WindowOverlap is not None or
            self.WindowFunction is not None or
            self.TransformType is not None or
            self.TransformSize is not None or
            self.RawReference is not None or
            self.SpectraReference is not None or
            self.FbeData or
            self.FbeDataTime is not None or
            self.Custom is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DasFbe', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DasFbe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DasFbe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DasFbe'):
        if self.uuid is not None and 'uuid' not in already_processed:
            already_processed.add('uuid')
            outfile.write(' uuid=%s' % (quote_attrib(self.uuid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DasFbe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FbeIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFbeIndex>%s</%sFbeIndex>%s' % (namespace_, self.gds_format_integer(self.FbeIndex, input_name='FbeIndex'), namespace_, eol_))
        if self.FbeDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFbeDescription>%s</%sFbeDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FbeDescription), input_name='FbeDescription')), namespace_, eol_))
        if self.FbeDataUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFbeDataUnit>%s</%sFbeDataUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FbeDataUnit), input_name='FbeDataUnit')), namespace_, eol_))
        if self.OutputDataRate is not None:
            self.OutputDataRate.export(outfile, level, namespace_, name_='OutputDataRate', pretty_print=pretty_print)
        if self.StartLocusIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartLocusIndex>%s</%sStartLocusIndex>%s' % (namespace_, self.gds_format_integer(self.StartLocusIndex, input_name='StartLocusIndex'), namespace_, eol_))
        if self.NumberOfLoci is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberOfLoci>%s</%sNumberOfLoci>%s' % (namespace_, self.gds_format_integer(self.NumberOfLoci, input_name='NumberOfLoci'), namespace_, eol_))
        if self.SpatialSamplingInterval is not None:
            self.SpatialSamplingInterval.export(outfile, level, namespace_, name_='SpatialSamplingInterval', pretty_print=pretty_print)
        if self.SpatialSamplingIntervalUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpatialSamplingIntervalUnit>%s</%sSpatialSamplingIntervalUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SpatialSamplingIntervalUnit), input_name='SpatialSamplingIntervalUnit')), namespace_, eol_))
        if self.FilterType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFilterType>%s</%sFilterType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FilterType), input_name='FilterType')), namespace_, eol_))
        if self.WindowSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWindowSize>%s</%sWindowSize>%s' % (namespace_, self.gds_format_integer(self.WindowSize, input_name='WindowSize'), namespace_, eol_))
        if self.WindowOverlap is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWindowOverlap>%s</%sWindowOverlap>%s' % (namespace_, self.gds_format_integer(self.WindowOverlap, input_name='WindowOverlap'), namespace_, eol_))
        if self.WindowFunction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWindowFunction>%s</%sWindowFunction>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WindowFunction), input_name='WindowFunction')), namespace_, eol_))
        if self.TransformType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransformType>%s</%sTransformType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TransformType), input_name='TransformType')), namespace_, eol_))
        if self.TransformSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransformSize>%s</%sTransformSize>%s' % (namespace_, self.gds_format_integer(self.TransformSize, input_name='TransformSize'), namespace_, eol_))
        if self.RawReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRawReference>%s</%sRawReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RawReference), input_name='RawReference')), namespace_, eol_))
        if self.SpectraReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpectraReference>%s</%sSpectraReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SpectraReference), input_name='SpectraReference')), namespace_, eol_))
        for FbeData_ in self.FbeData:
            FbeData_.export(outfile, level, namespace_, name_='FbeData', pretty_print=pretty_print)
        if self.FbeDataTime is not None:
            self.FbeDataTime.export(outfile, level, namespace_, name_='FbeDataTime', pretty_print=pretty_print)
        if self.Custom is not None:
            self.Custom.export(outfile, level, namespace_, name_='Custom', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uuid', node)
        if value is not None and 'uuid' not in already_processed:
            already_processed.add('uuid')
            self.uuid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FbeIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FbeIndex')
            self.FbeIndex = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.FbeIndex)
        elif nodeName_ == 'FbeDescription':
            FbeDescription_ = child_.text
            FbeDescription_ = self.gds_validate_string(FbeDescription_, node, 'FbeDescription')
            self.FbeDescription = FbeDescription_
            # validate type String2000
            self.validate_String2000(self.FbeDescription)
        elif nodeName_ == 'FbeDataUnit':
            FbeDataUnit_ = child_.text
            FbeDataUnit_ = self.gds_validate_string(FbeDataUnit_, node, 'FbeDataUnit')
            self.FbeDataUnit = FbeDataUnit_
            # validate type String64
            self.validate_String64(self.FbeDataUnit)
        elif nodeName_ == 'OutputDataRate':
            obj_ = FrequencyMeasure.factory()
            obj_.build(child_)
            self.OutputDataRate = obj_
            obj_.original_tagname_ = 'OutputDataRate'
        elif nodeName_ == 'StartLocusIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StartLocusIndex')
            self.StartLocusIndex = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.StartLocusIndex)
        elif nodeName_ == 'NumberOfLoci':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfLoci')
            self.NumberOfLoci = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.NumberOfLoci)
        elif nodeName_ == 'SpatialSamplingInterval':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.SpatialSamplingInterval = obj_
            obj_.original_tagname_ = 'SpatialSamplingInterval'
        elif nodeName_ == 'SpatialSamplingIntervalUnit':
            SpatialSamplingIntervalUnit_ = child_.text
            SpatialSamplingIntervalUnit_ = self.gds_validate_string(SpatialSamplingIntervalUnit_, node, 'SpatialSamplingIntervalUnit')
            self.SpatialSamplingIntervalUnit = SpatialSamplingIntervalUnit_
            # validate type String64
            self.validate_String64(self.SpatialSamplingIntervalUnit)
        elif nodeName_ == 'FilterType':
            FilterType_ = child_.text
            FilterType_ = self.gds_validate_string(FilterType_, node, 'FilterType')
            self.FilterType = FilterType_
            # validate type String64
            self.validate_String64(self.FilterType)
        elif nodeName_ == 'WindowSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'WindowSize')
            self.WindowSize = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.WindowSize)
        elif nodeName_ == 'WindowOverlap':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'WindowOverlap')
            self.WindowOverlap = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.WindowOverlap)
        elif nodeName_ == 'WindowFunction':
            WindowFunction_ = child_.text
            WindowFunction_ = self.gds_validate_string(WindowFunction_, node, 'WindowFunction')
            self.WindowFunction = WindowFunction_
            # validate type String64
            self.validate_String64(self.WindowFunction)
        elif nodeName_ == 'TransformType':
            TransformType_ = child_.text
            TransformType_ = self.gds_validate_string(TransformType_, node, 'TransformType')
            self.TransformType = TransformType_
            # validate type String64
            self.validate_String64(self.TransformType)
        elif nodeName_ == 'TransformSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TransformSize')
            self.TransformSize = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.TransformSize)
        elif nodeName_ == 'RawReference':
            RawReference_ = child_.text
            RawReference_ = self.gds_validate_string(RawReference_, node, 'RawReference')
            self.RawReference = RawReference_
            # validate type UuidString
            self.validate_UuidString(self.RawReference)
        elif nodeName_ == 'SpectraReference':
            SpectraReference_ = child_.text
            SpectraReference_ = self.gds_validate_string(SpectraReference_, node, 'SpectraReference')
            self.SpectraReference = SpectraReference_
            # validate type UuidString
            self.validate_UuidString(self.SpectraReference)
        elif nodeName_ == 'FbeData':
            obj_ = DasFbeData.factory()
            obj_.build(child_)
            self.FbeData.append(obj_)
            obj_.original_tagname_ = 'FbeData'
        elif nodeName_ == 'FbeDataTime':
            obj_ = DasTimeArray.factory()
            obj_.build(child_)
            self.FbeDataTime = obj_
            obj_.original_tagname_ = 'FbeDataTime'
        elif nodeName_ == 'Custom':
            obj_ = DasCustom.factory()
            obj_.build(child_)
            self.Custom = obj_
            obj_.original_tagname_ = 'Custom'
# end class DasFbe


class DasFbeData(GeneratedsSuper):
    """Two dimensional (loci & time) array containing processed frequency
    band extracted data samples. This processed data type is
    obtained by applying a frequency band filter to the raw data
    acquired by the DAS acquisition system. For each frequency band
    provided, a separate DASFbeData array object is created."""
    subclass = None
    superclass = None
    def __init__(self, FbeDataIndex=None, StartFrequency=None, EndFrequency=None, Dimensions=None, FbeDataArray=None):
        self.original_tagname_ = None
        self.FbeDataIndex = FbeDataIndex
        self.validate_NonNegativeLong(self.FbeDataIndex)
        self.StartFrequency = StartFrequency
        self.EndFrequency = EndFrequency
        if Dimensions is None:
            self.Dimensions = []
        else:
            self.Dimensions = Dimensions
        self.FbeDataArray = FbeDataArray
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DasFbeData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DasFbeData.subclass:
            return DasFbeData.subclass(*args_, **kwargs_)
        else:
            return DasFbeData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FbeDataIndex(self): return self.FbeDataIndex
    def set_FbeDataIndex(self, FbeDataIndex): self.FbeDataIndex = FbeDataIndex
    FbeDataIndexProp = property(get_FbeDataIndex, set_FbeDataIndex)
    def get_StartFrequency(self): return self.StartFrequency
    def set_StartFrequency(self, StartFrequency): self.StartFrequency = StartFrequency
    StartFrequencyProp = property(get_StartFrequency, set_StartFrequency)
    def get_EndFrequency(self): return self.EndFrequency
    def set_EndFrequency(self, EndFrequency): self.EndFrequency = EndFrequency
    EndFrequencyProp = property(get_EndFrequency, set_EndFrequency)
    def get_Dimensions(self): return self.Dimensions
    def set_Dimensions(self, Dimensions): self.Dimensions = Dimensions
    def add_Dimensions(self, value): self.Dimensions.append(value)
    def insert_Dimensions_at(self, index, value): self.Dimensions.insert(index, value)
    def replace_Dimensions_at(self, index, value): self.Dimensions[index] = value
    DimensionsProp = property(get_Dimensions, set_Dimensions)
    def get_FbeDataArray(self): return self.FbeDataArray
    def set_FbeDataArray(self, FbeDataArray): self.FbeDataArray = FbeDataArray
    FbeDataArrayProp = property(get_FbeDataArray, set_FbeDataArray)
    def validate_NonNegativeLong(self, value):
        # Validate type NonNegativeLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeLong' % {"value" : value} )
    def validate_DasDimensions(self, value):
        # Validate type DasDimensions, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['frequency', 'locus', 'time']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DasDimensions' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FbeDataIndex is not None or
            self.StartFrequency is not None or
            self.EndFrequency is not None or
            self.Dimensions or
            self.FbeDataArray is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DasFbeData', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DasFbeData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DasFbeData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DasFbeData'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DasFbeData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FbeDataIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFbeDataIndex>%s</%sFbeDataIndex>%s' % (namespace_, self.gds_format_integer(self.FbeDataIndex, input_name='FbeDataIndex'), namespace_, eol_))
        if self.StartFrequency is not None:
            self.StartFrequency.export(outfile, level, namespace_, name_='StartFrequency', pretty_print=pretty_print)
        if self.EndFrequency is not None:
            self.EndFrequency.export(outfile, level, namespace_, name_='EndFrequency', pretty_print=pretty_print)
        for Dimensions_ in self.Dimensions:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDimensions>%s</%sDimensions>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(Dimensions_), input_name='Dimensions')), namespace_, eol_))
        if self.FbeDataArray is not None:
            self.FbeDataArray.export(outfile, level, namespace_, name_='FbeDataArray', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FbeDataIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FbeDataIndex')
            self.FbeDataIndex = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.FbeDataIndex)
        elif nodeName_ == 'StartFrequency':
            obj_ = FrequencyMeasure.factory()
            obj_.build(child_)
            self.StartFrequency = obj_
            obj_.original_tagname_ = 'StartFrequency'
        elif nodeName_ == 'EndFrequency':
            obj_ = FrequencyMeasure.factory()
            obj_.build(child_)
            self.EndFrequency = obj_
            obj_.original_tagname_ = 'EndFrequency'
        elif nodeName_ == 'Dimensions':
            Dimensions_ = child_.text
            Dimensions_ = self.gds_validate_string(Dimensions_, node, 'Dimensions')
            self.Dimensions.append(Dimensions_)
            # validate type DasDimensions
            self.validate_DasDimensions(self.Dimensions[-1])
        elif nodeName_ == 'FbeDataArray':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <FbeDataArray> element')
            self.FbeDataArray = obj_
            obj_.original_tagname_ = 'FbeDataArray'
# end class DasFbeData


class DasProcessed(GeneratedsSuper):
    """This object contains data objects for processed data types and has
    no data attributes. Currently only two processed data types have
    been defined: the frequency band extracted (FBE) and spectra. In
    the future other processed data types may be added. Note that a
    DasProcessed object is optional and only present if DAS FBE or
    DAS spectra data is exchanged."""
    subclass = None
    superclass = None
    def __init__(self, Fbe=None, Spectra=None):
        self.original_tagname_ = None
        if Fbe is None:
            self.Fbe = []
        else:
            self.Fbe = Fbe
        if Spectra is None:
            self.Spectra = []
        else:
            self.Spectra = Spectra
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DasProcessed)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DasProcessed.subclass:
            return DasProcessed.subclass(*args_, **kwargs_)
        else:
            return DasProcessed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Fbe(self): return self.Fbe
    def set_Fbe(self, Fbe): self.Fbe = Fbe
    def add_Fbe(self, value): self.Fbe.append(value)
    def insert_Fbe_at(self, index, value): self.Fbe.insert(index, value)
    def replace_Fbe_at(self, index, value): self.Fbe[index] = value
    FbeProp = property(get_Fbe, set_Fbe)
    def get_Spectra(self): return self.Spectra
    def set_Spectra(self, Spectra): self.Spectra = Spectra
    def add_Spectra(self, value): self.Spectra.append(value)
    def insert_Spectra_at(self, index, value): self.Spectra.insert(index, value)
    def replace_Spectra_at(self, index, value): self.Spectra[index] = value
    SpectraProp = property(get_Spectra, set_Spectra)
    def hasContent_(self):
        if (
            self.Fbe or
            self.Spectra
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DasProcessed', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DasProcessed')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DasProcessed', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DasProcessed'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DasProcessed', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Fbe_ in self.Fbe:
            Fbe_.export(outfile, level, namespace_, name_='Fbe', pretty_print=pretty_print)
        for Spectra_ in self.Spectra:
            Spectra_.export(outfile, level, namespace_, name_='Spectra', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Fbe':
            obj_ = DasFbe.factory()
            obj_.build(child_)
            self.Fbe.append(obj_)
            obj_.original_tagname_ = 'Fbe'
        elif nodeName_ == 'Spectra':
            obj_ = DasSpectra.factory()
            obj_.build(child_)
            self.Spectra.append(obj_)
            obj_.original_tagname_ = 'Spectra'
# end class DasProcessed


class DasRaw(GeneratedsSuper):
    """This object contains the attributes of raw data acquired by the DAS
    measurement instrument. This includes the raw data unit, the
    location of the raw data acquired along the fiber optical path,
    and information about times and (optional) triggers. Note that
    the actual raw data samples, times and trigger times arrays are
    not present in the XML files but only in the HDF5 files because
    of their size. The XML files only contain references to locate
    the corresponding HDF files, which contain the actual raw
    samples, times, and (optional) trigger times.A universally
    unique identifier (UUID) for an instance of raw DAS data."""
    subclass = None
    superclass = None
    def __init__(self, uuid=None, RawIndex=None, RawDescription=None, RawDataUnit=None, OutputDataRate=None, StartLocusIndex=None, NumberOfLoci=None, RawData=None, RawDataTime=None, RawDataTriggerTime=None, Custom=None):
        self.original_tagname_ = None
        self.uuid = _cast(None, uuid)
        self.RawIndex = RawIndex
        self.validate_NonNegativeLong(self.RawIndex)
        self.RawDescription = RawDescription
        self.validate_String2000(self.RawDescription)
        self.RawDataUnit = RawDataUnit
        self.validate_String64(self.RawDataUnit)
        self.OutputDataRate = OutputDataRate
        self.StartLocusIndex = StartLocusIndex
        self.validate_NonNegativeLong(self.StartLocusIndex)
        self.NumberOfLoci = NumberOfLoci
        self.validate_NonNegativeLong(self.NumberOfLoci)
        self.RawData = RawData
        self.RawDataTime = RawDataTime
        self.RawDataTriggerTime = RawDataTriggerTime
        self.Custom = Custom
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DasRaw)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DasRaw.subclass:
            return DasRaw.subclass(*args_, **kwargs_)
        else:
            return DasRaw(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RawIndex(self): return self.RawIndex
    def set_RawIndex(self, RawIndex): self.RawIndex = RawIndex
    RawIndexProp = property(get_RawIndex, set_RawIndex)
    def get_RawDescription(self): return self.RawDescription
    def set_RawDescription(self, RawDescription): self.RawDescription = RawDescription
    RawDescriptionProp = property(get_RawDescription, set_RawDescription)
    def get_RawDataUnit(self): return self.RawDataUnit
    def set_RawDataUnit(self, RawDataUnit): self.RawDataUnit = RawDataUnit
    RawDataUnitProp = property(get_RawDataUnit, set_RawDataUnit)
    def get_OutputDataRate(self): return self.OutputDataRate
    def set_OutputDataRate(self, OutputDataRate): self.OutputDataRate = OutputDataRate
    OutputDataRateProp = property(get_OutputDataRate, set_OutputDataRate)
    def get_StartLocusIndex(self): return self.StartLocusIndex
    def set_StartLocusIndex(self, StartLocusIndex): self.StartLocusIndex = StartLocusIndex
    StartLocusIndexProp = property(get_StartLocusIndex, set_StartLocusIndex)
    def get_NumberOfLoci(self): return self.NumberOfLoci
    def set_NumberOfLoci(self, NumberOfLoci): self.NumberOfLoci = NumberOfLoci
    NumberOfLociProp = property(get_NumberOfLoci, set_NumberOfLoci)
    def get_RawData(self): return self.RawData
    def set_RawData(self, RawData): self.RawData = RawData
    RawDataProp = property(get_RawData, set_RawData)
    def get_RawDataTime(self): return self.RawDataTime
    def set_RawDataTime(self, RawDataTime): self.RawDataTime = RawDataTime
    RawDataTimeProp = property(get_RawDataTime, set_RawDataTime)
    def get_RawDataTriggerTime(self): return self.RawDataTriggerTime
    def set_RawDataTriggerTime(self, RawDataTriggerTime): self.RawDataTriggerTime = RawDataTriggerTime
    RawDataTriggerTimeProp = property(get_RawDataTriggerTime, set_RawDataTriggerTime)
    def get_Custom(self): return self.Custom
    def set_Custom(self, Custom): self.Custom = Custom
    CustomProp = property(get_Custom, set_Custom)
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    uuidProp = property(get_uuid, set_uuid)
    def validate_NonNegativeLong(self, value):
        # Validate type NonNegativeLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeLong' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.RawIndex is not None or
            self.RawDescription is not None or
            self.RawDataUnit is not None or
            self.OutputDataRate is not None or
            self.StartLocusIndex is not None or
            self.NumberOfLoci is not None or
            self.RawData is not None or
            self.RawDataTime is not None or
            self.RawDataTriggerTime is not None or
            self.Custom is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DasRaw', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DasRaw')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DasRaw', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DasRaw'):
        if self.uuid is not None and 'uuid' not in already_processed:
            already_processed.add('uuid')
            outfile.write(' uuid=%s' % (quote_attrib(self.uuid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DasRaw', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RawIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRawIndex>%s</%sRawIndex>%s' % (namespace_, self.gds_format_integer(self.RawIndex, input_name='RawIndex'), namespace_, eol_))
        if self.RawDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRawDescription>%s</%sRawDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RawDescription), input_name='RawDescription')), namespace_, eol_))
        if self.RawDataUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRawDataUnit>%s</%sRawDataUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RawDataUnit), input_name='RawDataUnit')), namespace_, eol_))
        if self.OutputDataRate is not None:
            self.OutputDataRate.export(outfile, level, namespace_, name_='OutputDataRate', pretty_print=pretty_print)
        if self.StartLocusIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartLocusIndex>%s</%sStartLocusIndex>%s' % (namespace_, self.gds_format_integer(self.StartLocusIndex, input_name='StartLocusIndex'), namespace_, eol_))
        if self.NumberOfLoci is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberOfLoci>%s</%sNumberOfLoci>%s' % (namespace_, self.gds_format_integer(self.NumberOfLoci, input_name='NumberOfLoci'), namespace_, eol_))
        if self.RawData is not None:
            self.RawData.export(outfile, level, namespace_, name_='RawData', pretty_print=pretty_print)
        if self.RawDataTime is not None:
            self.RawDataTime.export(outfile, level, namespace_, name_='RawDataTime', pretty_print=pretty_print)
        if self.RawDataTriggerTime is not None:
            self.RawDataTriggerTime.export(outfile, level, namespace_, name_='RawDataTriggerTime', pretty_print=pretty_print)
        if self.Custom is not None:
            self.Custom.export(outfile, level, namespace_, name_='Custom', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uuid', node)
        if value is not None and 'uuid' not in already_processed:
            already_processed.add('uuid')
            self.uuid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RawIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RawIndex')
            self.RawIndex = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.RawIndex)
        elif nodeName_ == 'RawDescription':
            RawDescription_ = child_.text
            RawDescription_ = self.gds_validate_string(RawDescription_, node, 'RawDescription')
            self.RawDescription = RawDescription_
            # validate type String2000
            self.validate_String2000(self.RawDescription)
        elif nodeName_ == 'RawDataUnit':
            RawDataUnit_ = child_.text
            RawDataUnit_ = self.gds_validate_string(RawDataUnit_, node, 'RawDataUnit')
            self.RawDataUnit = RawDataUnit_
            # validate type String64
            self.validate_String64(self.RawDataUnit)
        elif nodeName_ == 'OutputDataRate':
            obj_ = FrequencyMeasure.factory()
            obj_.build(child_)
            self.OutputDataRate = obj_
            obj_.original_tagname_ = 'OutputDataRate'
        elif nodeName_ == 'StartLocusIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StartLocusIndex')
            self.StartLocusIndex = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.StartLocusIndex)
        elif nodeName_ == 'NumberOfLoci':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfLoci')
            self.NumberOfLoci = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.NumberOfLoci)
        elif nodeName_ == 'RawData':
            obj_ = DasRawData.factory()
            obj_.build(child_)
            self.RawData = obj_
            obj_.original_tagname_ = 'RawData'
        elif nodeName_ == 'RawDataTime':
            obj_ = DasTimeArray.factory()
            obj_.build(child_)
            self.RawDataTime = obj_
            obj_.original_tagname_ = 'RawDataTime'
        elif nodeName_ == 'RawDataTriggerTime':
            obj_ = DasTimeArray.factory()
            obj_.build(child_)
            self.RawDataTriggerTime = obj_
            obj_.original_tagname_ = 'RawDataTriggerTime'
        elif nodeName_ == 'Custom':
            obj_ = DasCustom.factory()
            obj_.build(child_)
            self.Custom = obj_
            obj_.original_tagname_ = 'Custom'
# end class DasRaw


class DasRawData(GeneratedsSuper):
    """Two- dimensional array containing raw data samples acquired by the
    DAS acquisition system."""
    subclass = None
    superclass = None
    def __init__(self, Dimensions=None, RawDataArray=None):
        self.original_tagname_ = None
        if Dimensions is None:
            self.Dimensions = []
        else:
            self.Dimensions = Dimensions
        self.RawDataArray = RawDataArray
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DasRawData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DasRawData.subclass:
            return DasRawData.subclass(*args_, **kwargs_)
        else:
            return DasRawData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Dimensions(self): return self.Dimensions
    def set_Dimensions(self, Dimensions): self.Dimensions = Dimensions
    def add_Dimensions(self, value): self.Dimensions.append(value)
    def insert_Dimensions_at(self, index, value): self.Dimensions.insert(index, value)
    def replace_Dimensions_at(self, index, value): self.Dimensions[index] = value
    DimensionsProp = property(get_Dimensions, set_Dimensions)
    def get_RawDataArray(self): return self.RawDataArray
    def set_RawDataArray(self, RawDataArray): self.RawDataArray = RawDataArray
    RawDataArrayProp = property(get_RawDataArray, set_RawDataArray)
    def validate_DasDimensions(self, value):
        # Validate type DasDimensions, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['frequency', 'locus', 'time']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DasDimensions' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Dimensions or
            self.RawDataArray is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DasRawData', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DasRawData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DasRawData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DasRawData'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DasRawData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Dimensions_ in self.Dimensions:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDimensions>%s</%sDimensions>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(Dimensions_), input_name='Dimensions')), namespace_, eol_))
        if self.RawDataArray is not None:
            self.RawDataArray.export(outfile, level, namespace_, name_='RawDataArray', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Dimensions':
            Dimensions_ = child_.text
            Dimensions_ = self.gds_validate_string(Dimensions_, node, 'Dimensions')
            self.Dimensions.append(Dimensions_)
            # validate type DasDimensions
            self.validate_DasDimensions(self.Dimensions[-1])
        elif nodeName_ == 'RawDataArray':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <RawDataArray> element')
            self.RawDataArray = obj_
            obj_.original_tagname_ = 'RawDataArray'
# end class DasRawData


class DasSpectra(GeneratedsSuper):
    """This object contains the attributes of spectra processed data. This
    includes the spectra data unit, location of the spectra data
    along the fiber optical path, information about times,
    (optional) filter related parameters, and UUIDs of the original
    raw from which the spectra file was processed and/or the UUID of
    the FBE files that were processed from the spectra files. Note
    that the actual spectrum data samples and times arrays are not
    present in the XML files but only in the HDF5 files because of
    their size. The XML files only contain references to locate the
    corresponding HDF files containing the actual spectrum samples
    and times.A universally unique identifier (UUID) for an instance
    of spectra DAS data."""
    subclass = None
    superclass = None
    def __init__(self, uuid=None, SpectraIndex=None, SpectraDescription=None, SpectraDataUnit=None, OutputDataRate=None, StartLocusIndex=None, NumberOfLoci=None, SpatialSamplingInterval=None, SpatialSamplingIntervalUnit=None, FilterType=None, WindowSize=None, WindowOverlap=None, WindowFunction=None, TransformType=None, TransformSize=None, RawReference=None, FbeReference=None, SpectraData=None, SpectraDataTime=None, Custom=None):
        self.original_tagname_ = None
        self.uuid = _cast(None, uuid)
        self.SpectraIndex = SpectraIndex
        self.validate_NonNegativeLong(self.SpectraIndex)
        self.SpectraDescription = SpectraDescription
        self.validate_String2000(self.SpectraDescription)
        self.SpectraDataUnit = SpectraDataUnit
        self.validate_String64(self.SpectraDataUnit)
        self.OutputDataRate = OutputDataRate
        self.StartLocusIndex = StartLocusIndex
        self.validate_NonNegativeLong(self.StartLocusIndex)
        self.NumberOfLoci = NumberOfLoci
        self.validate_NonNegativeLong(self.NumberOfLoci)
        self.SpatialSamplingInterval = SpatialSamplingInterval
        self.SpatialSamplingIntervalUnit = SpatialSamplingIntervalUnit
        self.validate_String64(self.SpatialSamplingIntervalUnit)
        self.FilterType = FilterType
        self.validate_String64(self.FilterType)
        self.WindowSize = WindowSize
        self.validate_NonNegativeLong(self.WindowSize)
        self.WindowOverlap = WindowOverlap
        self.validate_NonNegativeLong(self.WindowOverlap)
        self.WindowFunction = WindowFunction
        self.validate_String64(self.WindowFunction)
        self.TransformType = TransformType
        self.validate_String64(self.TransformType)
        self.TransformSize = TransformSize
        self.validate_NonNegativeLong(self.TransformSize)
        self.RawReference = RawReference
        self.validate_UuidString(self.RawReference)
        self.FbeReference = FbeReference
        self.validate_UuidString(self.FbeReference)
        self.SpectraData = SpectraData
        self.SpectraDataTime = SpectraDataTime
        self.Custom = Custom
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DasSpectra)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DasSpectra.subclass:
            return DasSpectra.subclass(*args_, **kwargs_)
        else:
            return DasSpectra(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpectraIndex(self): return self.SpectraIndex
    def set_SpectraIndex(self, SpectraIndex): self.SpectraIndex = SpectraIndex
    SpectraIndexProp = property(get_SpectraIndex, set_SpectraIndex)
    def get_SpectraDescription(self): return self.SpectraDescription
    def set_SpectraDescription(self, SpectraDescription): self.SpectraDescription = SpectraDescription
    SpectraDescriptionProp = property(get_SpectraDescription, set_SpectraDescription)
    def get_SpectraDataUnit(self): return self.SpectraDataUnit
    def set_SpectraDataUnit(self, SpectraDataUnit): self.SpectraDataUnit = SpectraDataUnit
    SpectraDataUnitProp = property(get_SpectraDataUnit, set_SpectraDataUnit)
    def get_OutputDataRate(self): return self.OutputDataRate
    def set_OutputDataRate(self, OutputDataRate): self.OutputDataRate = OutputDataRate
    OutputDataRateProp = property(get_OutputDataRate, set_OutputDataRate)
    def get_StartLocusIndex(self): return self.StartLocusIndex
    def set_StartLocusIndex(self, StartLocusIndex): self.StartLocusIndex = StartLocusIndex
    StartLocusIndexProp = property(get_StartLocusIndex, set_StartLocusIndex)
    def get_NumberOfLoci(self): return self.NumberOfLoci
    def set_NumberOfLoci(self, NumberOfLoci): self.NumberOfLoci = NumberOfLoci
    NumberOfLociProp = property(get_NumberOfLoci, set_NumberOfLoci)
    def get_SpatialSamplingInterval(self): return self.SpatialSamplingInterval
    def set_SpatialSamplingInterval(self, SpatialSamplingInterval): self.SpatialSamplingInterval = SpatialSamplingInterval
    SpatialSamplingIntervalProp = property(get_SpatialSamplingInterval, set_SpatialSamplingInterval)
    def get_SpatialSamplingIntervalUnit(self): return self.SpatialSamplingIntervalUnit
    def set_SpatialSamplingIntervalUnit(self, SpatialSamplingIntervalUnit): self.SpatialSamplingIntervalUnit = SpatialSamplingIntervalUnit
    SpatialSamplingIntervalUnitProp = property(get_SpatialSamplingIntervalUnit, set_SpatialSamplingIntervalUnit)
    def get_FilterType(self): return self.FilterType
    def set_FilterType(self, FilterType): self.FilterType = FilterType
    FilterTypeProp = property(get_FilterType, set_FilterType)
    def get_WindowSize(self): return self.WindowSize
    def set_WindowSize(self, WindowSize): self.WindowSize = WindowSize
    WindowSizeProp = property(get_WindowSize, set_WindowSize)
    def get_WindowOverlap(self): return self.WindowOverlap
    def set_WindowOverlap(self, WindowOverlap): self.WindowOverlap = WindowOverlap
    WindowOverlapProp = property(get_WindowOverlap, set_WindowOverlap)
    def get_WindowFunction(self): return self.WindowFunction
    def set_WindowFunction(self, WindowFunction): self.WindowFunction = WindowFunction
    WindowFunctionProp = property(get_WindowFunction, set_WindowFunction)
    def get_TransformType(self): return self.TransformType
    def set_TransformType(self, TransformType): self.TransformType = TransformType
    TransformTypeProp = property(get_TransformType, set_TransformType)
    def get_TransformSize(self): return self.TransformSize
    def set_TransformSize(self, TransformSize): self.TransformSize = TransformSize
    TransformSizeProp = property(get_TransformSize, set_TransformSize)
    def get_RawReference(self): return self.RawReference
    def set_RawReference(self, RawReference): self.RawReference = RawReference
    RawReferenceProp = property(get_RawReference, set_RawReference)
    def get_FbeReference(self): return self.FbeReference
    def set_FbeReference(self, FbeReference): self.FbeReference = FbeReference
    FbeReferenceProp = property(get_FbeReference, set_FbeReference)
    def get_SpectraData(self): return self.SpectraData
    def set_SpectraData(self, SpectraData): self.SpectraData = SpectraData
    SpectraDataProp = property(get_SpectraData, set_SpectraData)
    def get_SpectraDataTime(self): return self.SpectraDataTime
    def set_SpectraDataTime(self, SpectraDataTime): self.SpectraDataTime = SpectraDataTime
    SpectraDataTimeProp = property(get_SpectraDataTime, set_SpectraDataTime)
    def get_Custom(self): return self.Custom
    def set_Custom(self, Custom): self.Custom = Custom
    CustomProp = property(get_Custom, set_Custom)
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    uuidProp = property(get_uuid, set_uuid)
    def validate_NonNegativeLong(self, value):
        # Validate type NonNegativeLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeLong' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_UuidString(self, value):
        # Validate type UuidString, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_UuidString_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_UuidString_patterns_, ))
    validate_UuidString_patterns_ = [['^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$']]
    def hasContent_(self):
        if (
            self.SpectraIndex is not None or
            self.SpectraDescription is not None or
            self.SpectraDataUnit is not None or
            self.OutputDataRate is not None or
            self.StartLocusIndex is not None or
            self.NumberOfLoci is not None or
            self.SpatialSamplingInterval is not None or
            self.SpatialSamplingIntervalUnit is not None or
            self.FilterType is not None or
            self.WindowSize is not None or
            self.WindowOverlap is not None or
            self.WindowFunction is not None or
            self.TransformType is not None or
            self.TransformSize is not None or
            self.RawReference is not None or
            self.FbeReference is not None or
            self.SpectraData is not None or
            self.SpectraDataTime is not None or
            self.Custom is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DasSpectra', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DasSpectra')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DasSpectra', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DasSpectra'):
        if self.uuid is not None and 'uuid' not in already_processed:
            already_processed.add('uuid')
            outfile.write(' uuid=%s' % (quote_attrib(self.uuid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DasSpectra', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpectraIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpectraIndex>%s</%sSpectraIndex>%s' % (namespace_, self.gds_format_integer(self.SpectraIndex, input_name='SpectraIndex'), namespace_, eol_))
        if self.SpectraDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpectraDescription>%s</%sSpectraDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SpectraDescription), input_name='SpectraDescription')), namespace_, eol_))
        if self.SpectraDataUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpectraDataUnit>%s</%sSpectraDataUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SpectraDataUnit), input_name='SpectraDataUnit')), namespace_, eol_))
        if self.OutputDataRate is not None:
            self.OutputDataRate.export(outfile, level, namespace_, name_='OutputDataRate', pretty_print=pretty_print)
        if self.StartLocusIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartLocusIndex>%s</%sStartLocusIndex>%s' % (namespace_, self.gds_format_integer(self.StartLocusIndex, input_name='StartLocusIndex'), namespace_, eol_))
        if self.NumberOfLoci is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberOfLoci>%s</%sNumberOfLoci>%s' % (namespace_, self.gds_format_integer(self.NumberOfLoci, input_name='NumberOfLoci'), namespace_, eol_))
        if self.SpatialSamplingInterval is not None:
            self.SpatialSamplingInterval.export(outfile, level, namespace_, name_='SpatialSamplingInterval', pretty_print=pretty_print)
        if self.SpatialSamplingIntervalUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpatialSamplingIntervalUnit>%s</%sSpatialSamplingIntervalUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SpatialSamplingIntervalUnit), input_name='SpatialSamplingIntervalUnit')), namespace_, eol_))
        if self.FilterType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFilterType>%s</%sFilterType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FilterType), input_name='FilterType')), namespace_, eol_))
        if self.WindowSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWindowSize>%s</%sWindowSize>%s' % (namespace_, self.gds_format_integer(self.WindowSize, input_name='WindowSize'), namespace_, eol_))
        if self.WindowOverlap is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWindowOverlap>%s</%sWindowOverlap>%s' % (namespace_, self.gds_format_integer(self.WindowOverlap, input_name='WindowOverlap'), namespace_, eol_))
        if self.WindowFunction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWindowFunction>%s</%sWindowFunction>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WindowFunction), input_name='WindowFunction')), namespace_, eol_))
        if self.TransformType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransformType>%s</%sTransformType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TransformType), input_name='TransformType')), namespace_, eol_))
        if self.TransformSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransformSize>%s</%sTransformSize>%s' % (namespace_, self.gds_format_integer(self.TransformSize, input_name='TransformSize'), namespace_, eol_))
        if self.RawReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRawReference>%s</%sRawReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RawReference), input_name='RawReference')), namespace_, eol_))
        if self.FbeReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFbeReference>%s</%sFbeReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FbeReference), input_name='FbeReference')), namespace_, eol_))
        if self.SpectraData is not None:
            self.SpectraData.export(outfile, level, namespace_, name_='SpectraData', pretty_print=pretty_print)
        if self.SpectraDataTime is not None:
            self.SpectraDataTime.export(outfile, level, namespace_, name_='SpectraDataTime', pretty_print=pretty_print)
        if self.Custom is not None:
            self.Custom.export(outfile, level, namespace_, name_='Custom', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uuid', node)
        if value is not None and 'uuid' not in already_processed:
            already_processed.add('uuid')
            self.uuid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpectraIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SpectraIndex')
            self.SpectraIndex = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.SpectraIndex)
        elif nodeName_ == 'SpectraDescription':
            SpectraDescription_ = child_.text
            SpectraDescription_ = self.gds_validate_string(SpectraDescription_, node, 'SpectraDescription')
            self.SpectraDescription = SpectraDescription_
            # validate type String2000
            self.validate_String2000(self.SpectraDescription)
        elif nodeName_ == 'SpectraDataUnit':
            SpectraDataUnit_ = child_.text
            SpectraDataUnit_ = self.gds_validate_string(SpectraDataUnit_, node, 'SpectraDataUnit')
            self.SpectraDataUnit = SpectraDataUnit_
            # validate type String64
            self.validate_String64(self.SpectraDataUnit)
        elif nodeName_ == 'OutputDataRate':
            obj_ = FrequencyMeasure.factory()
            obj_.build(child_)
            self.OutputDataRate = obj_
            obj_.original_tagname_ = 'OutputDataRate'
        elif nodeName_ == 'StartLocusIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StartLocusIndex')
            self.StartLocusIndex = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.StartLocusIndex)
        elif nodeName_ == 'NumberOfLoci':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfLoci')
            self.NumberOfLoci = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.NumberOfLoci)
        elif nodeName_ == 'SpatialSamplingInterval':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.SpatialSamplingInterval = obj_
            obj_.original_tagname_ = 'SpatialSamplingInterval'
        elif nodeName_ == 'SpatialSamplingIntervalUnit':
            SpatialSamplingIntervalUnit_ = child_.text
            SpatialSamplingIntervalUnit_ = self.gds_validate_string(SpatialSamplingIntervalUnit_, node, 'SpatialSamplingIntervalUnit')
            self.SpatialSamplingIntervalUnit = SpatialSamplingIntervalUnit_
            # validate type String64
            self.validate_String64(self.SpatialSamplingIntervalUnit)
        elif nodeName_ == 'FilterType':
            FilterType_ = child_.text
            FilterType_ = self.gds_validate_string(FilterType_, node, 'FilterType')
            self.FilterType = FilterType_
            # validate type String64
            self.validate_String64(self.FilterType)
        elif nodeName_ == 'WindowSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'WindowSize')
            self.WindowSize = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.WindowSize)
        elif nodeName_ == 'WindowOverlap':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'WindowOverlap')
            self.WindowOverlap = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.WindowOverlap)
        elif nodeName_ == 'WindowFunction':
            WindowFunction_ = child_.text
            WindowFunction_ = self.gds_validate_string(WindowFunction_, node, 'WindowFunction')
            self.WindowFunction = WindowFunction_
            # validate type String64
            self.validate_String64(self.WindowFunction)
        elif nodeName_ == 'TransformType':
            TransformType_ = child_.text
            TransformType_ = self.gds_validate_string(TransformType_, node, 'TransformType')
            self.TransformType = TransformType_
            # validate type String64
            self.validate_String64(self.TransformType)
        elif nodeName_ == 'TransformSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TransformSize')
            self.TransformSize = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.TransformSize)
        elif nodeName_ == 'RawReference':
            RawReference_ = child_.text
            RawReference_ = self.gds_validate_string(RawReference_, node, 'RawReference')
            self.RawReference = RawReference_
            # validate type UuidString
            self.validate_UuidString(self.RawReference)
        elif nodeName_ == 'FbeReference':
            FbeReference_ = child_.text
            FbeReference_ = self.gds_validate_string(FbeReference_, node, 'FbeReference')
            self.FbeReference = FbeReference_
            # validate type UuidString
            self.validate_UuidString(self.FbeReference)
        elif nodeName_ == 'SpectraData':
            obj_ = DasSpectraData.factory()
            obj_.build(child_)
            self.SpectraData = obj_
            obj_.original_tagname_ = 'SpectraData'
        elif nodeName_ == 'SpectraDataTime':
            obj_ = DasTimeArray.factory()
            obj_.build(child_)
            self.SpectraDataTime = obj_
            obj_.original_tagname_ = 'SpectraDataTime'
        elif nodeName_ == 'Custom':
            obj_ = DasCustom.factory()
            obj_.build(child_)
            self.Custom = obj_
            obj_.original_tagname_ = 'Custom'
# end class DasSpectra


class DasSpectraData(GeneratedsSuper):
    """Three-dimensional array (loci, time, transform) containing spectrum
    data samples. Spectrum data is processed data obtained by
    applying a mathematical transformation function to the DAS raw
    data acquired by the acquisition system. The array is 3D and
    contains TransformSize points for each locus and time for which
    the data is provided. For example, many service providers will
    provide Fourier transformed versions of the raw data to
    customers, but other transformation functions are also allowed."""
    subclass = None
    superclass = None
    def __init__(self, StartFrequency=None, EndFrequency=None, Dimensions=None, SpectraDataArray=None):
        self.original_tagname_ = None
        self.StartFrequency = StartFrequency
        self.EndFrequency = EndFrequency
        if Dimensions is None:
            self.Dimensions = []
        else:
            self.Dimensions = Dimensions
        self.SpectraDataArray = SpectraDataArray
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DasSpectraData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DasSpectraData.subclass:
            return DasSpectraData.subclass(*args_, **kwargs_)
        else:
            return DasSpectraData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartFrequency(self): return self.StartFrequency
    def set_StartFrequency(self, StartFrequency): self.StartFrequency = StartFrequency
    StartFrequencyProp = property(get_StartFrequency, set_StartFrequency)
    def get_EndFrequency(self): return self.EndFrequency
    def set_EndFrequency(self, EndFrequency): self.EndFrequency = EndFrequency
    EndFrequencyProp = property(get_EndFrequency, set_EndFrequency)
    def get_Dimensions(self): return self.Dimensions
    def set_Dimensions(self, Dimensions): self.Dimensions = Dimensions
    def add_Dimensions(self, value): self.Dimensions.append(value)
    def insert_Dimensions_at(self, index, value): self.Dimensions.insert(index, value)
    def replace_Dimensions_at(self, index, value): self.Dimensions[index] = value
    DimensionsProp = property(get_Dimensions, set_Dimensions)
    def get_SpectraDataArray(self): return self.SpectraDataArray
    def set_SpectraDataArray(self, SpectraDataArray): self.SpectraDataArray = SpectraDataArray
    SpectraDataArrayProp = property(get_SpectraDataArray, set_SpectraDataArray)
    def validate_DasDimensions(self, value):
        # Validate type DasDimensions, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['frequency', 'locus', 'time']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DasDimensions' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.StartFrequency is not None or
            self.EndFrequency is not None or
            self.Dimensions or
            self.SpectraDataArray is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DasSpectraData', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DasSpectraData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DasSpectraData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DasSpectraData'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DasSpectraData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StartFrequency is not None:
            self.StartFrequency.export(outfile, level, namespace_, name_='StartFrequency', pretty_print=pretty_print)
        if self.EndFrequency is not None:
            self.EndFrequency.export(outfile, level, namespace_, name_='EndFrequency', pretty_print=pretty_print)
        for Dimensions_ in self.Dimensions:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDimensions>%s</%sDimensions>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(Dimensions_), input_name='Dimensions')), namespace_, eol_))
        if self.SpectraDataArray is not None:
            self.SpectraDataArray.export(outfile, level, namespace_, name_='SpectraDataArray', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartFrequency':
            obj_ = FrequencyMeasure.factory()
            obj_.build(child_)
            self.StartFrequency = obj_
            obj_.original_tagname_ = 'StartFrequency'
        elif nodeName_ == 'EndFrequency':
            obj_ = FrequencyMeasure.factory()
            obj_.build(child_)
            self.EndFrequency = obj_
            obj_.original_tagname_ = 'EndFrequency'
        elif nodeName_ == 'Dimensions':
            Dimensions_ = child_.text
            Dimensions_ = self.gds_validate_string(Dimensions_, node, 'Dimensions')
            self.Dimensions.append(Dimensions_)
            # validate type DasDimensions
            self.validate_DasDimensions(self.Dimensions[-1])
        elif nodeName_ == 'SpectraDataArray':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <SpectraDataArray> element')
            self.SpectraDataArray = obj_
            obj_.original_tagname_ = 'SpectraDataArray'
# end class DasSpectraData


class DasTimeArray(GeneratedsSuper):
    """The Times arrays contain the â€˜scanâ€™ or â€˜traceâ€™ times at which the
    raw, FBE and spectrum arrays were acquired or processed: - For
    raw data, these are the times for which all loci in the
    â€˜scannedâ€™ fiber section were interrogated by a single pulse of
    the DAS measurement system. - For the processed data, these are
    the times of the first sample in the time window used in the
    frequency filter or transformation function to calculate the FBE
    or spectrum data."""
    subclass = None
    superclass = None
    def __init__(self, StartTime=None, EndTime=None, TimeArray=None):
        self.original_tagname_ = None
        self.StartTime = StartTime
        self.validate_TimeStamp(self.StartTime)
        self.EndTime = EndTime
        self.validate_TimeStamp(self.EndTime)
        self.TimeArray = TimeArray
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DasTimeArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DasTimeArray.subclass:
            return DasTimeArray.subclass(*args_, **kwargs_)
        else:
            return DasTimeArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartTime(self): return self.StartTime
    def set_StartTime(self, StartTime): self.StartTime = StartTime
    StartTimeProp = property(get_StartTime, set_StartTime)
    def get_EndTime(self): return self.EndTime
    def set_EndTime(self, EndTime): self.EndTime = EndTime
    EndTimeProp = property(get_EndTime, set_EndTime)
    def get_TimeArray(self): return self.TimeArray
    def set_TimeArray(self, TimeArray): self.TimeArray = TimeArray
    TimeArrayProp = property(get_TimeArray, set_TimeArray)
    def validate_TimeStamp(self, value):
        # Validate type TimeStamp, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TimeStamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TimeStamp_patterns_, ))
    validate_TimeStamp_patterns_ = [['^.+T.+[Z+\\-].*$']]
    def hasContent_(self):
        if (
            self.StartTime is not None or
            self.EndTime is not None or
            self.TimeArray is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DasTimeArray', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DasTimeArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DasTimeArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DasTimeArray'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DasTimeArray', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StartTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartTime>%s</%sStartTime>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StartTime), input_name='StartTime')), namespace_, eol_))
        if self.EndTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndTime>%s</%sEndTime>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EndTime), input_name='EndTime')), namespace_, eol_))
        if self.TimeArray is not None:
            self.TimeArray.export(outfile, level, namespace_, name_='TimeArray', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartTime':
            StartTime_ = child_.text
            StartTime_ = self.gds_validate_string(StartTime_, node, 'StartTime')
            self.StartTime = StartTime_
            # validate type TimeStamp
            self.validate_TimeStamp(self.StartTime)
        elif nodeName_ == 'EndTime':
            EndTime_ = child_.text
            EndTime_ = self.gds_validate_string(EndTime_, node, 'EndTime')
            self.EndTime = EndTime_
            # validate type TimeStamp
            self.validate_TimeStamp(self.EndTime)
        elif nodeName_ == 'TimeArray':
            obj_ = IntegerExternalArray.factory()
            obj_.build(child_)
            self.TimeArray = obj_
            obj_.original_tagname_ = 'TimeArray'
# end class DasTimeArray


class AbstractDtsEquipment(GeneratedsSuper):
    """The abstract class of equipment in the optical path from which all
    components in the optical path inherit."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, Manufacturer=None, ManufacturingDate=None, Type=None, SupplyDate=None, SupplierModelNumber=None, SoftwareVersion=None, Comment=None, Supplier=None, extensiontype_=None):
        self.original_tagname_ = None
        self.Name = Name
        self.validate_String64(self.Name)
        self.Manufacturer = Manufacturer
        self.validate_String64(self.Manufacturer)
        if isinstance(ManufacturingDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ManufacturingDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ManufacturingDate
        self.ManufacturingDate = initvalue_
        self.Type = Type
        self.validate_String64(self.Type)
        if isinstance(SupplyDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(SupplyDate, '%Y-%m-%d').date()
        else:
            initvalue_ = SupplyDate
        self.SupplyDate = initvalue_
        self.SupplierModelNumber = SupplierModelNumber
        self.validate_String64(self.SupplierModelNumber)
        self.SoftwareVersion = SoftwareVersion
        self.validate_String64(self.SoftwareVersion)
        self.Comment = Comment
        self.validate_String2000(self.Comment)
        self.Supplier = Supplier
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractDtsEquipment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractDtsEquipment.subclass:
            return AbstractDtsEquipment.subclass(*args_, **kwargs_)
        else:
            return AbstractDtsEquipment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_Manufacturer(self): return self.Manufacturer
    def set_Manufacturer(self, Manufacturer): self.Manufacturer = Manufacturer
    ManufacturerProp = property(get_Manufacturer, set_Manufacturer)
    def get_ManufacturingDate(self): return self.ManufacturingDate
    def set_ManufacturingDate(self, ManufacturingDate): self.ManufacturingDate = ManufacturingDate
    ManufacturingDateProp = property(get_ManufacturingDate, set_ManufacturingDate)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    TypeProp = property(get_Type, set_Type)
    def get_SupplyDate(self): return self.SupplyDate
    def set_SupplyDate(self, SupplyDate): self.SupplyDate = SupplyDate
    SupplyDateProp = property(get_SupplyDate, set_SupplyDate)
    def get_SupplierModelNumber(self): return self.SupplierModelNumber
    def set_SupplierModelNumber(self, SupplierModelNumber): self.SupplierModelNumber = SupplierModelNumber
    SupplierModelNumberProp = property(get_SupplierModelNumber, set_SupplierModelNumber)
    def get_SoftwareVersion(self): return self.SoftwareVersion
    def set_SoftwareVersion(self, SoftwareVersion): self.SoftwareVersion = SoftwareVersion
    SoftwareVersionProp = property(get_SoftwareVersion, set_SoftwareVersion)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_Supplier(self): return self.Supplier
    def set_Supplier(self, Supplier): self.Supplier = Supplier
    SupplierProp = property(get_Supplier, set_Supplier)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Manufacturer is not None or
            self.ManufacturingDate is not None or
            self.Type is not None or
            self.SupplyDate is not None or
            self.SupplierModelNumber is not None or
            self.SoftwareVersion is not None or
            self.Comment is not None or
            self.Supplier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractDtsEquipment', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDtsEquipment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractDtsEquipment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractDtsEquipment'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractDtsEquipment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ManufacturingDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturingDate>%s</%sManufacturingDate>%s' % (namespace_, self.gds_format_date(self.ManufacturingDate, input_name='ManufacturingDate'), namespace_, eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sType>%s</%sType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), namespace_, eol_))
        if self.SupplyDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSupplyDate>%s</%sSupplyDate>%s' % (namespace_, self.gds_format_date(self.SupplyDate, input_name='SupplyDate'), namespace_, eol_))
        if self.SupplierModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSupplierModelNumber>%s</%sSupplierModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SupplierModelNumber), input_name='SupplierModelNumber')), namespace_, eol_))
        if self.SoftwareVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSoftwareVersion>%s</%sSoftwareVersion>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SoftwareVersion), input_name='SoftwareVersion')), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
        if self.Supplier is not None:
            self.Supplier.export(outfile, level, namespace_, name_='Supplier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
            # validate type String64
            self.validate_String64(self.Manufacturer)
        elif nodeName_ == 'ManufacturingDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ManufacturingDate = dval_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type String64
            self.validate_String64(self.Type)
        elif nodeName_ == 'SupplyDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.SupplyDate = dval_
        elif nodeName_ == 'SupplierModelNumber':
            SupplierModelNumber_ = child_.text
            SupplierModelNumber_ = self.gds_validate_string(SupplierModelNumber_, node, 'SupplierModelNumber')
            self.SupplierModelNumber = SupplierModelNumber_
            # validate type String64
            self.validate_String64(self.SupplierModelNumber)
        elif nodeName_ == 'SoftwareVersion':
            SoftwareVersion_ = child_.text
            SoftwareVersion_ = self.gds_validate_string(SoftwareVersion_, node, 'SoftwareVersion')
            self.SoftwareVersion = SoftwareVersion_
            # validate type String64
            self.validate_String64(self.SoftwareVersion)
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        elif nodeName_ == 'Supplier':
            obj_ = BusinessAssociate.factory()
            obj_.build(child_)
            self.Supplier = obj_
            obj_.original_tagname_ = 'Supplier'
# end class AbstractDtsEquipment


class DtsPatchCord(GeneratedsSuper):
    """Information regarding the patch cord used to connect the instrument
    box to the start of the optical fiber path."""
    subclass = None
    superclass = None
    def __init__(self, FiberLength=None, Description=None):
        self.original_tagname_ = None
        self.FiberLength = FiberLength
        self.Description = Description
        self.validate_String2000(self.Description)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DtsPatchCord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DtsPatchCord.subclass:
            return DtsPatchCord.subclass(*args_, **kwargs_)
        else:
            return DtsPatchCord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FiberLength(self): return self.FiberLength
    def set_FiberLength(self, FiberLength): self.FiberLength = FiberLength
    FiberLengthProp = property(get_FiberLength, set_FiberLength)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    DescriptionProp = property(get_Description, set_Description)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.FiberLength is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DtsPatchCord', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DtsPatchCord')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DtsPatchCord', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DtsPatchCord'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DtsPatchCord', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FiberLength is not None:
            self.FiberLength.export(outfile, level, namespace_, name_='FiberLength', pretty_print=pretty_print)
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FiberLength':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.FiberLength = obj_
            obj_.original_tagname_ = 'FiberLength'
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            # validate type String2000
            self.validate_String2000(self.Description)
# end class DtsPatchCord


class Instrument(AbstractDtsEquipment):
    """The general class of an instrument, including vendor information, in
    the installed system."""
    subclass = None
    superclass = AbstractDtsEquipment
    def __init__(self, Name=None, Manufacturer=None, ManufacturingDate=None, Type=None, SupplyDate=None, SupplierModelNumber=None, SoftwareVersion=None, Comment=None, Supplier=None, InstrumentVendor=None, extensiontype_=None):
        self.original_tagname_ = None
        super(Instrument, self).__init__(Name, Manufacturer, ManufacturingDate, Type, SupplyDate, SupplierModelNumber, SoftwareVersion, Comment, Supplier, extensiontype_, )
        self.InstrumentVendor = InstrumentVendor
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Instrument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Instrument.subclass:
            return Instrument.subclass(*args_, **kwargs_)
        else:
            return Instrument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InstrumentVendor(self): return self.InstrumentVendor
    def set_InstrumentVendor(self, InstrumentVendor): self.InstrumentVendor = InstrumentVendor
    InstrumentVendorProp = property(get_InstrumentVendor, set_InstrumentVendor)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.InstrumentVendor is not None or
            super(Instrument, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='Instrument', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Instrument')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='Instrument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='Instrument'):
        super(Instrument, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Instrument')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='Instrument', fromsubclass_=False, pretty_print=True):
        super(Instrument, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InstrumentVendor is not None:
            self.InstrumentVendor.export(outfile, level, namespace_, name_='InstrumentVendor', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Instrument, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InstrumentVendor':
            obj_ = BusinessAssociate.factory()
            obj_.build(child_)
            self.InstrumentVendor = obj_
            obj_.original_tagname_ = 'InstrumentVendor'
        super(Instrument, self).buildChildren(child_, node, nodeName_, True)
# end class Instrument


class DtsCalibration(GeneratedsSuper):
    """Calibration parameters vary from vendor to vendor, depending on the
    calibration method being used. This is a general type that
    allows a calibration date, business associate, and many
    name/value pairs.A unique identifier (UID) of an instance of
    DtsCalibration."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, DTimCalibration=None, CalibratedBy=None, CalibrationProtocol=None, Parameter=None, Remark=None, ExtensionNameValue=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        if isinstance(DTimCalibration, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DTimCalibration, '%Y-%m-%d').date()
        else:
            initvalue_ = DTimCalibration
        self.DTimCalibration = initvalue_
        self.CalibratedBy = CalibratedBy
        self.validate_String64(self.CalibratedBy)
        self.CalibrationProtocol = CalibrationProtocol
        self.validate_String64(self.CalibrationProtocol)
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
        self.Remark = Remark
        self.validate_String2000(self.Remark)
        if ExtensionNameValue is None:
            self.ExtensionNameValue = []
        else:
            self.ExtensionNameValue = ExtensionNameValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DtsCalibration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DtsCalibration.subclass:
            return DtsCalibration.subclass(*args_, **kwargs_)
        else:
            return DtsCalibration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DTimCalibration(self): return self.DTimCalibration
    def set_DTimCalibration(self, DTimCalibration): self.DTimCalibration = DTimCalibration
    DTimCalibrationProp = property(get_DTimCalibration, set_DTimCalibration)
    def get_CalibratedBy(self): return self.CalibratedBy
    def set_CalibratedBy(self, CalibratedBy): self.CalibratedBy = CalibratedBy
    CalibratedByProp = property(get_CalibratedBy, set_CalibratedBy)
    def get_CalibrationProtocol(self): return self.CalibrationProtocol
    def set_CalibrationProtocol(self, CalibrationProtocol): self.CalibrationProtocol = CalibrationProtocol
    CalibrationProtocolProp = property(get_CalibrationProtocol, set_CalibrationProtocol)
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    def add_Parameter(self, value): self.Parameter.append(value)
    def insert_Parameter_at(self, index, value): self.Parameter.insert(index, value)
    def replace_Parameter_at(self, index, value): self.Parameter[index] = value
    ParameterProp = property(get_Parameter, set_Parameter)
    def get_Remark(self): return self.Remark
    def set_Remark(self, Remark): self.Remark = Remark
    RemarkProp = property(get_Remark, set_Remark)
    def get_ExtensionNameValue(self): return self.ExtensionNameValue
    def set_ExtensionNameValue(self, ExtensionNameValue): self.ExtensionNameValue = ExtensionNameValue
    def add_ExtensionNameValue(self, value): self.ExtensionNameValue.append(value)
    def insert_ExtensionNameValue_at(self, index, value): self.ExtensionNameValue.insert(index, value)
    def replace_ExtensionNameValue_at(self, index, value): self.ExtensionNameValue[index] = value
    ExtensionNameValueProp = property(get_ExtensionNameValue, set_ExtensionNameValue)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.DTimCalibration is not None or
            self.CalibratedBy is not None or
            self.CalibrationProtocol is not None or
            self.Parameter or
            self.Remark is not None or
            self.ExtensionNameValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DtsCalibration', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DtsCalibration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DtsCalibration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DtsCalibration'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DtsCalibration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DTimCalibration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTimCalibration>%s</%sDTimCalibration>%s' % (namespace_, self.gds_format_date(self.DTimCalibration, input_name='DTimCalibration'), namespace_, eol_))
        if self.CalibratedBy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCalibratedBy>%s</%sCalibratedBy>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CalibratedBy), input_name='CalibratedBy')), namespace_, eol_))
        if self.CalibrationProtocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCalibrationProtocol>%s</%sCalibrationProtocol>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CalibrationProtocol), input_name='CalibrationProtocol')), namespace_, eol_))
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, namespace_, name_='Parameter', pretty_print=pretty_print)
        if self.Remark is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRemark>%s</%sRemark>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Remark), input_name='Remark')), namespace_, eol_))
        for ExtensionNameValue_ in self.ExtensionNameValue:
            ExtensionNameValue_.export(outfile, level, namespace_, name_='ExtensionNameValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DTimCalibration':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DTimCalibration = dval_
        elif nodeName_ == 'CalibratedBy':
            CalibratedBy_ = child_.text
            CalibratedBy_ = self.gds_validate_string(CalibratedBy_, node, 'CalibratedBy')
            self.CalibratedBy = CalibratedBy_
            # validate type String64
            self.validate_String64(self.CalibratedBy)
        elif nodeName_ == 'CalibrationProtocol':
            CalibrationProtocol_ = child_.text
            CalibrationProtocol_ = self.gds_validate_string(CalibrationProtocol_, node, 'CalibrationProtocol')
            self.CalibrationProtocol = CalibrationProtocol_
            # validate type String64
            self.validate_String64(self.CalibrationProtocol)
        elif nodeName_ == 'Parameter':
            obj_ = CalibrationParameter.factory()
            obj_.build(child_)
            self.Parameter.append(obj_)
            obj_.original_tagname_ = 'Parameter'
        elif nodeName_ == 'Remark':
            Remark_ = child_.text
            Remark_ = self.gds_validate_string(Remark_, node, 'Remark')
            self.Remark = Remark_
            # validate type String2000
            self.validate_String2000(self.Remark)
        elif nodeName_ == 'ExtensionNameValue':
            obj_ = ExtensionNameValue.factory()
            obj_.build(child_)
            self.ExtensionNameValue.append(obj_)
            obj_.original_tagname_ = 'ExtensionNameValue'
# end class DtsCalibration


class AbstractAttenuationMeasure(GeneratedsSuper):
    """Abstract class of attenuation measure."""
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractAttenuationMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractAttenuationMeasure.subclass:
            return AbstractAttenuationMeasure.subclass(*args_, **kwargs_)
        else:
            return AbstractAttenuationMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractAttenuationMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractAttenuationMeasure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractAttenuationMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractAttenuationMeasure'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractAttenuationMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractAttenuationMeasure


class AbstractCable(GeneratedsSuper):
    """The abstract class of class."""
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractCable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractCable.subclass:
            return AbstractCable.subclass(*args_, **kwargs_)
        else:
            return AbstractCable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractCable', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractCable', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractCable'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractCable', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractCable


class AbstractFiberFacility(GeneratedsSuper):
    """The abstract base type of FiberFacility."""
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractFiberFacility)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractFiberFacility.subclass:
            return AbstractFiberFacility.subclass(*args_, **kwargs_)
        else:
            return AbstractFiberFacility(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractFiberFacility', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractFiberFacility')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractFiberFacility', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractFiberFacility'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractFiberFacility', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractFiberFacility


class FiberCommon(AbstractDtsEquipment):
    """A specialization of the equipment class containing information on
    reflectance, loss and reason for decommissioning, from which all
    equipment in the optical path inherits.Unique identifier of this
    object."""
    subclass = None
    superclass = AbstractDtsEquipment
    def __init__(self, Name=None, Manufacturer=None, ManufacturingDate=None, Type=None, SupplyDate=None, SupplierModelNumber=None, SoftwareVersion=None, Comment=None, Supplier=None, uid=None, Reflectance=None, Loss=None, ReasonForDecommissioning=None, extensiontype_=None):
        self.original_tagname_ = None
        super(FiberCommon, self).__init__(Name, Manufacturer, ManufacturingDate, Type, SupplyDate, SupplierModelNumber, SoftwareVersion, Comment, Supplier, extensiontype_, )
        self.uid = _cast(None, uid)
        self.Reflectance = Reflectance
        self.Loss = Loss
        self.ReasonForDecommissioning = ReasonForDecommissioning
        self.validate_String2000(self.ReasonForDecommissioning)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberCommon)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberCommon.subclass:
            return FiberCommon.subclass(*args_, **kwargs_)
        else:
            return FiberCommon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reflectance(self): return self.Reflectance
    def set_Reflectance(self, Reflectance): self.Reflectance = Reflectance
    ReflectanceProp = property(get_Reflectance, set_Reflectance)
    def get_Loss(self): return self.Loss
    def set_Loss(self, Loss): self.Loss = Loss
    LossProp = property(get_Loss, set_Loss)
    def get_ReasonForDecommissioning(self): return self.ReasonForDecommissioning
    def set_ReasonForDecommissioning(self, ReasonForDecommissioning): self.ReasonForDecommissioning = ReasonForDecommissioning
    ReasonForDecommissioningProp = property(get_ReasonForDecommissioning, set_ReasonForDecommissioning)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Reflectance is not None or
            self.Loss is not None or
            self.ReasonForDecommissioning is not None or
            super(FiberCommon, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberCommon', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberCommon')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberCommon', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberCommon'):
        super(FiberCommon, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FiberCommon')
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberCommon', fromsubclass_=False, pretty_print=True):
        super(FiberCommon, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Reflectance is not None:
            self.Reflectance.export(outfile, level, namespace_, name_='Reflectance', pretty_print=pretty_print)
        if self.Loss is not None:
            self.Loss.export(outfile, level, namespace_, name_='Loss', pretty_print=pretty_print)
        if self.ReasonForDecommissioning is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReasonForDecommissioning>%s</%sReasonForDecommissioning>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ReasonForDecommissioning), input_name='ReasonForDecommissioning')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(FiberCommon, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reflectance':
            obj_ = DimensionlessMeasure.factory()
            obj_.build(child_)
            self.Reflectance = obj_
            obj_.original_tagname_ = 'Reflectance'
        elif nodeName_ == 'Loss':
            obj_ = DimensionlessMeasure.factory()
            obj_.build(child_)
            self.Loss = obj_
            obj_.original_tagname_ = 'Loss'
        elif nodeName_ == 'ReasonForDecommissioning':
            ReasonForDecommissioning_ = child_.text
            ReasonForDecommissioning_ = self.gds_validate_string(ReasonForDecommissioning_, node, 'ReasonForDecommissioning')
            self.ReasonForDecommissioning = ReasonForDecommissioning_
            # validate type String2000
            self.validate_String2000(self.ReasonForDecommissioning)
        super(FiberCommon, self).buildChildren(child_, node, nodeName_, True)
# end class FiberCommon


class FiberConnection(FiberCommon):
    """A connection component within the optical path."""
    subclass = None
    superclass = FiberCommon
    def __init__(self, Name=None, Manufacturer=None, ManufacturingDate=None, Type=None, SupplyDate=None, SupplierModelNumber=None, SoftwareVersion=None, Comment=None, Supplier=None, uid=None, Reflectance=None, Loss=None, ReasonForDecommissioning=None, ConnectorType=None, EndType=None):
        self.original_tagname_ = None
        super(FiberConnection, self).__init__(Name, Manufacturer, ManufacturingDate, Type, SupplyDate, SupplierModelNumber, SoftwareVersion, Comment, Supplier, uid, Reflectance, Loss, ReasonForDecommissioning, )
        self.ConnectorType = ConnectorType
        self.validate_FiberConnectorTypes(self.ConnectorType)
        self.EndType = EndType
        self.validate_FiberEndType(self.EndType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberConnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberConnection.subclass:
            return FiberConnection.subclass(*args_, **kwargs_)
        else:
            return FiberConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConnectorType(self): return self.ConnectorType
    def set_ConnectorType(self, ConnectorType): self.ConnectorType = ConnectorType
    ConnectorTypeProp = property(get_ConnectorType, set_ConnectorType)
    def get_EndType(self): return self.EndType
    def set_EndType(self, EndType): self.EndType = EndType
    EndTypeProp = property(get_EndType, set_EndType)
    def validate_FiberConnectorTypes(self, value):
        # Validate type FiberConnectorTypes, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['dry mate', 'wet mate']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FiberConnectorTypes' % {"value" : value.encode("utf-8")} )
    def validate_FiberEndType(self, value):
        # Validate type FiberEndType, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['angle polished', 'flat polished']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FiberEndType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ConnectorType is not None or
            self.EndType is not None or
            super(FiberConnection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberConnection', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberConnection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberConnection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberConnection'):
        super(FiberConnection, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FiberConnection')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberConnection', fromsubclass_=False, pretty_print=True):
        super(FiberConnection, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConnectorType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConnectorType>%s</%sConnectorType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ConnectorType), input_name='ConnectorType')), namespace_, eol_))
        if self.EndType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndType>%s</%sEndType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EndType), input_name='EndType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FiberConnection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConnectorType':
            ConnectorType_ = child_.text
            ConnectorType_ = self.gds_validate_string(ConnectorType_, node, 'ConnectorType')
            self.ConnectorType = ConnectorType_
            # validate type FiberConnectorTypes
            self.validate_FiberConnectorTypes(self.ConnectorType)
        elif nodeName_ == 'EndType':
            EndType_ = child_.text
            EndType_ = self.gds_validate_string(EndType_, node, 'EndType')
            self.EndType = EndType_
            # validate type FiberEndType
            self.validate_FiberEndType(self.EndType)
        super(FiberConnection, self).buildChildren(child_, node, nodeName_, True)
# end class FiberConnection


class FiberControlLine(AbstractCable):
    """Information regarding the control line into which a fiber cable may
    be pumped to measure a facility.A reference to the control line
    string in a completion data object that represents this control
    line containing a fiber."""
    subclass = None
    superclass = AbstractCable
    def __init__(self, downholeControlLineReference=None, Size=None, Material=None, EncapsulationType=None, EncapsulationSize=None, Comment=None, PumpActivity=None):
        self.original_tagname_ = None
        super(FiberControlLine, self).__init__()
        self.downholeControlLineReference = _cast(None, downholeControlLineReference)
        self.Size = Size
        self.validate_ControlLineSize(self.Size)
        self.Material = Material
        self.validate_ControlLineMaterial(self.Material)
        self.EncapsulationType = EncapsulationType
        self.validate_ControlLineEncapsulationType(self.EncapsulationType)
        self.EncapsulationSize = EncapsulationSize
        self.validate_ControlLineEncapsulationSize(self.EncapsulationSize)
        self.Comment = Comment
        self.validate_String2000(self.Comment)
        if PumpActivity is None:
            self.PumpActivity = []
        else:
            self.PumpActivity = PumpActivity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberControlLine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberControlLine.subclass:
            return FiberControlLine.subclass(*args_, **kwargs_)
        else:
            return FiberControlLine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Size(self): return self.Size
    def set_Size(self, Size): self.Size = Size
    SizeProp = property(get_Size, set_Size)
    def get_Material(self): return self.Material
    def set_Material(self, Material): self.Material = Material
    MaterialProp = property(get_Material, set_Material)
    def get_EncapsulationType(self): return self.EncapsulationType
    def set_EncapsulationType(self, EncapsulationType): self.EncapsulationType = EncapsulationType
    EncapsulationTypeProp = property(get_EncapsulationType, set_EncapsulationType)
    def get_EncapsulationSize(self): return self.EncapsulationSize
    def set_EncapsulationSize(self, EncapsulationSize): self.EncapsulationSize = EncapsulationSize
    EncapsulationSizeProp = property(get_EncapsulationSize, set_EncapsulationSize)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_PumpActivity(self): return self.PumpActivity
    def set_PumpActivity(self, PumpActivity): self.PumpActivity = PumpActivity
    def add_PumpActivity(self, value): self.PumpActivity.append(value)
    def insert_PumpActivity_at(self, index, value): self.PumpActivity.insert(index, value)
    def replace_PumpActivity_at(self, index, value): self.PumpActivity[index] = value
    PumpActivityProp = property(get_PumpActivity, set_PumpActivity)
    def get_downholeControlLineReference(self): return self.downholeControlLineReference
    def set_downholeControlLineReference(self, downholeControlLineReference): self.downholeControlLineReference = downholeControlLineReference
    downholeControlLineReferenceProp = property(get_downholeControlLineReference, set_downholeControlLineReference)
    def validate_ControlLineSize(self, value):
        # Validate type ControlLineSize, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['diameter 0.25 in weight 0.028 lb/ft', 'diameter 0.25 in weight 0.035 lb/ft', 'diameter 0.375 in weight 0.048 lb/ft']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ControlLineSize' % {"value" : value.encode("utf-8")} )
    def validate_ControlLineMaterial(self, value):
        # Validate type ControlLineMaterial, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inc 825', 'ss 316']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ControlLineMaterial' % {"value" : value.encode("utf-8")} )
    def validate_ControlLineEncapsulationType(self, value):
        # Validate type ControlLineEncapsulationType, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['round', 'square']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ControlLineEncapsulationType' % {"value" : value.encode("utf-8")} )
    def validate_ControlLineEncapsulationSize(self, value):
        # Validate type ControlLineEncapsulationSize, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['11x11', '23x11']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ControlLineEncapsulationSize' % {"value" : value.encode("utf-8")} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Size is not None or
            self.Material is not None or
            self.EncapsulationType is not None or
            self.EncapsulationSize is not None or
            self.Comment is not None or
            self.PumpActivity or
            super(FiberControlLine, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberControlLine', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberControlLine')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberControlLine', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberControlLine'):
        super(FiberControlLine, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FiberControlLine')
        if self.downholeControlLineReference is not None and 'downholeControlLineReference' not in already_processed:
            already_processed.add('downholeControlLineReference')
            outfile.write(' downholeControlLineReference=%s' % (quote_attrib(self.downholeControlLineReference), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberControlLine', fromsubclass_=False, pretty_print=True):
        super(FiberControlLine, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSize>%s</%sSize>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Size), input_name='Size')), namespace_, eol_))
        if self.Material is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaterial>%s</%sMaterial>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Material), input_name='Material')), namespace_, eol_))
        if self.EncapsulationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEncapsulationType>%s</%sEncapsulationType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EncapsulationType), input_name='EncapsulationType')), namespace_, eol_))
        if self.EncapsulationSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEncapsulationSize>%s</%sEncapsulationSize>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EncapsulationSize), input_name='EncapsulationSize')), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
        for PumpActivity_ in self.PumpActivity:
            PumpActivity_.export(outfile, level, namespace_, name_='PumpActivity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('downholeControlLineReference', node)
        if value is not None and 'downholeControlLineReference' not in already_processed:
            already_processed.add('downholeControlLineReference')
            self.downholeControlLineReference = value
        super(FiberControlLine, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Size':
            Size_ = child_.text
            Size_ = self.gds_validate_string(Size_, node, 'Size')
            self.Size = Size_
            # validate type ControlLineSize
            self.validate_ControlLineSize(self.Size)
        elif nodeName_ == 'Material':
            Material_ = child_.text
            Material_ = self.gds_validate_string(Material_, node, 'Material')
            self.Material = Material_
            # validate type ControlLineMaterial
            self.validate_ControlLineMaterial(self.Material)
        elif nodeName_ == 'EncapsulationType':
            EncapsulationType_ = child_.text
            EncapsulationType_ = self.gds_validate_string(EncapsulationType_, node, 'EncapsulationType')
            self.EncapsulationType = EncapsulationType_
            # validate type ControlLineEncapsulationType
            self.validate_ControlLineEncapsulationType(self.EncapsulationType)
        elif nodeName_ == 'EncapsulationSize':
            EncapsulationSize_ = child_.text
            EncapsulationSize_ = self.gds_validate_string(EncapsulationSize_, node, 'EncapsulationSize')
            self.EncapsulationSize = EncapsulationSize_
            # validate type ControlLineEncapsulationSize
            self.validate_ControlLineEncapsulationSize(self.EncapsulationSize)
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        elif nodeName_ == 'PumpActivity':
            obj_ = FiberPumpActivity.factory()
            obj_.build(child_)
            self.PumpActivity.append(obj_)
            obj_.original_tagname_ = 'PumpActivity'
        super(FiberControlLine, self).buildChildren(child_, node, nodeName_, True)
# end class FiberControlLine


class FiberConveyance(GeneratedsSuper):
    """The means by which this fiber segment is conveyed into the well.
    Choices: permanent, intervention, or control line conveyance
    method."""
    subclass = None
    superclass = None
    def __init__(self, Cable=None):
        self.original_tagname_ = None
        self.Cable = Cable
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberConveyance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberConveyance.subclass:
            return FiberConveyance.subclass(*args_, **kwargs_)
        else:
            return FiberConveyance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cable(self): return self.Cable
    def set_Cable(self, Cable): self.Cable = Cable
    CableProp = property(get_Cable, set_Cable)
    def hasContent_(self):
        if (
            self.Cable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberConveyance', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberConveyance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberConveyance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberConveyance'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberConveyance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cable is not None:
            self.Cable.export(outfile, level, namespace_, name_='Cable', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cable':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Cable> element')
            self.Cable = obj_
            obj_.original_tagname_ = 'Cable'
# end class FiberConveyance


class FiberFacilityGeneric(AbstractFiberFacility):
    """If a facility mapping is not explicitly to a well or pipeline, use
    this element to show what optical path distances map to lengths
    in a generic facility."""
    subclass = None
    superclass = AbstractFiberFacility
    def __init__(self, FacilityName=None, FacilityKind=None):
        self.original_tagname_ = None
        super(FiberFacilityGeneric, self).__init__()
        self.FacilityName = FacilityName
        self.validate_String64(self.FacilityName)
        self.FacilityKind = FacilityKind
        self.validate_String64(self.FacilityKind)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberFacilityGeneric)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberFacilityGeneric.subclass:
            return FiberFacilityGeneric.subclass(*args_, **kwargs_)
        else:
            return FiberFacilityGeneric(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FacilityName(self): return self.FacilityName
    def set_FacilityName(self, FacilityName): self.FacilityName = FacilityName
    FacilityNameProp = property(get_FacilityName, set_FacilityName)
    def get_FacilityKind(self): return self.FacilityKind
    def set_FacilityKind(self, FacilityKind): self.FacilityKind = FacilityKind
    FacilityKindProp = property(get_FacilityKind, set_FacilityKind)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.FacilityName is not None or
            self.FacilityKind is not None or
            super(FiberFacilityGeneric, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberFacilityGeneric', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberFacilityGeneric')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberFacilityGeneric', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberFacilityGeneric'):
        super(FiberFacilityGeneric, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FiberFacilityGeneric')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberFacilityGeneric', fromsubclass_=False, pretty_print=True):
        super(FiberFacilityGeneric, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FacilityName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFacilityName>%s</%sFacilityName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FacilityName), input_name='FacilityName')), namespace_, eol_))
        if self.FacilityKind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFacilityKind>%s</%sFacilityKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FacilityKind), input_name='FacilityKind')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FiberFacilityGeneric, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FacilityName':
            FacilityName_ = child_.text
            FacilityName_ = self.gds_validate_string(FacilityName_, node, 'FacilityName')
            self.FacilityName = FacilityName_
            # validate type String64
            self.validate_String64(self.FacilityName)
        elif nodeName_ == 'FacilityKind':
            FacilityKind_ = child_.text
            FacilityKind_ = self.gds_validate_string(FacilityKind_, node, 'FacilityKind')
            self.FacilityKind = FacilityKind_
            # validate type String64
            self.validate_String64(self.FacilityKind)
        super(FiberFacilityGeneric, self).buildChildren(child_, node, nodeName_, True)
# end class FiberFacilityGeneric


class FiberFacilityMapping(GeneratedsSuper):
    """Relates lengths of fiber to corresponding lengths of facilities
    (probably wellbores or pipelines). The facilityMapping also
    contains the datum from which the InterpretedData is
    indexed.Unique identifier of this object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, TimeStart=None, TimeEnd=None, Comment=None, FiberFacilityMappingPart=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        if isinstance(TimeStart, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(TimeStart, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = TimeStart
        self.TimeStart = initvalue_
        if isinstance(TimeEnd, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(TimeEnd, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = TimeEnd
        self.TimeEnd = initvalue_
        self.Comment = Comment
        self.validate_String2000(self.Comment)
        if FiberFacilityMappingPart is None:
            self.FiberFacilityMappingPart = []
        else:
            self.FiberFacilityMappingPart = FiberFacilityMappingPart
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberFacilityMapping)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberFacilityMapping.subclass:
            return FiberFacilityMapping.subclass(*args_, **kwargs_)
        else:
            return FiberFacilityMapping(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeStart(self): return self.TimeStart
    def set_TimeStart(self, TimeStart): self.TimeStart = TimeStart
    TimeStartProp = property(get_TimeStart, set_TimeStart)
    def get_TimeEnd(self): return self.TimeEnd
    def set_TimeEnd(self, TimeEnd): self.TimeEnd = TimeEnd
    TimeEndProp = property(get_TimeEnd, set_TimeEnd)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_FiberFacilityMappingPart(self): return self.FiberFacilityMappingPart
    def set_FiberFacilityMappingPart(self, FiberFacilityMappingPart): self.FiberFacilityMappingPart = FiberFacilityMappingPart
    def add_FiberFacilityMappingPart(self, value): self.FiberFacilityMappingPart.append(value)
    def insert_FiberFacilityMappingPart_at(self, index, value): self.FiberFacilityMappingPart.insert(index, value)
    def replace_FiberFacilityMappingPart_at(self, index, value): self.FiberFacilityMappingPart[index] = value
    FiberFacilityMappingPartProp = property(get_FiberFacilityMappingPart, set_FiberFacilityMappingPart)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.TimeStart is not None or
            self.TimeEnd is not None or
            self.Comment is not None or
            self.FiberFacilityMappingPart
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberFacilityMapping', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberFacilityMapping')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberFacilityMapping', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberFacilityMapping'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberFacilityMapping', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TimeStart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeStart>%s</%sTimeStart>%s' % (namespace_, self.gds_format_datetime(self.TimeStart, input_name='TimeStart'), namespace_, eol_))
        if self.TimeEnd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeEnd>%s</%sTimeEnd>%s' % (namespace_, self.gds_format_datetime(self.TimeEnd, input_name='TimeEnd'), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
        for FiberFacilityMappingPart_ in self.FiberFacilityMappingPart:
            FiberFacilityMappingPart_.export(outfile, level, namespace_, name_='FiberFacilityMappingPart', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeStart':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.TimeStart = dval_
        elif nodeName_ == 'TimeEnd':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.TimeEnd = dval_
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        elif nodeName_ == 'FiberFacilityMappingPart':
            obj_ = FiberFacilityMappingPart.factory()
            obj_.build(child_)
            self.FiberFacilityMappingPart.append(obj_)
            obj_.original_tagname_ = 'FiberFacilityMappingPart'
# end class FiberFacilityMapping


class FiberFacilityMappingPart(GeneratedsSuper):
    """Relates distances measured along the optical path to specific
    lengths along facilities (wellbores or pipelines).Unique
    identifier or this object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, OpticalPathDistanceStart=None, OpticalPathDistanceEnd=None, FacilityLengthStart=None, FacilityLengthEnd=None, Comment=None, FiberFacility=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.OpticalPathDistanceStart = OpticalPathDistanceStart
        self.OpticalPathDistanceEnd = OpticalPathDistanceEnd
        self.FacilityLengthStart = FacilityLengthStart
        self.FacilityLengthEnd = FacilityLengthEnd
        self.Comment = Comment
        self.validate_String2000(self.Comment)
        self.FiberFacility = FiberFacility
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberFacilityMappingPart)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberFacilityMappingPart.subclass:
            return FiberFacilityMappingPart.subclass(*args_, **kwargs_)
        else:
            return FiberFacilityMappingPart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpticalPathDistanceStart(self): return self.OpticalPathDistanceStart
    def set_OpticalPathDistanceStart(self, OpticalPathDistanceStart): self.OpticalPathDistanceStart = OpticalPathDistanceStart
    OpticalPathDistanceStartProp = property(get_OpticalPathDistanceStart, set_OpticalPathDistanceStart)
    def get_OpticalPathDistanceEnd(self): return self.OpticalPathDistanceEnd
    def set_OpticalPathDistanceEnd(self, OpticalPathDistanceEnd): self.OpticalPathDistanceEnd = OpticalPathDistanceEnd
    OpticalPathDistanceEndProp = property(get_OpticalPathDistanceEnd, set_OpticalPathDistanceEnd)
    def get_FacilityLengthStart(self): return self.FacilityLengthStart
    def set_FacilityLengthStart(self, FacilityLengthStart): self.FacilityLengthStart = FacilityLengthStart
    FacilityLengthStartProp = property(get_FacilityLengthStart, set_FacilityLengthStart)
    def get_FacilityLengthEnd(self): return self.FacilityLengthEnd
    def set_FacilityLengthEnd(self, FacilityLengthEnd): self.FacilityLengthEnd = FacilityLengthEnd
    FacilityLengthEndProp = property(get_FacilityLengthEnd, set_FacilityLengthEnd)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_FiberFacility(self): return self.FiberFacility
    def set_FiberFacility(self, FiberFacility): self.FiberFacility = FiberFacility
    FiberFacilityProp = property(get_FiberFacility, set_FiberFacility)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.OpticalPathDistanceStart is not None or
            self.OpticalPathDistanceEnd is not None or
            self.FacilityLengthStart is not None or
            self.FacilityLengthEnd is not None or
            self.Comment is not None or
            self.FiberFacility is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberFacilityMappingPart', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberFacilityMappingPart')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberFacilityMappingPart', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberFacilityMappingPart'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberFacilityMappingPart', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OpticalPathDistanceStart is not None:
            self.OpticalPathDistanceStart.export(outfile, level, namespace_, name_='OpticalPathDistanceStart', pretty_print=pretty_print)
        if self.OpticalPathDistanceEnd is not None:
            self.OpticalPathDistanceEnd.export(outfile, level, namespace_, name_='OpticalPathDistanceEnd', pretty_print=pretty_print)
        if self.FacilityLengthStart is not None:
            self.FacilityLengthStart.export(outfile, level, namespace_, name_='FacilityLengthStart', pretty_print=pretty_print)
        if self.FacilityLengthEnd is not None:
            self.FacilityLengthEnd.export(outfile, level, namespace_, name_='FacilityLengthEnd', pretty_print=pretty_print)
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
        if self.FiberFacility is not None:
            self.FiberFacility.export(outfile, level, namespace_, name_='FiberFacility', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpticalPathDistanceStart':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.OpticalPathDistanceStart = obj_
            obj_.original_tagname_ = 'OpticalPathDistanceStart'
        elif nodeName_ == 'OpticalPathDistanceEnd':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.OpticalPathDistanceEnd = obj_
            obj_.original_tagname_ = 'OpticalPathDistanceEnd'
        elif nodeName_ == 'FacilityLengthStart':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.FacilityLengthStart = obj_
            obj_.original_tagname_ = 'FacilityLengthStart'
        elif nodeName_ == 'FacilityLengthEnd':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.FacilityLengthEnd = obj_
            obj_.original_tagname_ = 'FacilityLengthEnd'
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        elif nodeName_ == 'FiberFacility':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <FiberFacility> element')
            self.FiberFacility = obj_
            obj_.original_tagname_ = 'FiberFacility'
# end class FiberFacilityMappingPart


class FiberFacilityPipeline(AbstractFiberFacility):
    """If facility mapping is to a pipeline, this element shows what
    optical path distances map to pipeline lengths."""
    subclass = None
    superclass = AbstractFiberFacility
    def __init__(self, Name=None, DatumPortReference=None, Installation=None, Kind=None, ContextFacility=None):
        self.original_tagname_ = None
        super(FiberFacilityPipeline, self).__init__()
        self.Name = Name
        self.DatumPortReference = DatumPortReference
        self.validate_String64(self.DatumPortReference)
        self.Installation = Installation
        self.Kind = Kind
        self.validate_String64(self.Kind)
        self.ContextFacility = ContextFacility
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberFacilityPipeline)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberFacilityPipeline.subclass:
            return FiberFacilityPipeline.subclass(*args_, **kwargs_)
        else:
            return FiberFacilityPipeline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_DatumPortReference(self): return self.DatumPortReference
    def set_DatumPortReference(self, DatumPortReference): self.DatumPortReference = DatumPortReference
    DatumPortReferenceProp = property(get_DatumPortReference, set_DatumPortReference)
    def get_Installation(self): return self.Installation
    def set_Installation(self, Installation): self.Installation = Installation
    InstallationProp = property(get_Installation, set_Installation)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    KindProp = property(get_Kind, set_Kind)
    def get_ContextFacility(self): return self.ContextFacility
    def set_ContextFacility(self, ContextFacility): self.ContextFacility = ContextFacility
    ContextFacilityProp = property(get_ContextFacility, set_ContextFacility)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.DatumPortReference is not None or
            self.Installation is not None or
            self.Kind is not None or
            self.ContextFacility is not None or
            super(FiberFacilityPipeline, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberFacilityPipeline', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberFacilityPipeline')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberFacilityPipeline', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberFacilityPipeline'):
        super(FiberFacilityPipeline, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FiberFacilityPipeline')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberFacilityPipeline', fromsubclass_=False, pretty_print=True):
        super(FiberFacilityPipeline, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            self.Name.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        if self.DatumPortReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDatumPortReference>%s</%sDatumPortReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DatumPortReference), input_name='DatumPortReference')), namespace_, eol_))
        if self.Installation is not None:
            self.Installation.export(outfile, level, namespace_, name_='Installation', pretty_print=pretty_print)
        if self.Kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKind>%s</%sKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Kind), input_name='Kind')), namespace_, eol_))
        if self.ContextFacility is not None:
            self.ContextFacility.export(outfile, level, namespace_, name_='ContextFacility', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FiberFacilityPipeline, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = NameStruct.factory()
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'DatumPortReference':
            DatumPortReference_ = child_.text
            DatumPortReference_ = self.gds_validate_string(DatumPortReference_, node, 'DatumPortReference')
            self.DatumPortReference = DatumPortReference_
            # validate type String64
            self.validate_String64(self.DatumPortReference)
        elif nodeName_ == 'Installation':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.Installation = obj_
            obj_.original_tagname_ = 'Installation'
        elif nodeName_ == 'Kind':
            Kind_ = child_.text
            Kind_ = self.gds_validate_string(Kind_, node, 'Kind')
            self.Kind = Kind_
            # validate type String64
            self.validate_String64(self.Kind)
        elif nodeName_ == 'ContextFacility':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.ContextFacility = obj_
            obj_.original_tagname_ = 'ContextFacility'
        super(FiberFacilityPipeline, self).buildChildren(child_, node, nodeName_, True)
# end class FiberFacilityPipeline


class FiberFacilityWell(AbstractFiberFacility):
    """If facility mapping is to a wellbore, this element shows what
    optical path distances map to wellbore measured depths."""
    subclass = None
    superclass = AbstractFiberFacility
    def __init__(self, Name=None, WellDatum=None, WellboreReference=None):
        self.original_tagname_ = None
        super(FiberFacilityWell, self).__init__()
        self.Name = Name
        self.validate_String64(self.Name)
        self.WellDatum = WellDatum
        self.validate_WellboreDatumReference(self.WellDatum)
        self.WellboreReference = WellboreReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberFacilityWell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberFacilityWell.subclass:
            return FiberFacilityWell.subclass(*args_, **kwargs_)
        else:
            return FiberFacilityWell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_WellDatum(self): return self.WellDatum
    def set_WellDatum(self, WellDatum): self.WellDatum = WellDatum
    WellDatumProp = property(get_WellDatum, set_WellDatum)
    def get_WellboreReference(self): return self.WellboreReference
    def set_WellboreReference(self, WellboreReference): self.WellboreReference = WellboreReference
    WellboreReferenceProp = property(get_WellboreReference, set_WellboreReference)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_WellboreDatumReference(self, value):
        # Validate type WellboreDatumReference, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ground level', 'kelly bushing', 'mean sea level', 'derrick floor', 'casing flange', 'crown valve', 'rotary bushing', 'rotary table', 'sea floor', 'lowest astronomical tide', 'mean higher high water', 'mean high water', 'mean lower low water', 'mean low water', 'mean tide level', 'kickoff point']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WellboreDatumReference' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.WellDatum is not None or
            self.WellboreReference is not None or
            super(FiberFacilityWell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberFacilityWell', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberFacilityWell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberFacilityWell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberFacilityWell'):
        super(FiberFacilityWell, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FiberFacilityWell')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberFacilityWell', fromsubclass_=False, pretty_print=True):
        super(FiberFacilityWell, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.WellDatum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWellDatum>%s</%sWellDatum>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WellDatum), input_name='WellDatum')), namespace_, eol_))
        if self.WellboreReference is not None:
            self.WellboreReference.export(outfile, level, namespace_, name_='WellboreReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FiberFacilityWell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'WellDatum':
            WellDatum_ = child_.text
            WellDatum_ = self.gds_validate_string(WellDatum_, node, 'WellDatum')
            self.WellDatum = WellDatum_
            # validate type WellboreDatumReference
            self.validate_WellboreDatumReference(self.WellDatum)
        elif nodeName_ == 'WellboreReference':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.WellboreReference = obj_
            obj_.original_tagname_ = 'WellboreReference'
        super(FiberFacilityWell, self).buildChildren(child_, node, nodeName_, True)
# end class FiberFacilityWell


class FiberOneWayAttenuation(GeneratedsSuper):
    """The power loss for one-way travel of a beam of light, usually
    measured in decibels per unit length. It is necessary to include
    both the value (and its unit) and the wavelength at which this
    attenuation was measured.Unique identifier of this object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Value=None, AttenuationMeasure=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Value = Value
        self.AttenuationMeasure = AttenuationMeasure
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberOneWayAttenuation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberOneWayAttenuation.subclass:
            return FiberOneWayAttenuation.subclass(*args_, **kwargs_)
        else:
            return FiberOneWayAttenuation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    ValueProp = property(get_Value, set_Value)
    def get_AttenuationMeasure(self): return self.AttenuationMeasure
    def set_AttenuationMeasure(self, AttenuationMeasure): self.AttenuationMeasure = AttenuationMeasure
    AttenuationMeasureProp = property(get_AttenuationMeasure, set_AttenuationMeasure)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def hasContent_(self):
        if (
            self.Value is not None or
            self.AttenuationMeasure is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberOneWayAttenuation', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberOneWayAttenuation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberOneWayAttenuation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberOneWayAttenuation'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberOneWayAttenuation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            self.Value.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
        if self.AttenuationMeasure is not None:
            self.AttenuationMeasure.export(outfile, level, namespace_, name_='AttenuationMeasure', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            obj_ = LogarithmicPowerRatioPerLengthMeasure.factory()
            obj_.build(child_)
            self.Value = obj_
            obj_.original_tagname_ = 'Value'
        elif nodeName_ == 'AttenuationMeasure':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AttenuationMeasure> element')
            self.AttenuationMeasure = obj_
            obj_.original_tagname_ = 'AttenuationMeasure'
# end class FiberOneWayAttenuation


class FiberOpticalPathInventory(GeneratedsSuper):
    """The list of equipment used in the optical path. Equipment may be
    used in the optical path for different periods of time, so this
    inventory contains all items of equipment that are used at some
    period of time."""
    subclass = None
    superclass = None
    def __init__(self, Connection=None, Turnaround=None, Segment=None, Terminator=None, Splice=None):
        self.original_tagname_ = None
        if Connection is None:
            self.Connection = []
        else:
            self.Connection = Connection
        if Turnaround is None:
            self.Turnaround = []
        else:
            self.Turnaround = Turnaround
        if Segment is None:
            self.Segment = []
        else:
            self.Segment = Segment
        self.Terminator = Terminator
        if Splice is None:
            self.Splice = []
        else:
            self.Splice = Splice
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberOpticalPathInventory)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberOpticalPathInventory.subclass:
            return FiberOpticalPathInventory.subclass(*args_, **kwargs_)
        else:
            return FiberOpticalPathInventory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Connection(self): return self.Connection
    def set_Connection(self, Connection): self.Connection = Connection
    def add_Connection(self, value): self.Connection.append(value)
    def insert_Connection_at(self, index, value): self.Connection.insert(index, value)
    def replace_Connection_at(self, index, value): self.Connection[index] = value
    ConnectionProp = property(get_Connection, set_Connection)
    def get_Turnaround(self): return self.Turnaround
    def set_Turnaround(self, Turnaround): self.Turnaround = Turnaround
    def add_Turnaround(self, value): self.Turnaround.append(value)
    def insert_Turnaround_at(self, index, value): self.Turnaround.insert(index, value)
    def replace_Turnaround_at(self, index, value): self.Turnaround[index] = value
    TurnaroundProp = property(get_Turnaround, set_Turnaround)
    def get_Segment(self): return self.Segment
    def set_Segment(self, Segment): self.Segment = Segment
    def add_Segment(self, value): self.Segment.append(value)
    def insert_Segment_at(self, index, value): self.Segment.insert(index, value)
    def replace_Segment_at(self, index, value): self.Segment[index] = value
    SegmentProp = property(get_Segment, set_Segment)
    def get_Terminator(self): return self.Terminator
    def set_Terminator(self, Terminator): self.Terminator = Terminator
    TerminatorProp = property(get_Terminator, set_Terminator)
    def get_Splice(self): return self.Splice
    def set_Splice(self, Splice): self.Splice = Splice
    def add_Splice(self, value): self.Splice.append(value)
    def insert_Splice_at(self, index, value): self.Splice.insert(index, value)
    def replace_Splice_at(self, index, value): self.Splice[index] = value
    SpliceProp = property(get_Splice, set_Splice)
    def hasContent_(self):
        if (
            self.Connection or
            self.Turnaround or
            self.Segment or
            self.Terminator is not None or
            self.Splice
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberOpticalPathInventory', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberOpticalPathInventory')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberOpticalPathInventory', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberOpticalPathInventory'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberOpticalPathInventory', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Connection_ in self.Connection:
            Connection_.export(outfile, level, namespace_, name_='Connection', pretty_print=pretty_print)
        for Turnaround_ in self.Turnaround:
            Turnaround_.export(outfile, level, namespace_, name_='Turnaround', pretty_print=pretty_print)
        for Segment_ in self.Segment:
            Segment_.export(outfile, level, namespace_, name_='Segment', pretty_print=pretty_print)
        if self.Terminator is not None:
            self.Terminator.export(outfile, level, namespace_, name_='Terminator', pretty_print=pretty_print)
        for Splice_ in self.Splice:
            Splice_.export(outfile, level, namespace_, name_='Splice', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Connection':
            obj_ = FiberConnection.factory()
            obj_.build(child_)
            self.Connection.append(obj_)
            obj_.original_tagname_ = 'Connection'
        elif nodeName_ == 'Turnaround':
            obj_ = FiberTurnaround.factory()
            obj_.build(child_)
            self.Turnaround.append(obj_)
            obj_.original_tagname_ = 'Turnaround'
        elif nodeName_ == 'Segment':
            obj_ = FiberOpticalPathSegment.factory()
            obj_.build(child_)
            self.Segment.append(obj_)
            obj_.original_tagname_ = 'Segment'
        elif nodeName_ == 'Terminator':
            obj_ = FiberTerminator.factory()
            obj_.build(child_)
            self.Terminator = obj_
            obj_.original_tagname_ = 'Terminator'
        elif nodeName_ == 'Splice':
            obj_ = FiberSplice.factory()
            obj_.build(child_)
            self.Splice.append(obj_)
            obj_.original_tagname_ = 'Splice'
# end class FiberOpticalPathInventory


class FiberOpticalPathNetwork(GeneratedsSuper):
    """The sequence of connected items of equipment along the optical path.
    Represented by a flow network.Unique identifier of this object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Installation=None, ContextFacility=None, DTimStart=None, DTimeEnd=None, ExistenceTime=None, DTimMin=None, DTimMax=None, Comment=None, ExternalConnect=None, Network=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Installation = Installation
        if ContextFacility is None:
            self.ContextFacility = []
        else:
            self.ContextFacility = ContextFacility
        if isinstance(DTimStart, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DTimStart, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DTimStart
        self.DTimStart = initvalue_
        if isinstance(DTimeEnd, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DTimeEnd, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DTimeEnd
        self.DTimeEnd = initvalue_
        self.ExistenceTime = ExistenceTime
        self.DTimMin = DTimMin
        self.DTimMax = DTimMax
        self.Comment = Comment
        self.validate_String2000(self.Comment)
        if ExternalConnect is None:
            self.ExternalConnect = []
        else:
            self.ExternalConnect = ExternalConnect
        if Network is None:
            self.Network = []
        else:
            self.Network = Network
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberOpticalPathNetwork)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberOpticalPathNetwork.subclass:
            return FiberOpticalPathNetwork.subclass(*args_, **kwargs_)
        else:
            return FiberOpticalPathNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Installation(self): return self.Installation
    def set_Installation(self, Installation): self.Installation = Installation
    InstallationProp = property(get_Installation, set_Installation)
    def get_ContextFacility(self): return self.ContextFacility
    def set_ContextFacility(self, ContextFacility): self.ContextFacility = ContextFacility
    def add_ContextFacility(self, value): self.ContextFacility.append(value)
    def insert_ContextFacility_at(self, index, value): self.ContextFacility.insert(index, value)
    def replace_ContextFacility_at(self, index, value): self.ContextFacility[index] = value
    ContextFacilityProp = property(get_ContextFacility, set_ContextFacility)
    def get_DTimStart(self): return self.DTimStart
    def set_DTimStart(self, DTimStart): self.DTimStart = DTimStart
    DTimStartProp = property(get_DTimStart, set_DTimStart)
    def get_DTimeEnd(self): return self.DTimeEnd
    def set_DTimeEnd(self, DTimeEnd): self.DTimeEnd = DTimeEnd
    DTimeEndProp = property(get_DTimeEnd, set_DTimeEnd)
    def get_ExistenceTime(self): return self.ExistenceTime
    def set_ExistenceTime(self, ExistenceTime): self.ExistenceTime = ExistenceTime
    ExistenceTimeProp = property(get_ExistenceTime, set_ExistenceTime)
    def get_DTimMin(self): return self.DTimMin
    def set_DTimMin(self, DTimMin): self.DTimMin = DTimMin
    DTimMinProp = property(get_DTimMin, set_DTimMin)
    def get_DTimMax(self): return self.DTimMax
    def set_DTimMax(self, DTimMax): self.DTimMax = DTimMax
    DTimMaxProp = property(get_DTimMax, set_DTimMax)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_ExternalConnect(self): return self.ExternalConnect
    def set_ExternalConnect(self, ExternalConnect): self.ExternalConnect = ExternalConnect
    def add_ExternalConnect(self, value): self.ExternalConnect.append(value)
    def insert_ExternalConnect_at(self, index, value): self.ExternalConnect.insert(index, value)
    def replace_ExternalConnect_at(self, index, value): self.ExternalConnect[index] = value
    ExternalConnectProp = property(get_ExternalConnect, set_ExternalConnect)
    def get_Network(self): return self.Network
    def set_Network(self, Network): self.Network = Network
    def add_Network(self, value): self.Network.append(value)
    def insert_Network_at(self, index, value): self.Network.insert(index, value)
    def replace_Network_at(self, index, value): self.Network[index] = value
    NetworkProp = property(get_Network, set_Network)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Installation is not None or
            self.ContextFacility or
            self.DTimStart is not None or
            self.DTimeEnd is not None or
            self.ExistenceTime is not None or
            self.DTimMin is not None or
            self.DTimMax is not None or
            self.Comment is not None or
            self.ExternalConnect or
            self.Network
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberOpticalPathNetwork', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberOpticalPathNetwork')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberOpticalPathNetwork', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberOpticalPathNetwork'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberOpticalPathNetwork', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Installation is not None:
            self.Installation.export(outfile, level, namespace_, name_='Installation', pretty_print=pretty_print)
        for ContextFacility_ in self.ContextFacility:
            ContextFacility_.export(outfile, level, namespace_, name_='ContextFacility', pretty_print=pretty_print)
        if self.DTimStart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTimStart>%s</%sDTimStart>%s' % (namespace_, self.gds_format_datetime(self.DTimStart, input_name='DTimStart'), namespace_, eol_))
        if self.DTimeEnd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTimeEnd>%s</%sDTimeEnd>%s' % (namespace_, self.gds_format_datetime(self.DTimeEnd, input_name='DTimeEnd'), namespace_, eol_))
        if self.ExistenceTime is not None:
            self.ExistenceTime.export(outfile, level, namespace_, name_='ExistenceTime', pretty_print=pretty_print)
        if self.DTimMin is not None:
            self.DTimMin.export(outfile, level, namespace_, name_='DTimMin', pretty_print=pretty_print)
        if self.DTimMax is not None:
            self.DTimMax.export(outfile, level, namespace_, name_='DTimMax', pretty_print=pretty_print)
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
        for ExternalConnect_ in self.ExternalConnect:
            ExternalConnect_.export(outfile, level, namespace_, name_='ExternalConnect', pretty_print=pretty_print)
        for Network_ in self.Network:
            Network_.export(outfile, level, namespace_, name_='Network', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Installation':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.Installation = obj_
            obj_.original_tagname_ = 'Installation'
        elif nodeName_ == 'ContextFacility':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.ContextFacility.append(obj_)
            obj_.original_tagname_ = 'ContextFacility'
        elif nodeName_ == 'DTimStart':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DTimStart = dval_
        elif nodeName_ == 'DTimeEnd':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DTimeEnd = dval_
        elif nodeName_ == 'ExistenceTime':
            obj_ = EndpointQualifiedDateTime.factory()
            obj_.build(child_)
            self.ExistenceTime = obj_
            obj_.original_tagname_ = 'ExistenceTime'
        elif nodeName_ == 'DTimMin':
            obj_ = EndpointQualifiedDateTime.factory()
            obj_.build(child_)
            self.DTimMin = obj_
            obj_.original_tagname_ = 'DTimMin'
        elif nodeName_ == 'DTimMax':
            obj_ = EndpointQualifiedDateTime.factory()
            obj_.build(child_)
            self.DTimMax = obj_
            obj_.original_tagname_ = 'DTimMax'
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        elif nodeName_ == 'ExternalConnect':
            obj_ = ProductFlowExternalReference.factory()
            obj_.build(child_)
            self.ExternalConnect.append(obj_)
            obj_.original_tagname_ = 'ExternalConnect'
        elif nodeName_ == 'Network':
            obj_ = ProductFlowNetwork.factory()
            obj_.build(child_)
            self.Network.append(obj_)
            obj_.original_tagname_ = 'Network'
# end class FiberOpticalPathNetwork


class FiberOpticalPathSegment(FiberCommon):
    """A single segment of the optical fiber used for distributed
    temperature surveys. Multiple such segments may be connected by
    other types of components including connectors, splices and
    fiber turnarounds."""
    subclass = None
    superclass = FiberCommon
    def __init__(self, Name=None, Manufacturer=None, ManufacturingDate=None, Type=None, SupplyDate=None, SupplierModelNumber=None, SoftwareVersion=None, Comment=None, Supplier=None, uid=None, Reflectance=None, Loss=None, ReasonForDecommissioning=None, FiberLength=None, OverStuffing=None, CoreDiameter=None, CladdedDiameter=None, OutsideDiameter=None, Mode=None, Coating=None, Jacket=None, CoreType=None, Parameter=None, SpoolNumberTag=None, SpoolLength=None, CableType=None, RefractiveIndex=None, FiberConveyance=None, OneWayAttenuation=None):
        self.original_tagname_ = None
        super(FiberOpticalPathSegment, self).__init__(Name, Manufacturer, ManufacturingDate, Type, SupplyDate, SupplierModelNumber, SoftwareVersion, Comment, Supplier, uid, Reflectance, Loss, ReasonForDecommissioning, )
        self.FiberLength = FiberLength
        self.OverStuffing = OverStuffing
        self.CoreDiameter = CoreDiameter
        self.CladdedDiameter = CladdedDiameter
        self.OutsideDiameter = OutsideDiameter
        self.Mode = Mode
        self.validate_FiberMode(self.Mode)
        self.Coating = Coating
        self.validate_String64(self.Coating)
        self.Jacket = Jacket
        self.validate_String64(self.Jacket)
        self.CoreType = CoreType
        self.validate_String64(self.CoreType)
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
        self.SpoolNumberTag = SpoolNumberTag
        self.validate_String64(self.SpoolNumberTag)
        self.SpoolLength = SpoolLength
        self.CableType = CableType
        self.validate_CableType(self.CableType)
        if RefractiveIndex is None:
            self.RefractiveIndex = []
        else:
            self.RefractiveIndex = RefractiveIndex
        self.FiberConveyance = FiberConveyance
        if OneWayAttenuation is None:
            self.OneWayAttenuation = []
        else:
            self.OneWayAttenuation = OneWayAttenuation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberOpticalPathSegment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberOpticalPathSegment.subclass:
            return FiberOpticalPathSegment.subclass(*args_, **kwargs_)
        else:
            return FiberOpticalPathSegment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FiberLength(self): return self.FiberLength
    def set_FiberLength(self, FiberLength): self.FiberLength = FiberLength
    FiberLengthProp = property(get_FiberLength, set_FiberLength)
    def get_OverStuffing(self): return self.OverStuffing
    def set_OverStuffing(self, OverStuffing): self.OverStuffing = OverStuffing
    OverStuffingProp = property(get_OverStuffing, set_OverStuffing)
    def get_CoreDiameter(self): return self.CoreDiameter
    def set_CoreDiameter(self, CoreDiameter): self.CoreDiameter = CoreDiameter
    CoreDiameterProp = property(get_CoreDiameter, set_CoreDiameter)
    def get_CladdedDiameter(self): return self.CladdedDiameter
    def set_CladdedDiameter(self, CladdedDiameter): self.CladdedDiameter = CladdedDiameter
    CladdedDiameterProp = property(get_CladdedDiameter, set_CladdedDiameter)
    def get_OutsideDiameter(self): return self.OutsideDiameter
    def set_OutsideDiameter(self, OutsideDiameter): self.OutsideDiameter = OutsideDiameter
    OutsideDiameterProp = property(get_OutsideDiameter, set_OutsideDiameter)
    def get_Mode(self): return self.Mode
    def set_Mode(self, Mode): self.Mode = Mode
    ModeProp = property(get_Mode, set_Mode)
    def get_Coating(self): return self.Coating
    def set_Coating(self, Coating): self.Coating = Coating
    CoatingProp = property(get_Coating, set_Coating)
    def get_Jacket(self): return self.Jacket
    def set_Jacket(self, Jacket): self.Jacket = Jacket
    JacketProp = property(get_Jacket, set_Jacket)
    def get_CoreType(self): return self.CoreType
    def set_CoreType(self, CoreType): self.CoreType = CoreType
    CoreTypeProp = property(get_CoreType, set_CoreType)
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    def add_Parameter(self, value): self.Parameter.append(value)
    def insert_Parameter_at(self, index, value): self.Parameter.insert(index, value)
    def replace_Parameter_at(self, index, value): self.Parameter[index] = value
    ParameterProp = property(get_Parameter, set_Parameter)
    def get_SpoolNumberTag(self): return self.SpoolNumberTag
    def set_SpoolNumberTag(self, SpoolNumberTag): self.SpoolNumberTag = SpoolNumberTag
    SpoolNumberTagProp = property(get_SpoolNumberTag, set_SpoolNumberTag)
    def get_SpoolLength(self): return self.SpoolLength
    def set_SpoolLength(self, SpoolLength): self.SpoolLength = SpoolLength
    SpoolLengthProp = property(get_SpoolLength, set_SpoolLength)
    def get_CableType(self): return self.CableType
    def set_CableType(self, CableType): self.CableType = CableType
    CableTypeProp = property(get_CableType, set_CableType)
    def get_RefractiveIndex(self): return self.RefractiveIndex
    def set_RefractiveIndex(self, RefractiveIndex): self.RefractiveIndex = RefractiveIndex
    def add_RefractiveIndex(self, value): self.RefractiveIndex.append(value)
    def insert_RefractiveIndex_at(self, index, value): self.RefractiveIndex.insert(index, value)
    def replace_RefractiveIndex_at(self, index, value): self.RefractiveIndex[index] = value
    RefractiveIndexProp = property(get_RefractiveIndex, set_RefractiveIndex)
    def get_FiberConveyance(self): return self.FiberConveyance
    def set_FiberConveyance(self, FiberConveyance): self.FiberConveyance = FiberConveyance
    FiberConveyanceProp = property(get_FiberConveyance, set_FiberConveyance)
    def get_OneWayAttenuation(self): return self.OneWayAttenuation
    def set_OneWayAttenuation(self, OneWayAttenuation): self.OneWayAttenuation = OneWayAttenuation
    def add_OneWayAttenuation(self, value): self.OneWayAttenuation.append(value)
    def insert_OneWayAttenuation_at(self, index, value): self.OneWayAttenuation.insert(index, value)
    def replace_OneWayAttenuation_at(self, index, value): self.OneWayAttenuation[index] = value
    OneWayAttenuationProp = property(get_OneWayAttenuation, set_OneWayAttenuation)
    def validate_FiberMode(self, value):
        # Validate type FiberMode, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['multimode', 'other', 'singlemode']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FiberMode' % {"value" : value.encode("utf-8")} )
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_CableType(self, value):
        # Validate type CableType, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['electrical-fiber-cable', 'multi-fiber-cable', 'single-fiber-cable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CableType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FiberLength is not None or
            self.OverStuffing is not None or
            self.CoreDiameter is not None or
            self.CladdedDiameter is not None or
            self.OutsideDiameter is not None or
            self.Mode is not None or
            self.Coating is not None or
            self.Jacket is not None or
            self.CoreType is not None or
            self.Parameter or
            self.SpoolNumberTag is not None or
            self.SpoolLength is not None or
            self.CableType is not None or
            self.RefractiveIndex or
            self.FiberConveyance is not None or
            self.OneWayAttenuation or
            super(FiberOpticalPathSegment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberOpticalPathSegment', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberOpticalPathSegment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberOpticalPathSegment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberOpticalPathSegment'):
        super(FiberOpticalPathSegment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FiberOpticalPathSegment')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberOpticalPathSegment', fromsubclass_=False, pretty_print=True):
        super(FiberOpticalPathSegment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FiberLength is not None:
            self.FiberLength.export(outfile, level, namespace_, name_='FiberLength', pretty_print=pretty_print)
        if self.OverStuffing is not None:
            self.OverStuffing.export(outfile, level, namespace_, name_='OverStuffing', pretty_print=pretty_print)
        if self.CoreDiameter is not None:
            self.CoreDiameter.export(outfile, level, namespace_, name_='CoreDiameter', pretty_print=pretty_print)
        if self.CladdedDiameter is not None:
            self.CladdedDiameter.export(outfile, level, namespace_, name_='CladdedDiameter', pretty_print=pretty_print)
        if self.OutsideDiameter is not None:
            self.OutsideDiameter.export(outfile, level, namespace_, name_='OutsideDiameter', pretty_print=pretty_print)
        if self.Mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMode>%s</%sMode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Mode), input_name='Mode')), namespace_, eol_))
        if self.Coating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCoating>%s</%sCoating>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Coating), input_name='Coating')), namespace_, eol_))
        if self.Jacket is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sJacket>%s</%sJacket>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Jacket), input_name='Jacket')), namespace_, eol_))
        if self.CoreType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCoreType>%s</%sCoreType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CoreType), input_name='CoreType')), namespace_, eol_))
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, namespace_, name_='Parameter', pretty_print=pretty_print)
        if self.SpoolNumberTag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpoolNumberTag>%s</%sSpoolNumberTag>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SpoolNumberTag), input_name='SpoolNumberTag')), namespace_, eol_))
        if self.SpoolLength is not None:
            self.SpoolLength.export(outfile, level, namespace_, name_='SpoolLength', pretty_print=pretty_print)
        if self.CableType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCableType>%s</%sCableType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CableType), input_name='CableType')), namespace_, eol_))
        for RefractiveIndex_ in self.RefractiveIndex:
            RefractiveIndex_.export(outfile, level, namespace_, name_='RefractiveIndex', pretty_print=pretty_print)
        if self.FiberConveyance is not None:
            self.FiberConveyance.export(outfile, level, namespace_, name_='FiberConveyance', pretty_print=pretty_print)
        for OneWayAttenuation_ in self.OneWayAttenuation:
            OneWayAttenuation_.export(outfile, level, namespace_, name_='OneWayAttenuation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FiberOpticalPathSegment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FiberLength':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.FiberLength = obj_
            obj_.original_tagname_ = 'FiberLength'
        elif nodeName_ == 'OverStuffing':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.OverStuffing = obj_
            obj_.original_tagname_ = 'OverStuffing'
        elif nodeName_ == 'CoreDiameter':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.CoreDiameter = obj_
            obj_.original_tagname_ = 'CoreDiameter'
        elif nodeName_ == 'CladdedDiameter':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.CladdedDiameter = obj_
            obj_.original_tagname_ = 'CladdedDiameter'
        elif nodeName_ == 'OutsideDiameter':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.OutsideDiameter = obj_
            obj_.original_tagname_ = 'OutsideDiameter'
        elif nodeName_ == 'Mode':
            Mode_ = child_.text
            Mode_ = self.gds_validate_string(Mode_, node, 'Mode')
            self.Mode = Mode_
            # validate type FiberMode
            self.validate_FiberMode(self.Mode)
        elif nodeName_ == 'Coating':
            Coating_ = child_.text
            Coating_ = self.gds_validate_string(Coating_, node, 'Coating')
            self.Coating = Coating_
            # validate type String64
            self.validate_String64(self.Coating)
        elif nodeName_ == 'Jacket':
            Jacket_ = child_.text
            Jacket_ = self.gds_validate_string(Jacket_, node, 'Jacket')
            self.Jacket = Jacket_
            # validate type String64
            self.validate_String64(self.Jacket)
        elif nodeName_ == 'CoreType':
            CoreType_ = child_.text
            CoreType_ = self.gds_validate_string(CoreType_, node, 'CoreType')
            self.CoreType = CoreType_
            # validate type String64
            self.validate_String64(self.CoreType)
        elif nodeName_ == 'Parameter':
            obj_ = IndexedObject.factory()
            obj_.build(child_)
            self.Parameter.append(obj_)
            obj_.original_tagname_ = 'Parameter'
        elif nodeName_ == 'SpoolNumberTag':
            SpoolNumberTag_ = child_.text
            SpoolNumberTag_ = self.gds_validate_string(SpoolNumberTag_, node, 'SpoolNumberTag')
            self.SpoolNumberTag = SpoolNumberTag_
            # validate type String64
            self.validate_String64(self.SpoolNumberTag)
        elif nodeName_ == 'SpoolLength':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.SpoolLength = obj_
            obj_.original_tagname_ = 'SpoolLength'
        elif nodeName_ == 'CableType':
            CableType_ = child_.text
            CableType_ = self.gds_validate_string(CableType_, node, 'CableType')
            self.CableType = CableType_
            # validate type CableType
            self.validate_CableType(self.CableType)
        elif nodeName_ == 'RefractiveIndex':
            obj_ = FiberRefractiveIndex.factory()
            obj_.build(child_)
            self.RefractiveIndex.append(obj_)
            obj_.original_tagname_ = 'RefractiveIndex'
        elif nodeName_ == 'FiberConveyance':
            obj_ = FiberConveyance.factory()
            obj_.build(child_)
            self.FiberConveyance = obj_
            obj_.original_tagname_ = 'FiberConveyance'
        elif nodeName_ == 'OneWayAttenuation':
            obj_ = FiberOneWayAttenuation.factory()
            obj_.build(child_)
            self.OneWayAttenuation.append(obj_)
            obj_.original_tagname_ = 'OneWayAttenuation'
        super(FiberOpticalPathSegment, self).buildChildren(child_, node, nodeName_, True)
# end class FiberOpticalPathSegment


class FiberOTDR(GeneratedsSuper):
    """Records the result arrays along with context information for an
    optical time domain reflectometry (OTDR) survey. The arrays
    define the relative scattered power from the Rayleigh scattering
    vs. distance along the fiber. The actual data values are
    recorded in an OTDR file and/or image file, which are referenced
    in sub-elements.Unique identifier of this object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Name=None, ReasonForRun=None, DTimRun=None, DataInOTDRFile=None, OTDRImageFile=None, OpticalPathDistanceStart=None, OpticalPathDistanceEnd=None, Direction=None, Wavelength=None, FiberOTDRInstrumentBox=None, MeasurementContact=None, ExtensionNameValue=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Name = Name
        self.validate_String64(self.Name)
        self.ReasonForRun = ReasonForRun
        self.validate_OTDRReason(self.ReasonForRun)
        if isinstance(DTimRun, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DTimRun, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DTimRun
        self.DTimRun = initvalue_
        self.DataInOTDRFile = DataInOTDRFile
        self.validate_String64(self.DataInOTDRFile)
        self.OTDRImageFile = OTDRImageFile
        self.validate_String64(self.OTDRImageFile)
        self.OpticalPathDistanceStart = OpticalPathDistanceStart
        self.OpticalPathDistanceEnd = OpticalPathDistanceEnd
        self.Direction = Direction
        self.validate_OTDRDirection(self.Direction)
        self.Wavelength = Wavelength
        self.FiberOTDRInstrumentBox = FiberOTDRInstrumentBox
        self.MeasurementContact = MeasurementContact
        if ExtensionNameValue is None:
            self.ExtensionNameValue = []
        else:
            self.ExtensionNameValue = ExtensionNameValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberOTDR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberOTDR.subclass:
            return FiberOTDR.subclass(*args_, **kwargs_)
        else:
            return FiberOTDR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_ReasonForRun(self): return self.ReasonForRun
    def set_ReasonForRun(self, ReasonForRun): self.ReasonForRun = ReasonForRun
    ReasonForRunProp = property(get_ReasonForRun, set_ReasonForRun)
    def get_DTimRun(self): return self.DTimRun
    def set_DTimRun(self, DTimRun): self.DTimRun = DTimRun
    DTimRunProp = property(get_DTimRun, set_DTimRun)
    def get_DataInOTDRFile(self): return self.DataInOTDRFile
    def set_DataInOTDRFile(self, DataInOTDRFile): self.DataInOTDRFile = DataInOTDRFile
    DataInOTDRFileProp = property(get_DataInOTDRFile, set_DataInOTDRFile)
    def get_OTDRImageFile(self): return self.OTDRImageFile
    def set_OTDRImageFile(self, OTDRImageFile): self.OTDRImageFile = OTDRImageFile
    OTDRImageFileProp = property(get_OTDRImageFile, set_OTDRImageFile)
    def get_OpticalPathDistanceStart(self): return self.OpticalPathDistanceStart
    def set_OpticalPathDistanceStart(self, OpticalPathDistanceStart): self.OpticalPathDistanceStart = OpticalPathDistanceStart
    OpticalPathDistanceStartProp = property(get_OpticalPathDistanceStart, set_OpticalPathDistanceStart)
    def get_OpticalPathDistanceEnd(self): return self.OpticalPathDistanceEnd
    def set_OpticalPathDistanceEnd(self, OpticalPathDistanceEnd): self.OpticalPathDistanceEnd = OpticalPathDistanceEnd
    OpticalPathDistanceEndProp = property(get_OpticalPathDistanceEnd, set_OpticalPathDistanceEnd)
    def get_Direction(self): return self.Direction
    def set_Direction(self, Direction): self.Direction = Direction
    DirectionProp = property(get_Direction, set_Direction)
    def get_Wavelength(self): return self.Wavelength
    def set_Wavelength(self, Wavelength): self.Wavelength = Wavelength
    WavelengthProp = property(get_Wavelength, set_Wavelength)
    def get_FiberOTDRInstrumentBox(self): return self.FiberOTDRInstrumentBox
    def set_FiberOTDRInstrumentBox(self, FiberOTDRInstrumentBox): self.FiberOTDRInstrumentBox = FiberOTDRInstrumentBox
    FiberOTDRInstrumentBoxProp = property(get_FiberOTDRInstrumentBox, set_FiberOTDRInstrumentBox)
    def get_MeasurementContact(self): return self.MeasurementContact
    def set_MeasurementContact(self, MeasurementContact): self.MeasurementContact = MeasurementContact
    MeasurementContactProp = property(get_MeasurementContact, set_MeasurementContact)
    def get_ExtensionNameValue(self): return self.ExtensionNameValue
    def set_ExtensionNameValue(self, ExtensionNameValue): self.ExtensionNameValue = ExtensionNameValue
    def add_ExtensionNameValue(self, value): self.ExtensionNameValue.append(value)
    def insert_ExtensionNameValue_at(self, index, value): self.ExtensionNameValue.insert(index, value)
    def replace_ExtensionNameValue_at(self, index, value): self.ExtensionNameValue[index] = value
    ExtensionNameValueProp = property(get_ExtensionNameValue, set_ExtensionNameValue)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_OTDRReason(self, value):
        # Validate type OTDRReason, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['dts', 'other', 'post-installation', 'pre-installation', 'run']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OTDRReason' % {"value" : value.encode("utf-8")} )
    def validate_OTDRDirection(self, value):
        # Validate type OTDRDirection, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['backward', 'forward']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OTDRDirection' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.ReasonForRun is not None or
            self.DTimRun is not None or
            self.DataInOTDRFile is not None or
            self.OTDRImageFile is not None or
            self.OpticalPathDistanceStart is not None or
            self.OpticalPathDistanceEnd is not None or
            self.Direction is not None or
            self.Wavelength is not None or
            self.FiberOTDRInstrumentBox is not None or
            self.MeasurementContact is not None or
            self.ExtensionNameValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberOTDR', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberOTDR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberOTDR', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberOTDR'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberOTDR', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.ReasonForRun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReasonForRun>%s</%sReasonForRun>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ReasonForRun), input_name='ReasonForRun')), namespace_, eol_))
        if self.DTimRun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTimRun>%s</%sDTimRun>%s' % (namespace_, self.gds_format_datetime(self.DTimRun, input_name='DTimRun'), namespace_, eol_))
        if self.DataInOTDRFile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataInOTDRFile>%s</%sDataInOTDRFile>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DataInOTDRFile), input_name='DataInOTDRFile')), namespace_, eol_))
        if self.OTDRImageFile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOTDRImageFile>%s</%sOTDRImageFile>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OTDRImageFile), input_name='OTDRImageFile')), namespace_, eol_))
        if self.OpticalPathDistanceStart is not None:
            self.OpticalPathDistanceStart.export(outfile, level, namespace_, name_='OpticalPathDistanceStart', pretty_print=pretty_print)
        if self.OpticalPathDistanceEnd is not None:
            self.OpticalPathDistanceEnd.export(outfile, level, namespace_, name_='OpticalPathDistanceEnd', pretty_print=pretty_print)
        if self.Direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDirection>%s</%sDirection>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Direction), input_name='Direction')), namespace_, eol_))
        if self.Wavelength is not None:
            self.Wavelength.export(outfile, level, namespace_, name_='Wavelength', pretty_print=pretty_print)
        if self.FiberOTDRInstrumentBox is not None:
            self.FiberOTDRInstrumentBox.export(outfile, level, namespace_, name_='FiberOTDRInstrumentBox', pretty_print=pretty_print)
        if self.MeasurementContact is not None:
            self.MeasurementContact.export(outfile, level, namespace_, name_='MeasurementContact', pretty_print=pretty_print)
        for ExtensionNameValue_ in self.ExtensionNameValue:
            ExtensionNameValue_.export(outfile, level, namespace_, name_='ExtensionNameValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'ReasonForRun':
            ReasonForRun_ = child_.text
            ReasonForRun_ = self.gds_validate_string(ReasonForRun_, node, 'ReasonForRun')
            self.ReasonForRun = ReasonForRun_
            # validate type OTDRReason
            self.validate_OTDRReason(self.ReasonForRun)
        elif nodeName_ == 'DTimRun':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DTimRun = dval_
        elif nodeName_ == 'DataInOTDRFile':
            DataInOTDRFile_ = child_.text
            DataInOTDRFile_ = self.gds_validate_string(DataInOTDRFile_, node, 'DataInOTDRFile')
            self.DataInOTDRFile = DataInOTDRFile_
            # validate type String64
            self.validate_String64(self.DataInOTDRFile)
        elif nodeName_ == 'OTDRImageFile':
            OTDRImageFile_ = child_.text
            OTDRImageFile_ = self.gds_validate_string(OTDRImageFile_, node, 'OTDRImageFile')
            self.OTDRImageFile = OTDRImageFile_
            # validate type String64
            self.validate_String64(self.OTDRImageFile)
        elif nodeName_ == 'OpticalPathDistanceStart':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.OpticalPathDistanceStart = obj_
            obj_.original_tagname_ = 'OpticalPathDistanceStart'
        elif nodeName_ == 'OpticalPathDistanceEnd':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.OpticalPathDistanceEnd = obj_
            obj_.original_tagname_ = 'OpticalPathDistanceEnd'
        elif nodeName_ == 'Direction':
            Direction_ = child_.text
            Direction_ = self.gds_validate_string(Direction_, node, 'Direction')
            self.Direction = Direction_
            # validate type OTDRDirection
            self.validate_OTDRDirection(self.Direction)
        elif nodeName_ == 'Wavelength':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.Wavelength = obj_
            obj_.original_tagname_ = 'Wavelength'
        elif nodeName_ == 'FiberOTDRInstrumentBox':
            obj_ = FiberOTDRInstrumentBox.factory()
            obj_.build(child_)
            self.FiberOTDRInstrumentBox = obj_
            obj_.original_tagname_ = 'FiberOTDRInstrumentBox'
        elif nodeName_ == 'MeasurementContact':
            obj_ = BusinessAssociate.factory()
            obj_.build(child_)
            self.MeasurementContact = obj_
            obj_.original_tagname_ = 'MeasurementContact'
        elif nodeName_ == 'ExtensionNameValue':
            obj_ = ExtensionNameValue.factory()
            obj_.build(child_)
            self.ExtensionNameValue.append(obj_)
            obj_.original_tagname_ = 'ExtensionNameValue'
# end class FiberOTDR


class FiberOTDRInstrumentBox(Instrument):
    """Information about an OTDR instrument box taht is used to perform
    OTDR surveys on the optical path."""
    subclass = None
    superclass = Instrument
    def __init__(self, Name=None, Manufacturer=None, ManufacturingDate=None, Type=None, SupplyDate=None, SupplierModelNumber=None, SoftwareVersion=None, Comment=None, Supplier=None, InstrumentVendor=None):
        self.original_tagname_ = None
        super(FiberOTDRInstrumentBox, self).__init__(Name, Manufacturer, ManufacturingDate, Type, SupplyDate, SupplierModelNumber, SoftwareVersion, Comment, Supplier, InstrumentVendor, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberOTDRInstrumentBox)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberOTDRInstrumentBox.subclass:
            return FiberOTDRInstrumentBox.subclass(*args_, **kwargs_)
        else:
            return FiberOTDRInstrumentBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(FiberOTDRInstrumentBox, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberOTDRInstrumentBox', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberOTDRInstrumentBox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberOTDRInstrumentBox', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberOTDRInstrumentBox'):
        super(FiberOTDRInstrumentBox, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FiberOTDRInstrumentBox')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberOTDRInstrumentBox', fromsubclass_=False, pretty_print=True):
        super(FiberOTDRInstrumentBox, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FiberOTDRInstrumentBox, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FiberOTDRInstrumentBox, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FiberOTDRInstrumentBox


class FiberPathDefect(GeneratedsSuper):
    """A zone of the fiber that has defective optical properties (e.g.,
    darkening).The unique identifier of this object."""
    subclass = None
    superclass = None
    def __init__(self, defectID=None, OpticalPathDistanceStart=None, OpticalPathDistanceEnd=None, DefectType=None, TimeStart=None, TimeEnd=None, Comment=None):
        self.original_tagname_ = None
        self.defectID = _cast(None, defectID)
        self.OpticalPathDistanceStart = OpticalPathDistanceStart
        self.OpticalPathDistanceEnd = OpticalPathDistanceEnd
        self.DefectType = DefectType
        self.validate_PathDefectTypes(self.DefectType)
        if isinstance(TimeStart, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(TimeStart, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = TimeStart
        self.TimeStart = initvalue_
        if isinstance(TimeEnd, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(TimeEnd, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = TimeEnd
        self.TimeEnd = initvalue_
        self.Comment = Comment
        self.validate_String2000(self.Comment)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberPathDefect)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberPathDefect.subclass:
            return FiberPathDefect.subclass(*args_, **kwargs_)
        else:
            return FiberPathDefect(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpticalPathDistanceStart(self): return self.OpticalPathDistanceStart
    def set_OpticalPathDistanceStart(self, OpticalPathDistanceStart): self.OpticalPathDistanceStart = OpticalPathDistanceStart
    OpticalPathDistanceStartProp = property(get_OpticalPathDistanceStart, set_OpticalPathDistanceStart)
    def get_OpticalPathDistanceEnd(self): return self.OpticalPathDistanceEnd
    def set_OpticalPathDistanceEnd(self, OpticalPathDistanceEnd): self.OpticalPathDistanceEnd = OpticalPathDistanceEnd
    OpticalPathDistanceEndProp = property(get_OpticalPathDistanceEnd, set_OpticalPathDistanceEnd)
    def get_DefectType(self): return self.DefectType
    def set_DefectType(self, DefectType): self.DefectType = DefectType
    DefectTypeProp = property(get_DefectType, set_DefectType)
    def get_TimeStart(self): return self.TimeStart
    def set_TimeStart(self, TimeStart): self.TimeStart = TimeStart
    TimeStartProp = property(get_TimeStart, set_TimeStart)
    def get_TimeEnd(self): return self.TimeEnd
    def set_TimeEnd(self, TimeEnd): self.TimeEnd = TimeEnd
    TimeEndProp = property(get_TimeEnd, set_TimeEnd)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_defectID(self): return self.defectID
    def set_defectID(self, defectID): self.defectID = defectID
    defectIDProp = property(get_defectID, set_defectID)
    def validate_PathDefectTypes(self, value):
        # Validate type PathDefectTypes, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['darkened fiber', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PathDefectTypes' % {"value" : value.encode("utf-8")} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.OpticalPathDistanceStart is not None or
            self.OpticalPathDistanceEnd is not None or
            self.DefectType is not None or
            self.TimeStart is not None or
            self.TimeEnd is not None or
            self.Comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberPathDefect', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberPathDefect')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberPathDefect', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberPathDefect'):
        if self.defectID is not None and 'defectID' not in already_processed:
            already_processed.add('defectID')
            outfile.write(' defectID=%s' % (quote_attrib(self.defectID), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberPathDefect', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OpticalPathDistanceStart is not None:
            self.OpticalPathDistanceStart.export(outfile, level, namespace_, name_='OpticalPathDistanceStart', pretty_print=pretty_print)
        if self.OpticalPathDistanceEnd is not None:
            self.OpticalPathDistanceEnd.export(outfile, level, namespace_, name_='OpticalPathDistanceEnd', pretty_print=pretty_print)
        if self.DefectType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefectType>%s</%sDefectType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DefectType), input_name='DefectType')), namespace_, eol_))
        if self.TimeStart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeStart>%s</%sTimeStart>%s' % (namespace_, self.gds_format_datetime(self.TimeStart, input_name='TimeStart'), namespace_, eol_))
        if self.TimeEnd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeEnd>%s</%sTimeEnd>%s' % (namespace_, self.gds_format_datetime(self.TimeEnd, input_name='TimeEnd'), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('defectID', node)
        if value is not None and 'defectID' not in already_processed:
            already_processed.add('defectID')
            self.defectID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpticalPathDistanceStart':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.OpticalPathDistanceStart = obj_
            obj_.original_tagname_ = 'OpticalPathDistanceStart'
        elif nodeName_ == 'OpticalPathDistanceEnd':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.OpticalPathDistanceEnd = obj_
            obj_.original_tagname_ = 'OpticalPathDistanceEnd'
        elif nodeName_ == 'DefectType':
            DefectType_ = child_.text
            DefectType_ = self.gds_validate_string(DefectType_, node, 'DefectType')
            self.DefectType = DefectType_
            # validate type PathDefectTypes
            self.validate_PathDefectTypes(self.DefectType)
        elif nodeName_ == 'TimeStart':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.TimeStart = dval_
        elif nodeName_ == 'TimeEnd':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.TimeEnd = dval_
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
# end class FiberPathDefect


class FiberPumpActivity(GeneratedsSuper):
    """The activity of pumping the fiber downhole into a control line
    (small diameter tube).Unique identifier of this object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Name=None, InstalledFiber=None, PumpingDate=None, EngineerName=None, ServiceCompany=None, PumpFluidType=None, ControlLineFluid=None, PumpDirection=None, FiberEndSeal=None, CableMeterType=None, CableMeterSerialNumber=None, CableMeterCalibrationDate=None, ExcessFiberRecovered=None, Comment=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Name = Name
        self.validate_String64(self.Name)
        self.InstalledFiber = InstalledFiber
        self.validate_String64(self.InstalledFiber)
        if isinstance(PumpingDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(PumpingDate, '%Y-%m-%d').date()
        else:
            initvalue_ = PumpingDate
        self.PumpingDate = initvalue_
        self.EngineerName = EngineerName
        self.validate_String64(self.EngineerName)
        self.ServiceCompany = ServiceCompany
        self.validate_String64(self.ServiceCompany)
        self.PumpFluidType = PumpFluidType
        self.validate_String64(self.PumpFluidType)
        self.ControlLineFluid = ControlLineFluid
        self.validate_String64(self.ControlLineFluid)
        self.PumpDirection = PumpDirection
        self.validate_String64(self.PumpDirection)
        self.FiberEndSeal = FiberEndSeal
        self.validate_String64(self.FiberEndSeal)
        self.CableMeterType = CableMeterType
        self.validate_String64(self.CableMeterType)
        self.CableMeterSerialNumber = CableMeterSerialNumber
        self.validate_String64(self.CableMeterSerialNumber)
        if isinstance(CableMeterCalibrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CableMeterCalibrationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = CableMeterCalibrationDate
        self.CableMeterCalibrationDate = initvalue_
        self.ExcessFiberRecovered = ExcessFiberRecovered
        self.Comment = Comment
        self.validate_String2000(self.Comment)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberPumpActivity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberPumpActivity.subclass:
            return FiberPumpActivity.subclass(*args_, **kwargs_)
        else:
            return FiberPumpActivity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_InstalledFiber(self): return self.InstalledFiber
    def set_InstalledFiber(self, InstalledFiber): self.InstalledFiber = InstalledFiber
    InstalledFiberProp = property(get_InstalledFiber, set_InstalledFiber)
    def get_PumpingDate(self): return self.PumpingDate
    def set_PumpingDate(self, PumpingDate): self.PumpingDate = PumpingDate
    PumpingDateProp = property(get_PumpingDate, set_PumpingDate)
    def get_EngineerName(self): return self.EngineerName
    def set_EngineerName(self, EngineerName): self.EngineerName = EngineerName
    EngineerNameProp = property(get_EngineerName, set_EngineerName)
    def get_ServiceCompany(self): return self.ServiceCompany
    def set_ServiceCompany(self, ServiceCompany): self.ServiceCompany = ServiceCompany
    ServiceCompanyProp = property(get_ServiceCompany, set_ServiceCompany)
    def get_PumpFluidType(self): return self.PumpFluidType
    def set_PumpFluidType(self, PumpFluidType): self.PumpFluidType = PumpFluidType
    PumpFluidTypeProp = property(get_PumpFluidType, set_PumpFluidType)
    def get_ControlLineFluid(self): return self.ControlLineFluid
    def set_ControlLineFluid(self, ControlLineFluid): self.ControlLineFluid = ControlLineFluid
    ControlLineFluidProp = property(get_ControlLineFluid, set_ControlLineFluid)
    def get_PumpDirection(self): return self.PumpDirection
    def set_PumpDirection(self, PumpDirection): self.PumpDirection = PumpDirection
    PumpDirectionProp = property(get_PumpDirection, set_PumpDirection)
    def get_FiberEndSeal(self): return self.FiberEndSeal
    def set_FiberEndSeal(self, FiberEndSeal): self.FiberEndSeal = FiberEndSeal
    FiberEndSealProp = property(get_FiberEndSeal, set_FiberEndSeal)
    def get_CableMeterType(self): return self.CableMeterType
    def set_CableMeterType(self, CableMeterType): self.CableMeterType = CableMeterType
    CableMeterTypeProp = property(get_CableMeterType, set_CableMeterType)
    def get_CableMeterSerialNumber(self): return self.CableMeterSerialNumber
    def set_CableMeterSerialNumber(self, CableMeterSerialNumber): self.CableMeterSerialNumber = CableMeterSerialNumber
    CableMeterSerialNumberProp = property(get_CableMeterSerialNumber, set_CableMeterSerialNumber)
    def get_CableMeterCalibrationDate(self): return self.CableMeterCalibrationDate
    def set_CableMeterCalibrationDate(self, CableMeterCalibrationDate): self.CableMeterCalibrationDate = CableMeterCalibrationDate
    CableMeterCalibrationDateProp = property(get_CableMeterCalibrationDate, set_CableMeterCalibrationDate)
    def get_ExcessFiberRecovered(self): return self.ExcessFiberRecovered
    def set_ExcessFiberRecovered(self, ExcessFiberRecovered): self.ExcessFiberRecovered = ExcessFiberRecovered
    ExcessFiberRecoveredProp = property(get_ExcessFiberRecovered, set_ExcessFiberRecovered)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.InstalledFiber is not None or
            self.PumpingDate is not None or
            self.EngineerName is not None or
            self.ServiceCompany is not None or
            self.PumpFluidType is not None or
            self.ControlLineFluid is not None or
            self.PumpDirection is not None or
            self.FiberEndSeal is not None or
            self.CableMeterType is not None or
            self.CableMeterSerialNumber is not None or
            self.CableMeterCalibrationDate is not None or
            self.ExcessFiberRecovered is not None or
            self.Comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberPumpActivity', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberPumpActivity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberPumpActivity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberPumpActivity'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberPumpActivity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.InstalledFiber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstalledFiber>%s</%sInstalledFiber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.InstalledFiber), input_name='InstalledFiber')), namespace_, eol_))
        if self.PumpingDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPumpingDate>%s</%sPumpingDate>%s' % (namespace_, self.gds_format_date(self.PumpingDate, input_name='PumpingDate'), namespace_, eol_))
        if self.EngineerName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEngineerName>%s</%sEngineerName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EngineerName), input_name='EngineerName')), namespace_, eol_))
        if self.ServiceCompany is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sServiceCompany>%s</%sServiceCompany>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ServiceCompany), input_name='ServiceCompany')), namespace_, eol_))
        if self.PumpFluidType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPumpFluidType>%s</%sPumpFluidType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PumpFluidType), input_name='PumpFluidType')), namespace_, eol_))
        if self.ControlLineFluid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlLineFluid>%s</%sControlLineFluid>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlLineFluid), input_name='ControlLineFluid')), namespace_, eol_))
        if self.PumpDirection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPumpDirection>%s</%sPumpDirection>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PumpDirection), input_name='PumpDirection')), namespace_, eol_))
        if self.FiberEndSeal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFiberEndSeal>%s</%sFiberEndSeal>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FiberEndSeal), input_name='FiberEndSeal')), namespace_, eol_))
        if self.CableMeterType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCableMeterType>%s</%sCableMeterType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CableMeterType), input_name='CableMeterType')), namespace_, eol_))
        if self.CableMeterSerialNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCableMeterSerialNumber>%s</%sCableMeterSerialNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CableMeterSerialNumber), input_name='CableMeterSerialNumber')), namespace_, eol_))
        if self.CableMeterCalibrationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCableMeterCalibrationDate>%s</%sCableMeterCalibrationDate>%s' % (namespace_, self.gds_format_date(self.CableMeterCalibrationDate, input_name='CableMeterCalibrationDate'), namespace_, eol_))
        if self.ExcessFiberRecovered is not None:
            self.ExcessFiberRecovered.export(outfile, level, namespace_, name_='ExcessFiberRecovered', pretty_print=pretty_print)
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'InstalledFiber':
            InstalledFiber_ = child_.text
            InstalledFiber_ = self.gds_validate_string(InstalledFiber_, node, 'InstalledFiber')
            self.InstalledFiber = InstalledFiber_
            # validate type String64
            self.validate_String64(self.InstalledFiber)
        elif nodeName_ == 'PumpingDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.PumpingDate = dval_
        elif nodeName_ == 'EngineerName':
            EngineerName_ = child_.text
            EngineerName_ = self.gds_validate_string(EngineerName_, node, 'EngineerName')
            self.EngineerName = EngineerName_
            # validate type String64
            self.validate_String64(self.EngineerName)
        elif nodeName_ == 'ServiceCompany':
            ServiceCompany_ = child_.text
            ServiceCompany_ = self.gds_validate_string(ServiceCompany_, node, 'ServiceCompany')
            self.ServiceCompany = ServiceCompany_
            # validate type String64
            self.validate_String64(self.ServiceCompany)
        elif nodeName_ == 'PumpFluidType':
            PumpFluidType_ = child_.text
            PumpFluidType_ = self.gds_validate_string(PumpFluidType_, node, 'PumpFluidType')
            self.PumpFluidType = PumpFluidType_
            # validate type String64
            self.validate_String64(self.PumpFluidType)
        elif nodeName_ == 'ControlLineFluid':
            ControlLineFluid_ = child_.text
            ControlLineFluid_ = self.gds_validate_string(ControlLineFluid_, node, 'ControlLineFluid')
            self.ControlLineFluid = ControlLineFluid_
            # validate type String64
            self.validate_String64(self.ControlLineFluid)
        elif nodeName_ == 'PumpDirection':
            PumpDirection_ = child_.text
            PumpDirection_ = self.gds_validate_string(PumpDirection_, node, 'PumpDirection')
            self.PumpDirection = PumpDirection_
            # validate type String64
            self.validate_String64(self.PumpDirection)
        elif nodeName_ == 'FiberEndSeal':
            FiberEndSeal_ = child_.text
            FiberEndSeal_ = self.gds_validate_string(FiberEndSeal_, node, 'FiberEndSeal')
            self.FiberEndSeal = FiberEndSeal_
            # validate type String64
            self.validate_String64(self.FiberEndSeal)
        elif nodeName_ == 'CableMeterType':
            CableMeterType_ = child_.text
            CableMeterType_ = self.gds_validate_string(CableMeterType_, node, 'CableMeterType')
            self.CableMeterType = CableMeterType_
            # validate type String64
            self.validate_String64(self.CableMeterType)
        elif nodeName_ == 'CableMeterSerialNumber':
            CableMeterSerialNumber_ = child_.text
            CableMeterSerialNumber_ = self.gds_validate_string(CableMeterSerialNumber_, node, 'CableMeterSerialNumber')
            self.CableMeterSerialNumber = CableMeterSerialNumber_
            # validate type String64
            self.validate_String64(self.CableMeterSerialNumber)
        elif nodeName_ == 'CableMeterCalibrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.CableMeterCalibrationDate = dval_
        elif nodeName_ == 'ExcessFiberRecovered':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.ExcessFiberRecovered = obj_
            obj_.original_tagname_ = 'ExcessFiberRecovered'
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
# end class FiberPumpActivity


class FiberRefractiveIndex(GeneratedsSuper):
    """The refractive index of a material depends on the frequency (or
    wavelength) of the light. Hence, it is necessary to include both
    the value (a unitless number) and the frequency (or wavelength)
    it was measured at. The frequency will be a quantity type with a
    frequency unit such as Hz.Unique identifier of this object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Value=None, Frequency=None, Wavelength=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Value = Value
        self.Frequency = Frequency
        self.Wavelength = Wavelength
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberRefractiveIndex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberRefractiveIndex.subclass:
            return FiberRefractiveIndex.subclass(*args_, **kwargs_)
        else:
            return FiberRefractiveIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    ValueProp = property(get_Value, set_Value)
    def get_Frequency(self): return self.Frequency
    def set_Frequency(self, Frequency): self.Frequency = Frequency
    FrequencyProp = property(get_Frequency, set_Frequency)
    def get_Wavelength(self): return self.Wavelength
    def set_Wavelength(self, Wavelength): self.Wavelength = Wavelength
    WavelengthProp = property(get_Wavelength, set_Wavelength)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def hasContent_(self):
        if (
            self.Value is not None or
            self.Frequency is not None or
            self.Wavelength is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberRefractiveIndex', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberRefractiveIndex')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberRefractiveIndex', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberRefractiveIndex'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberRefractiveIndex', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            self.Value.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
        if self.Frequency is not None:
            self.Frequency.export(outfile, level, namespace_, name_='Frequency', pretty_print=pretty_print)
        if self.Wavelength is not None:
            self.Wavelength.export(outfile, level, namespace_, name_='Wavelength', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            obj_ = LogarithmicPowerRatioPerLengthMeasure.factory()
            obj_.build(child_)
            self.Value = obj_
            obj_.original_tagname_ = 'Value'
        elif nodeName_ == 'Frequency':
            obj_ = FrequencyMeasure.factory()
            obj_.build(child_)
            self.Frequency = obj_
            obj_.original_tagname_ = 'Frequency'
        elif nodeName_ == 'Wavelength':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.Wavelength = obj_
            obj_.original_tagname_ = 'Wavelength'
# end class FiberRefractiveIndex


class FiberSplice(FiberCommon):
    """A splice component within the optical path."""
    subclass = None
    superclass = FiberCommon
    def __init__(self, Name=None, Manufacturer=None, ManufacturingDate=None, Type=None, SupplyDate=None, SupplierModelNumber=None, SoftwareVersion=None, Comment=None, Supplier=None, uid=None, Reflectance=None, Loss=None, ReasonForDecommissioning=None, SpliceEquipmentUsedReference=None, StrippingType=None, ProtectorType=None, FiberSpliceType=None, PressureRating=None, BendAngle=None):
        self.original_tagname_ = None
        super(FiberSplice, self).__init__(Name, Manufacturer, ManufacturingDate, Type, SupplyDate, SupplierModelNumber, SoftwareVersion, Comment, Supplier, uid, Reflectance, Loss, ReasonForDecommissioning, )
        self.SpliceEquipmentUsedReference = SpliceEquipmentUsedReference
        self.validate_String64(self.SpliceEquipmentUsedReference)
        self.StrippingType = StrippingType
        self.validate_String64(self.StrippingType)
        self.ProtectorType = ProtectorType
        self.validate_String64(self.ProtectorType)
        self.FiberSpliceType = FiberSpliceType
        self.validate_FiberSpliceTypes(self.FiberSpliceType)
        self.PressureRating = PressureRating
        self.BendAngle = BendAngle
        self.validate_PlaneAngleUom(self.BendAngle)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberSplice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberSplice.subclass:
            return FiberSplice.subclass(*args_, **kwargs_)
        else:
            return FiberSplice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpliceEquipmentUsedReference(self): return self.SpliceEquipmentUsedReference
    def set_SpliceEquipmentUsedReference(self, SpliceEquipmentUsedReference): self.SpliceEquipmentUsedReference = SpliceEquipmentUsedReference
    SpliceEquipmentUsedReferenceProp = property(get_SpliceEquipmentUsedReference, set_SpliceEquipmentUsedReference)
    def get_StrippingType(self): return self.StrippingType
    def set_StrippingType(self, StrippingType): self.StrippingType = StrippingType
    StrippingTypeProp = property(get_StrippingType, set_StrippingType)
    def get_ProtectorType(self): return self.ProtectorType
    def set_ProtectorType(self, ProtectorType): self.ProtectorType = ProtectorType
    ProtectorTypeProp = property(get_ProtectorType, set_ProtectorType)
    def get_FiberSpliceType(self): return self.FiberSpliceType
    def set_FiberSpliceType(self, FiberSpliceType): self.FiberSpliceType = FiberSpliceType
    FiberSpliceTypeProp = property(get_FiberSpliceType, set_FiberSpliceType)
    def get_PressureRating(self): return self.PressureRating
    def set_PressureRating(self, PressureRating): self.PressureRating = PressureRating
    PressureRatingProp = property(get_PressureRating, set_PressureRating)
    def get_BendAngle(self): return self.BendAngle
    def set_BendAngle(self, BendAngle): self.BendAngle = BendAngle
    BendAngleProp = property(get_BendAngle, set_BendAngle)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_FiberSpliceTypes(self, value):
        # Validate type FiberSpliceTypes, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['cable splice', 'h splice', 'user-custom']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FiberSpliceTypes' % {"value" : value.encode("utf-8")} )
    def validate_PlaneAngleUom(self, value):
        # Validate type PlaneAngleUom, a restriction on eml:UomEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0.001 seca', 'ccgr', 'cgr', 'dega', 'gon', 'krad', 'mila', 'mina', 'Mrad', 'mrad', 'rad', 'rev', 'seca', 'urad']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PlaneAngleUom' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SpliceEquipmentUsedReference is not None or
            self.StrippingType is not None or
            self.ProtectorType is not None or
            self.FiberSpliceType is not None or
            self.PressureRating is not None or
            self.BendAngle is not None or
            super(FiberSplice, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberSplice', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberSplice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberSplice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberSplice'):
        super(FiberSplice, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FiberSplice')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberSplice', fromsubclass_=False, pretty_print=True):
        super(FiberSplice, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpliceEquipmentUsedReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpliceEquipmentUsedReference>%s</%sSpliceEquipmentUsedReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SpliceEquipmentUsedReference), input_name='SpliceEquipmentUsedReference')), namespace_, eol_))
        if self.StrippingType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStrippingType>%s</%sStrippingType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StrippingType), input_name='StrippingType')), namespace_, eol_))
        if self.ProtectorType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtectorType>%s</%sProtectorType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ProtectorType), input_name='ProtectorType')), namespace_, eol_))
        if self.FiberSpliceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFiberSpliceType>%s</%sFiberSpliceType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FiberSpliceType), input_name='FiberSpliceType')), namespace_, eol_))
        if self.PressureRating is not None:
            self.PressureRating.export(outfile, level, namespace_, name_='PressureRating', pretty_print=pretty_print)
        if self.BendAngle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBendAngle>%s</%sBendAngle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BendAngle), input_name='BendAngle')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FiberSplice, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpliceEquipmentUsedReference':
            SpliceEquipmentUsedReference_ = child_.text
            SpliceEquipmentUsedReference_ = self.gds_validate_string(SpliceEquipmentUsedReference_, node, 'SpliceEquipmentUsedReference')
            self.SpliceEquipmentUsedReference = SpliceEquipmentUsedReference_
            # validate type String64
            self.validate_String64(self.SpliceEquipmentUsedReference)
        elif nodeName_ == 'StrippingType':
            StrippingType_ = child_.text
            StrippingType_ = self.gds_validate_string(StrippingType_, node, 'StrippingType')
            self.StrippingType = StrippingType_
            # validate type String64
            self.validate_String64(self.StrippingType)
        elif nodeName_ == 'ProtectorType':
            ProtectorType_ = child_.text
            ProtectorType_ = self.gds_validate_string(ProtectorType_, node, 'ProtectorType')
            self.ProtectorType = ProtectorType_
            # validate type String64
            self.validate_String64(self.ProtectorType)
        elif nodeName_ == 'FiberSpliceType':
            FiberSpliceType_ = child_.text
            FiberSpliceType_ = self.gds_validate_string(FiberSpliceType_, node, 'FiberSpliceType')
            self.FiberSpliceType = FiberSpliceType_
            # validate type FiberSpliceTypes
            self.validate_FiberSpliceTypes(self.FiberSpliceType)
        elif nodeName_ == 'PressureRating':
            obj_ = PressureMeasure.factory()
            obj_.build(child_)
            self.PressureRating = obj_
            obj_.original_tagname_ = 'PressureRating'
        elif nodeName_ == 'BendAngle':
            BendAngle_ = child_.text
            BendAngle_ = self.gds_validate_string(BendAngle_, node, 'BendAngle')
            self.BendAngle = BendAngle_
            # validate type PlaneAngleUom
            self.validate_PlaneAngleUom(self.BendAngle)
        super(FiberSplice, self).buildChildren(child_, node, nodeName_, True)
# end class FiberSplice


class FiberTerminator(FiberCommon):
    """The terminator of the optical path. This may be a component (in the
    case of a single ended fiber installation), or it may be a
    connection back into the instrument box in the case of a double
    ended fiber installation."""
    subclass = None
    superclass = FiberCommon
    def __init__(self, Name=None, Manufacturer=None, ManufacturingDate=None, Type=None, SupplyDate=None, SupplierModelNumber=None, SoftwareVersion=None, Comment=None, Supplier=None, uid=None, Reflectance=None, Loss=None, ReasonForDecommissioning=None, TerminationType=None):
        self.original_tagname_ = None
        super(FiberTerminator, self).__init__(Name, Manufacturer, ManufacturingDate, Type, SupplyDate, SupplierModelNumber, SoftwareVersion, Comment, Supplier, uid, Reflectance, Loss, ReasonForDecommissioning, )
        self.TerminationType = TerminationType
        self.validate_TerminationType(self.TerminationType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberTerminator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberTerminator.subclass:
            return FiberTerminator.subclass(*args_, **kwargs_)
        else:
            return FiberTerminator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TerminationType(self): return self.TerminationType
    def set_TerminationType(self, TerminationType): self.TerminationType = TerminationType
    TerminationTypeProp = property(get_TerminationType, set_TerminationType)
    def validate_TerminationType(self, value):
        # Validate type TerminationType, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['looped back to instrument box', 'termination at cable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TerminationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.TerminationType is not None or
            super(FiberTerminator, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberTerminator', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberTerminator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberTerminator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberTerminator'):
        super(FiberTerminator, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FiberTerminator')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberTerminator', fromsubclass_=False, pretty_print=True):
        super(FiberTerminator, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TerminationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTerminationType>%s</%sTerminationType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TerminationType), input_name='TerminationType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FiberTerminator, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TerminationType':
            TerminationType_ = child_.text
            TerminationType_ = self.gds_validate_string(TerminationType_, node, 'TerminationType')
            self.TerminationType = TerminationType_
            # validate type TerminationType
            self.validate_TerminationType(self.TerminationType)
        super(FiberTerminator, self).buildChildren(child_, node, nodeName_, True)
# end class FiberTerminator


class FiberTurnaround(FiberCommon):
    """A turnaround component within the optical path."""
    subclass = None
    superclass = FiberCommon
    def __init__(self, Name=None, Manufacturer=None, ManufacturingDate=None, Type=None, SupplyDate=None, SupplierModelNumber=None, SoftwareVersion=None, Comment=None, Supplier=None, uid=None, Reflectance=None, Loss=None, ReasonForDecommissioning=None):
        self.original_tagname_ = None
        super(FiberTurnaround, self).__init__(Name, Manufacturer, ManufacturingDate, Type, SupplyDate, SupplierModelNumber, SoftwareVersion, Comment, Supplier, uid, Reflectance, Loss, ReasonForDecommissioning, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberTurnaround)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberTurnaround.subclass:
            return FiberTurnaround.subclass(*args_, **kwargs_)
        else:
            return FiberTurnaround(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(FiberTurnaround, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberTurnaround', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberTurnaround')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberTurnaround', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberTurnaround'):
        super(FiberTurnaround, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FiberTurnaround')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberTurnaround', fromsubclass_=False, pretty_print=True):
        super(FiberTurnaround, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FiberTurnaround, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FiberTurnaround, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FiberTurnaround


class Frequency(AbstractAttenuationMeasure):
    """Frequency."""
    subclass = None
    superclass = AbstractAttenuationMeasure
    def __init__(self, Frequency_member=None):
        self.original_tagname_ = None
        super(Frequency, self).__init__()
        self.Frequency = Frequency_member
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Frequency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Frequency.subclass:
            return Frequency.subclass(*args_, **kwargs_)
        else:
            return Frequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Frequency(self): return self.Frequency
    def set_Frequency(self, Frequency): self.Frequency = Frequency
    FrequencyProp = property(get_Frequency, set_Frequency)
    def hasContent_(self):
        if (
            self.Frequency is not None or
            super(Frequency, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='Frequency', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Frequency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='Frequency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='Frequency'):
        super(Frequency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Frequency')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='Frequency', fromsubclass_=False, pretty_print=True):
        super(Frequency, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Frequency is not None:
            self.Frequency.export(outfile, level, namespace_, name_='Frequency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Frequency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Frequency':
            obj_ = FrequencyMeasure.factory()
            obj_.build(child_)
            self.Frequency = obj_
            obj_.original_tagname_ = 'Frequency'
        super(Frequency, self).buildChildren(child_, node, nodeName_, True)
# end class Frequency


class InterventionConveyance(AbstractCable):
    """Information on type of intervention conveyance used by the optical
    path."""
    subclass = None
    superclass = AbstractCable
    def __init__(self, InterventionConveyanceType=None, Comment=None):
        self.original_tagname_ = None
        super(InterventionConveyance, self).__init__()
        self.InterventionConveyanceType = InterventionConveyanceType
        self.validate_InterventionConveyanceType(self.InterventionConveyanceType)
        self.Comment = Comment
        self.validate_String2000(self.Comment)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InterventionConveyance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InterventionConveyance.subclass:
            return InterventionConveyance.subclass(*args_, **kwargs_)
        else:
            return InterventionConveyance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InterventionConveyanceType(self): return self.InterventionConveyanceType
    def set_InterventionConveyanceType(self, InterventionConveyanceType): self.InterventionConveyanceType = InterventionConveyanceType
    InterventionConveyanceTypeProp = property(get_InterventionConveyanceType, set_InterventionConveyanceType)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def validate_InterventionConveyanceType(self, value):
        # Validate type InterventionConveyanceType, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['coiled tubing', 'rod', 'slickline', 'wireline']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on InterventionConveyanceType' % {"value" : value.encode("utf-8")} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.InterventionConveyanceType is not None or
            self.Comment is not None or
            super(InterventionConveyance, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='InterventionConveyance', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterventionConveyance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='InterventionConveyance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='InterventionConveyance'):
        super(InterventionConveyance, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InterventionConveyance')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='InterventionConveyance', fromsubclass_=False, pretty_print=True):
        super(InterventionConveyance, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InterventionConveyanceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInterventionConveyanceType>%s</%sInterventionConveyanceType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.InterventionConveyanceType), input_name='InterventionConveyanceType')), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InterventionConveyance, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InterventionConveyanceType':
            InterventionConveyanceType_ = child_.text
            InterventionConveyanceType_ = self.gds_validate_string(InterventionConveyanceType_, node, 'InterventionConveyanceType')
            self.InterventionConveyanceType = InterventionConveyanceType_
            # validate type InterventionConveyanceType
            self.validate_InterventionConveyanceType(self.InterventionConveyanceType)
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        super(InterventionConveyance, self).buildChildren(child_, node, nodeName_, True)
# end class InterventionConveyance


class PermanentCable(AbstractCable):
    """Information on the type of permanent conveyance used by the optical
    path."""
    subclass = None
    superclass = AbstractCable
    def __init__(self, PermanentCableInstallationType=None, Comment=None):
        self.original_tagname_ = None
        super(PermanentCable, self).__init__()
        self.PermanentCableInstallationType = PermanentCableInstallationType
        self.validate_PermanentCableInstallationType(self.PermanentCableInstallationType)
        self.Comment = Comment
        self.validate_String2000(self.Comment)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PermanentCable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PermanentCable.subclass:
            return PermanentCable.subclass(*args_, **kwargs_)
        else:
            return PermanentCable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PermanentCableInstallationType(self): return self.PermanentCableInstallationType
    def set_PermanentCableInstallationType(self, PermanentCableInstallationType): self.PermanentCableInstallationType = PermanentCableInstallationType
    PermanentCableInstallationTypeProp = property(get_PermanentCableInstallationType, set_PermanentCableInstallationType)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def validate_PermanentCableInstallationType(self, value):
        # Validate type PermanentCableInstallationType, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['buried parallel to tubular', 'clamped to tubular', 'wrapped around tubular']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PermanentCableInstallationType' % {"value" : value.encode("utf-8")} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.PermanentCableInstallationType is not None or
            self.Comment is not None or
            super(PermanentCable, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PermanentCable', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PermanentCable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PermanentCable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PermanentCable'):
        super(PermanentCable, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PermanentCable')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PermanentCable', fromsubclass_=False, pretty_print=True):
        super(PermanentCable, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PermanentCableInstallationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPermanentCableInstallationType>%s</%sPermanentCableInstallationType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PermanentCableInstallationType), input_name='PermanentCableInstallationType')), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PermanentCable, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PermanentCableInstallationType':
            PermanentCableInstallationType_ = child_.text
            PermanentCableInstallationType_ = self.gds_validate_string(PermanentCableInstallationType_, node, 'PermanentCableInstallationType')
            self.PermanentCableInstallationType = PermanentCableInstallationType_
            # validate type PermanentCableInstallationType
            self.validate_PermanentCableInstallationType(self.PermanentCableInstallationType)
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        super(PermanentCable, self).buildChildren(child_, node, nodeName_, True)
# end class PermanentCable


class WaveLength(AbstractAttenuationMeasure):
    """Wave length."""
    subclass = None
    superclass = AbstractAttenuationMeasure
    def __init__(self, WaveLength_member=None):
        self.original_tagname_ = None
        super(WaveLength, self).__init__()
        self.WaveLength = WaveLength_member
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaveLength)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaveLength.subclass:
            return WaveLength.subclass(*args_, **kwargs_)
        else:
            return WaveLength(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WaveLength(self): return self.WaveLength
    def set_WaveLength(self, WaveLength): self.WaveLength = WaveLength
    WaveLengthProp = property(get_WaveLength, set_WaveLength)
    def hasContent_(self):
        if (
            self.WaveLength is not None or
            super(WaveLength, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='WaveLength', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaveLength')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='WaveLength', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='WaveLength'):
        super(WaveLength, self).exportAttributes(outfile, level, already_processed, namespace_, name_='WaveLength')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='WaveLength', fromsubclass_=False, pretty_print=True):
        super(WaveLength, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WaveLength is not None:
            self.WaveLength.export(outfile, level, namespace_, name_='WaveLength', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(WaveLength, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WaveLength':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.WaveLength = obj_
            obj_.original_tagname_ = 'WaveLength'
        super(WaveLength, self).buildChildren(child_, node, nodeName_, True)
# end class WaveLength


class AbstractDateTimeClass(GeneratedsSuper):
    """A reporting period that is different from the overall report period.
    For example, a particular day within a monthly report. This
    period must conform to the kind of interval. If one value from a
    pair are given, then both values must be given."""
    subclass = None
    superclass = None
    def __init__(self, DTime=None, Date=None, Month=None, extensiontype_=None):
        self.original_tagname_ = None
        self.DTime = DTime
        self.validate_TimeStamp(self.DTime)
        if isinstance(Date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Date
        self.Date = initvalue_
        self.Month = Month
        self.validate_CalendarMonth(self.Month)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractDateTimeClass)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractDateTimeClass.subclass:
            return AbstractDateTimeClass.subclass(*args_, **kwargs_)
        else:
            return AbstractDateTimeClass(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DTime(self): return self.DTime
    def set_DTime(self, DTime): self.DTime = DTime
    DTimeProp = property(get_DTime, set_DTime)
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    DateProp = property(get_Date, set_Date)
    def get_Month(self): return self.Month
    def set_Month(self, Month): self.Month = Month
    MonthProp = property(get_Month, set_Month)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_TimeStamp(self, value):
        # Validate type TimeStamp, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TimeStamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TimeStamp_patterns_, ))
    validate_TimeStamp_patterns_ = [['^.+T.+[Z+\\-].*$']]
    def validate_CalendarMonth(self, value):
        # Validate type CalendarMonth, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CalendarMonth_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CalendarMonth_patterns_, ))
    validate_CalendarMonth_patterns_ = [['^([1-9][0-9][0-9][0-9])-(([0][0-9])$|^([1][0-2]))$']]
    def hasContent_(self):
        if (
            self.DTime is not None or
            self.Date is not None or
            self.Month is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractDateTimeClass', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDateTimeClass')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractDateTimeClass', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractDateTimeClass'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractDateTimeClass', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTime>%s</%sDTime>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DTime), input_name='DTime')), namespace_, eol_))
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDate>%s</%sDate>%s' % (namespace_, self.gds_format_date(self.Date, input_name='Date'), namespace_, eol_))
        if self.Month is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMonth>%s</%sMonth>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Month), input_name='Month')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DTime':
            DTime_ = child_.text
            DTime_ = self.gds_validate_string(DTime_, node, 'DTime')
            self.DTime = DTime_
            # validate type TimeStamp
            self.validate_TimeStamp(self.DTime)
        elif nodeName_ == 'Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Date = dval_
        elif nodeName_ == 'Month':
            Month_ = child_.text
            Month_ = self.gds_validate_string(Month_, node, 'Month')
            self.Month = Month_
            # validate type CalendarMonth
            self.validate_CalendarMonth(self.Month)
# end class AbstractDateTimeClass


class AbstractFluidComponent(GeneratedsSuper):
    """The Abstract base type of FluidComponent.A unique identifier for
    this data element. It is not globally unique (not a uuid) and
    only need be unique within the context of the parent top-level
    object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, MassFraction=None, MoleFraction=None, extensiontype_=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.MassFraction = MassFraction
        self.MoleFraction = MoleFraction
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractFluidComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractFluidComponent.subclass:
            return AbstractFluidComponent.subclass(*args_, **kwargs_)
        else:
            return AbstractFluidComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MassFraction(self): return self.MassFraction
    def set_MassFraction(self, MassFraction): self.MassFraction = MassFraction
    MassFractionProp = property(get_MassFraction, set_MassFraction)
    def get_MoleFraction(self): return self.MoleFraction
    def set_MoleFraction(self, MoleFraction): self.MoleFraction = MoleFraction
    MoleFractionProp = property(get_MoleFraction, set_MoleFraction)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.MassFraction is not None or
            self.MoleFraction is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractFluidComponent', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractFluidComponent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractFluidComponent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractFluidComponent'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractFluidComponent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MassFraction is not None:
            self.MassFraction.export(outfile, level, namespace_, name_='MassFraction', pretty_print=pretty_print)
        if self.MoleFraction is not None:
            self.MoleFraction.export(outfile, level, namespace_, name_='MoleFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MassFraction':
            obj_ = MassPerMassMeasure.factory()
            obj_.build(child_)
            self.MassFraction = obj_
            obj_.original_tagname_ = 'MassFraction'
        elif nodeName_ == 'MoleFraction':
            obj_ = AmountOfSubstancePerAmountOfSubstanceMeasure.factory()
            obj_.build(child_)
            self.MoleFraction = obj_
            obj_.original_tagname_ = 'MoleFraction'
# end class AbstractFluidComponent


class BusinessAssociate(GeneratedsSuper):
    """Describes any company, person, group, consultant, etc., which is
    associated within a context (e.g., a well). The information
    contained in this module is: (1) contact information, such as
    address, phone numbers, email, (2) alternate name, or aliases,
    and (3) associations, such as the business associate that this
    one is associated with, or a contact who is associated with this
    business associate."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, Role=None, Alias=None, Address=None, PhoneNumber=None, Email=None, AssociatedWith=None, Contact=None, PersonnelCount=None, PersonName=None):
        self.original_tagname_ = None
        self.Name = Name
        self.validate_String64(self.Name)
        if Role is None:
            self.Role = []
        else:
            self.Role = Role
        if Alias is None:
            self.Alias = []
        else:
            self.Alias = Alias
        self.Address = Address
        if PhoneNumber is None:
            self.PhoneNumber = []
        else:
            self.PhoneNumber = PhoneNumber
        if Email is None:
            self.Email = []
        else:
            self.Email = Email
        self.AssociatedWith = AssociatedWith
        self.validate_String64(self.AssociatedWith)
        if Contact is None:
            self.Contact = []
        else:
            self.Contact = Contact
        self.PersonnelCount = PersonnelCount
        self.PersonName = PersonName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessAssociate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessAssociate.subclass:
            return BusinessAssociate.subclass(*args_, **kwargs_)
        else:
            return BusinessAssociate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_Role(self): return self.Role
    def set_Role(self, Role): self.Role = Role
    def add_Role(self, value): self.Role.append(value)
    def insert_Role_at(self, index, value): self.Role.insert(index, value)
    def replace_Role_at(self, index, value): self.Role[index] = value
    RoleProp = property(get_Role, set_Role)
    def get_Alias(self): return self.Alias
    def set_Alias(self, Alias): self.Alias = Alias
    def add_Alias(self, value): self.Alias.append(value)
    def insert_Alias_at(self, index, value): self.Alias.insert(index, value)
    def replace_Alias_at(self, index, value): self.Alias[index] = value
    AliasProp = property(get_Alias, set_Alias)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    AddressProp = property(get_Address, set_Address)
    def get_PhoneNumber(self): return self.PhoneNumber
    def set_PhoneNumber(self, PhoneNumber): self.PhoneNumber = PhoneNumber
    def add_PhoneNumber(self, value): self.PhoneNumber.append(value)
    def insert_PhoneNumber_at(self, index, value): self.PhoneNumber.insert(index, value)
    def replace_PhoneNumber_at(self, index, value): self.PhoneNumber[index] = value
    PhoneNumberProp = property(get_PhoneNumber, set_PhoneNumber)
    def get_Email(self): return self.Email
    def set_Email(self, Email): self.Email = Email
    def add_Email(self, value): self.Email.append(value)
    def insert_Email_at(self, index, value): self.Email.insert(index, value)
    def replace_Email_at(self, index, value): self.Email[index] = value
    EmailProp = property(get_Email, set_Email)
    def get_AssociatedWith(self): return self.AssociatedWith
    def set_AssociatedWith(self, AssociatedWith): self.AssociatedWith = AssociatedWith
    AssociatedWithProp = property(get_AssociatedWith, set_AssociatedWith)
    def get_Contact(self): return self.Contact
    def set_Contact(self, Contact): self.Contact = Contact
    def add_Contact(self, value): self.Contact.append(value)
    def insert_Contact_at(self, index, value): self.Contact.insert(index, value)
    def replace_Contact_at(self, index, value): self.Contact[index] = value
    ContactProp = property(get_Contact, set_Contact)
    def get_PersonnelCount(self): return self.PersonnelCount
    def set_PersonnelCount(self, PersonnelCount): self.PersonnelCount = PersonnelCount
    PersonnelCountProp = property(get_PersonnelCount, set_PersonnelCount)
    def get_PersonName(self): return self.PersonName
    def set_PersonName(self, PersonName): self.PersonName = PersonName
    PersonNameProp = property(get_PersonName, set_PersonName)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Role or
            self.Alias or
            self.Address is not None or
            self.PhoneNumber or
            self.Email or
            self.AssociatedWith is not None or
            self.Contact or
            self.PersonnelCount is not None or
            self.PersonName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='BusinessAssociate', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessAssociate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='BusinessAssociate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='BusinessAssociate'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='BusinessAssociate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        for Role_ in self.Role:
            Role_.export(outfile, level, namespace_, name_='Role', pretty_print=pretty_print)
        for Alias_ in self.Alias:
            Alias_.export(outfile, level, namespace_, name_='Alias', pretty_print=pretty_print)
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
        for PhoneNumber_ in self.PhoneNumber:
            PhoneNumber_.export(outfile, level, namespace_, name_='PhoneNumber', pretty_print=pretty_print)
        for Email_ in self.Email:
            Email_.export(outfile, level, namespace_, name_='Email', pretty_print=pretty_print)
        if self.AssociatedWith is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAssociatedWith>%s</%sAssociatedWith>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AssociatedWith), input_name='AssociatedWith')), namespace_, eol_))
        for Contact_ in self.Contact:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContact>%s</%sContact>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(Contact_), input_name='Contact')), namespace_, eol_))
        if self.PersonnelCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPersonnelCount>%s</%sPersonnelCount>%s' % (namespace_, self.gds_format_integer(self.PersonnelCount, input_name='PersonnelCount'), namespace_, eol_))
        if self.PersonName is not None:
            self.PersonName.export(outfile, level, namespace_, name_='PersonName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'Role':
            obj_ = NameStruct.factory()
            obj_.build(child_)
            self.Role.append(obj_)
            obj_.original_tagname_ = 'Role'
        elif nodeName_ == 'Alias':
            obj_ = NameStruct.factory()
            obj_.build(child_)
            self.Alias.append(obj_)
            obj_.original_tagname_ = 'Alias'
        elif nodeName_ == 'Address':
            obj_ = GeneralAddress.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'PhoneNumber':
            obj_ = PhoneNumberStruct.factory()
            obj_.build(child_)
            self.PhoneNumber.append(obj_)
            obj_.original_tagname_ = 'PhoneNumber'
        elif nodeName_ == 'Email':
            obj_ = EmailQualifierStruct.factory()
            obj_.build(child_)
            self.Email.append(obj_)
            obj_.original_tagname_ = 'Email'
        elif nodeName_ == 'AssociatedWith':
            AssociatedWith_ = child_.text
            AssociatedWith_ = self.gds_validate_string(AssociatedWith_, node, 'AssociatedWith')
            self.AssociatedWith = AssociatedWith_
            # validate type String64
            self.validate_String64(self.AssociatedWith)
        elif nodeName_ == 'Contact':
            Contact_ = child_.text
            Contact_ = self.gds_validate_string(Contact_, node, 'Contact')
            self.Contact.append(Contact_)
            # validate type String64
            self.validate_String64(self.Contact[-1])
        elif nodeName_ == 'PersonnelCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'PersonnelCount')
            self.PersonnelCount = ival_
        elif nodeName_ == 'PersonName':
            obj_ = PersonName.factory()
            obj_.build(child_)
            self.PersonName = obj_
            obj_.original_tagname_ = 'PersonName'
# end class BusinessAssociate


class CalibrationParameter(GeneratedsSuper):
    """Parameters are given by name/ value pairs, with optional UOM. The
    parameter name and UOM are attributes, and the value is the
    value of the element.The unit of measure of the parameter
    value.The name of the parameter."""
    subclass = None
    superclass = None
    def __init__(self, uom=None, name=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalibrationParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalibrationParameter.subclass:
            return CalibrationParameter.subclass(*args_, **kwargs_)
        else:
            return CalibrationParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CalibrationParameter', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalibrationParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CalibrationParameter', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CalibrationParameter'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CalibrationParameter', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CalibrationParameter


class DatedComment(GeneratedsSuper):
    """A general time-stamped comment structure.A unique identifier for
    this data element. It is not globally unique (not a uuid) and
    only need be unique within the context of the parent top-level
    object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Who=None, Role=None, StartTime=None, EndTime=None, Remark=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Who = Who
        self.validate_String64(self.Who)
        self.Role = Role
        self.validate_String64(self.Role)
        if isinstance(StartTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(StartTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = StartTime
        self.StartTime = initvalue_
        if isinstance(EndTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EndTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = EndTime
        self.EndTime = initvalue_
        self.Remark = Remark
        self.validate_String2000(self.Remark)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DatedComment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DatedComment.subclass:
            return DatedComment.subclass(*args_, **kwargs_)
        else:
            return DatedComment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Who(self): return self.Who
    def set_Who(self, Who): self.Who = Who
    WhoProp = property(get_Who, set_Who)
    def get_Role(self): return self.Role
    def set_Role(self, Role): self.Role = Role
    RoleProp = property(get_Role, set_Role)
    def get_StartTime(self): return self.StartTime
    def set_StartTime(self, StartTime): self.StartTime = StartTime
    StartTimeProp = property(get_StartTime, set_StartTime)
    def get_EndTime(self): return self.EndTime
    def set_EndTime(self, EndTime): self.EndTime = EndTime
    EndTimeProp = property(get_EndTime, set_EndTime)
    def get_Remark(self): return self.Remark
    def set_Remark(self, Remark): self.Remark = Remark
    RemarkProp = property(get_Remark, set_Remark)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Who is not None or
            self.Role is not None or
            self.StartTime is not None or
            self.EndTime is not None or
            self.Remark is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DatedComment', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatedComment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DatedComment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DatedComment'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DatedComment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Who is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWho>%s</%sWho>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Who), input_name='Who')), namespace_, eol_))
        if self.Role is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRole>%s</%sRole>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Role), input_name='Role')), namespace_, eol_))
        if self.StartTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartTime>%s</%sStartTime>%s' % (namespace_, self.gds_format_datetime(self.StartTime, input_name='StartTime'), namespace_, eol_))
        if self.EndTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndTime>%s</%sEndTime>%s' % (namespace_, self.gds_format_datetime(self.EndTime, input_name='EndTime'), namespace_, eol_))
        if self.Remark is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRemark>%s</%sRemark>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Remark), input_name='Remark')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Who':
            Who_ = child_.text
            Who_ = self.gds_validate_string(Who_, node, 'Who')
            self.Who = Who_
            # validate type String64
            self.validate_String64(self.Who)
        elif nodeName_ == 'Role':
            Role_ = child_.text
            Role_ = self.gds_validate_string(Role_, node, 'Role')
            self.Role = Role_
            # validate type String64
            self.validate_String64(self.Role)
        elif nodeName_ == 'StartTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.StartTime = dval_
        elif nodeName_ == 'EndTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.EndTime = dval_
        elif nodeName_ == 'Remark':
            Remark_ = child_.text
            Remark_ = self.gds_validate_string(Remark_, node, 'Remark')
            self.Remark = Remark_
            # validate type String2000
            self.validate_String2000(self.Remark)
# end class DatedComment


class EmailQualifierStruct(GeneratedsSuper):
    """An email address with an attribute, used to "qualify" an email as
    personal, work, or permanent."""
    subclass = None
    superclass = None
    def __init__(self, qualifier=None):
        self.original_tagname_ = None
        self.qualifier = _cast(None, qualifier)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EmailQualifierStruct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EmailQualifierStruct.subclass:
            return EmailQualifierStruct.subclass(*args_, **kwargs_)
        else:
            return EmailQualifierStruct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    qualifierProp = property(get_qualifier, set_qualifier)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EmailQualifierStruct', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EmailQualifierStruct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EmailQualifierStruct', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EmailQualifierStruct'):
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            outfile.write(' qualifier=%s' % (quote_attrib(self.qualifier), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EmailQualifierStruct', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qualifier', node)
        if value is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            self.qualifier = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EmailQualifierStruct


class EndpointQualifiedDate(GeneratedsSuper):
    """A date value used for min/max query parameters related to "growing
    objects". The meaning of the endpoint of an interval can be
    modified by the endpoint attribute.The default is "inclusive"."""
    subclass = None
    superclass = None
    def __init__(self, endpoint=None):
        self.original_tagname_ = None
        self.endpoint = _cast(None, endpoint)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndpointQualifiedDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndpointQualifiedDate.subclass:
            return EndpointQualifiedDate.subclass(*args_, **kwargs_)
        else:
            return EndpointQualifiedDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_endpoint(self): return self.endpoint
    def set_endpoint(self, endpoint): self.endpoint = endpoint
    endpointProp = property(get_endpoint, set_endpoint)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EndpointQualifiedDate', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndpointQualifiedDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EndpointQualifiedDate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EndpointQualifiedDate'):
        if self.endpoint is not None and 'endpoint' not in already_processed:
            already_processed.add('endpoint')
            outfile.write(' endpoint=%s' % (quote_attrib(self.endpoint), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EndpointQualifiedDate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('endpoint', node)
        if value is not None and 'endpoint' not in already_processed:
            already_processed.add('endpoint')
            self.endpoint = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EndpointQualifiedDate


class EndpointQualifiedDateTime(GeneratedsSuper):
    """A timestamp value used for min/max query parameters related to
    "growing objects". The meaning of the endpoint of an interval
    can be modified by the endpoint attribute.The default is
    "inclusive"."""
    subclass = None
    superclass = None
    def __init__(self, endpoint=None):
        self.original_tagname_ = None
        self.endpoint = _cast(None, endpoint)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndpointQualifiedDateTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndpointQualifiedDateTime.subclass:
            return EndpointQualifiedDateTime.subclass(*args_, **kwargs_)
        else:
            return EndpointQualifiedDateTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_endpoint(self): return self.endpoint
    def set_endpoint(self, endpoint): self.endpoint = endpoint
    endpointProp = property(get_endpoint, set_endpoint)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EndpointQualifiedDateTime', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndpointQualifiedDateTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EndpointQualifiedDateTime', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EndpointQualifiedDateTime'):
        if self.endpoint is not None and 'endpoint' not in already_processed:
            already_processed.add('endpoint')
            outfile.write(' endpoint=%s' % (quote_attrib(self.endpoint), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EndpointQualifiedDateTime', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('endpoint', node)
        if value is not None and 'endpoint' not in already_processed:
            already_processed.add('endpoint')
            self.endpoint = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EndpointQualifiedDateTime


class FacilityIdentifier(GeneratedsSuper):
    """Contains details about the facility being surveyed, such as name,
    geographical data, etc.A unique identifier for this data
    element. It is not globally unique (not a uuid) and only need be
    unique within the context of the parent top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Name=None, Installation=None, Kind=None, ContextFacility=None, BusinessUnit=None, Operator=None, GeographicContext=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Name = Name
        self.Installation = Installation
        self.Kind = Kind
        self.validate_String64(self.Kind)
        self.ContextFacility = ContextFacility
        self.BusinessUnit = BusinessUnit
        self.Operator = Operator
        self.GeographicContext = GeographicContext
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FacilityIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FacilityIdentifier.subclass:
            return FacilityIdentifier.subclass(*args_, **kwargs_)
        else:
            return FacilityIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_Installation(self): return self.Installation
    def set_Installation(self, Installation): self.Installation = Installation
    InstallationProp = property(get_Installation, set_Installation)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    KindProp = property(get_Kind, set_Kind)
    def get_ContextFacility(self): return self.ContextFacility
    def set_ContextFacility(self, ContextFacility): self.ContextFacility = ContextFacility
    ContextFacilityProp = property(get_ContextFacility, set_ContextFacility)
    def get_BusinessUnit(self): return self.BusinessUnit
    def set_BusinessUnit(self, BusinessUnit): self.BusinessUnit = BusinessUnit
    BusinessUnitProp = property(get_BusinessUnit, set_BusinessUnit)
    def get_Operator(self): return self.Operator
    def set_Operator(self, Operator): self.Operator = Operator
    OperatorProp = property(get_Operator, set_Operator)
    def get_GeographicContext(self): return self.GeographicContext
    def set_GeographicContext(self, GeographicContext): self.GeographicContext = GeographicContext
    GeographicContextProp = property(get_GeographicContext, set_GeographicContext)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Installation is not None or
            self.Kind is not None or
            self.ContextFacility is not None or
            self.BusinessUnit is not None or
            self.Operator is not None or
            self.GeographicContext is not None or
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FacilityIdentifier', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FacilityIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FacilityIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FacilityIdentifier'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FacilityIdentifier', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = NameStruct.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'Name', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_Name'):
              self.add_Name(obj_.value)
            elif hasattr(self, 'set_Name'):
              self.set_Name(obj_.value)
        elif nodeName_ == 'Installation':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'Installation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_Installation'):
              self.add_Installation(obj_.value)
            elif hasattr(self, 'set_Installation'):
              self.set_Installation(obj_.value)
        elif nodeName_ == 'Kind' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'Kind', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'ContextFacility':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ContextFacility', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ContextFacility'):
              self.add_ContextFacility(obj_.value)
            elif hasattr(self, 'set_ContextFacility'):
              self.set_ContextFacility(obj_.value)
        elif nodeName_ == 'BusinessUnit':
            obj_ = ProductVolumeBusinessUnit.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'BusinessUnit', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_BusinessUnit'):
              self.add_BusinessUnit(obj_.value)
            elif hasattr(self, 'set_BusinessUnit'):
              self.set_BusinessUnit(obj_.value)
        elif nodeName_ == 'Operator':
            obj_ = BusinessAssociate.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'Operator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_Operator'):
              self.add_Operator(obj_.value)
            elif hasattr(self, 'set_Operator'):
              self.set_Operator(obj_.value)
        elif nodeName_ == 'GeographicContext':
            obj_ = GeographicContext.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'GeographicContext', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_GeographicContext'):
              self.add_GeographicContext(obj_.value)
            elif hasattr(self, 'set_GeographicContext'):
              self.set_GeographicContext(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class FacilityIdentifier


class FacilityIdentifierStruct(GeneratedsSuper):
    """Identifies a facility.The kind of facility.A custom sub-
    categorization of facility kind. This attribute is free-form
    text and allows implementers to provide a more specific or
    specialized description of the facility kind.The naming system
    within which the name is unique. For example, API or NPD.The
    referencing uid."""
    subclass = None
    superclass = None
    def __init__(self, kind=None, siteKind=None, namingSystem=None, uidRef=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.kind = _cast(None, kind)
        self.siteKind = _cast(None, siteKind)
        self.namingSystem = _cast(None, namingSystem)
        self.uidRef = _cast(None, uidRef)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FacilityIdentifierStruct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FacilityIdentifierStruct.subclass:
            return FacilityIdentifierStruct.subclass(*args_, **kwargs_)
        else:
            return FacilityIdentifierStruct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    kindProp = property(get_kind, set_kind)
    def get_siteKind(self): return self.siteKind
    def set_siteKind(self, siteKind): self.siteKind = siteKind
    siteKindProp = property(get_siteKind, set_siteKind)
    def get_namingSystem(self): return self.namingSystem
    def set_namingSystem(self, namingSystem): self.namingSystem = namingSystem
    namingSystemProp = property(get_namingSystem, set_namingSystem)
    def get_uidRef(self): return self.uidRef
    def set_uidRef(self, uidRef): self.uidRef = uidRef
    uidRefProp = property(get_uidRef, set_uidRef)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FacilityIdentifierStruct', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FacilityIdentifierStruct')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FacilityIdentifierStruct'):
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            outfile.write(' kind=%s' % (quote_attrib(self.kind), ))
        if self.siteKind is not None and 'siteKind' not in already_processed:
            already_processed.add('siteKind')
            outfile.write(' siteKind=%s' % (quote_attrib(self.siteKind), ))
        if self.namingSystem is not None and 'namingSystem' not in already_processed:
            already_processed.add('namingSystem')
            outfile.write(' namingSystem=%s' % (quote_attrib(self.namingSystem), ))
        if self.uidRef is not None and 'uidRef' not in already_processed:
            already_processed.add('uidRef')
            outfile.write(' uidRef=%s' % (quote_attrib(self.uidRef), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FacilityIdentifierStruct', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            self.kind = value
        value = find_attr_value_('siteKind', node)
        if value is not None and 'siteKind' not in already_processed:
            already_processed.add('siteKind')
            self.siteKind = value
        value = find_attr_value_('namingSystem', node)
        if value is not None and 'namingSystem' not in already_processed:
            already_processed.add('namingSystem')
            self.namingSystem = value
        value = find_attr_value_('uidRef', node)
        if value is not None and 'uidRef' not in already_processed:
            already_processed.add('uidRef')
            self.uidRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class FacilityIdentifierStruct


class FluidComponent(GeneratedsSuper):
    """Fluid component.Fluid component reference."""
    subclass = None
    superclass = None
    def __init__(self, fluidComponentReference=None, MassFraction=None, MoleFraction=None, KValue=None):
        self.original_tagname_ = None
        self.fluidComponentReference = _cast(None, fluidComponentReference)
        self.MassFraction = MassFraction
        self.MoleFraction = MoleFraction
        self.KValue = KValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FluidComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FluidComponent.subclass:
            return FluidComponent.subclass(*args_, **kwargs_)
        else:
            return FluidComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MassFraction(self): return self.MassFraction
    def set_MassFraction(self, MassFraction): self.MassFraction = MassFraction
    MassFractionProp = property(get_MassFraction, set_MassFraction)
    def get_MoleFraction(self): return self.MoleFraction
    def set_MoleFraction(self, MoleFraction): self.MoleFraction = MoleFraction
    MoleFractionProp = property(get_MoleFraction, set_MoleFraction)
    def get_KValue(self): return self.KValue
    def set_KValue(self, KValue): self.KValue = KValue
    KValueProp = property(get_KValue, set_KValue)
    def get_fluidComponentReference(self): return self.fluidComponentReference
    def set_fluidComponentReference(self, fluidComponentReference): self.fluidComponentReference = fluidComponentReference
    fluidComponentReferenceProp = property(get_fluidComponentReference, set_fluidComponentReference)
    def hasContent_(self):
        if (
            self.MassFraction is not None or
            self.MoleFraction is not None or
            self.KValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FluidComponent', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FluidComponent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FluidComponent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FluidComponent'):
        if self.fluidComponentReference is not None and 'fluidComponentReference' not in already_processed:
            already_processed.add('fluidComponentReference')
            outfile.write(' fluidComponentReference=%s' % (quote_attrib(self.fluidComponentReference), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FluidComponent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MassFraction is not None:
            self.MassFraction.export(outfile, level, namespace_, name_='MassFraction', pretty_print=pretty_print)
        if self.MoleFraction is not None:
            self.MoleFraction.export(outfile, level, namespace_, name_='MoleFraction', pretty_print=pretty_print)
        if self.KValue is not None:
            self.KValue.export(outfile, level, namespace_, name_='KValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fluidComponentReference', node)
        if value is not None and 'fluidComponentReference' not in already_processed:
            already_processed.add('fluidComponentReference')
            self.fluidComponentReference = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MassFraction':
            obj_ = MassPerMassMeasure.factory()
            obj_.build(child_)
            self.MassFraction = obj_
            obj_.original_tagname_ = 'MassFraction'
        elif nodeName_ == 'MoleFraction':
            obj_ = AmountOfSubstancePerAmountOfSubstanceMeasure.factory()
            obj_.build(child_)
            self.MoleFraction = obj_
            obj_.original_tagname_ = 'MoleFraction'
        elif nodeName_ == 'KValue':
            obj_ = AmountOfSubstancePerAmountOfSubstanceMeasure.factory()
            obj_.build(child_)
            self.KValue = obj_
            obj_.original_tagname_ = 'KValue'
# end class FluidComponent


class FluidComponentCatalog(GeneratedsSuper):
    """Fluid component catalog."""
    subclass = None
    superclass = None
    def __init__(self, StockTankOil=None, NaturalGas=None, FormationWater=None, PureFluidComponent=None, PseudoFluidComponent=None, PlusFluidComponent=None):
        self.original_tagname_ = None
        if StockTankOil is None:
            self.StockTankOil = []
        else:
            self.StockTankOil = StockTankOil
        if NaturalGas is None:
            self.NaturalGas = []
        else:
            self.NaturalGas = NaturalGas
        if FormationWater is None:
            self.FormationWater = []
        else:
            self.FormationWater = FormationWater
        if PureFluidComponent is None:
            self.PureFluidComponent = []
        else:
            self.PureFluidComponent = PureFluidComponent
        if PseudoFluidComponent is None:
            self.PseudoFluidComponent = []
        else:
            self.PseudoFluidComponent = PseudoFluidComponent
        if PlusFluidComponent is None:
            self.PlusFluidComponent = []
        else:
            self.PlusFluidComponent = PlusFluidComponent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FluidComponentCatalog)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FluidComponentCatalog.subclass:
            return FluidComponentCatalog.subclass(*args_, **kwargs_)
        else:
            return FluidComponentCatalog(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StockTankOil(self): return self.StockTankOil
    def set_StockTankOil(self, StockTankOil): self.StockTankOil = StockTankOil
    def add_StockTankOil(self, value): self.StockTankOil.append(value)
    def insert_StockTankOil_at(self, index, value): self.StockTankOil.insert(index, value)
    def replace_StockTankOil_at(self, index, value): self.StockTankOil[index] = value
    StockTankOilProp = property(get_StockTankOil, set_StockTankOil)
    def get_NaturalGas(self): return self.NaturalGas
    def set_NaturalGas(self, NaturalGas): self.NaturalGas = NaturalGas
    def add_NaturalGas(self, value): self.NaturalGas.append(value)
    def insert_NaturalGas_at(self, index, value): self.NaturalGas.insert(index, value)
    def replace_NaturalGas_at(self, index, value): self.NaturalGas[index] = value
    NaturalGasProp = property(get_NaturalGas, set_NaturalGas)
    def get_FormationWater(self): return self.FormationWater
    def set_FormationWater(self, FormationWater): self.FormationWater = FormationWater
    def add_FormationWater(self, value): self.FormationWater.append(value)
    def insert_FormationWater_at(self, index, value): self.FormationWater.insert(index, value)
    def replace_FormationWater_at(self, index, value): self.FormationWater[index] = value
    FormationWaterProp = property(get_FormationWater, set_FormationWater)
    def get_PureFluidComponent(self): return self.PureFluidComponent
    def set_PureFluidComponent(self, PureFluidComponent): self.PureFluidComponent = PureFluidComponent
    def add_PureFluidComponent(self, value): self.PureFluidComponent.append(value)
    def insert_PureFluidComponent_at(self, index, value): self.PureFluidComponent.insert(index, value)
    def replace_PureFluidComponent_at(self, index, value): self.PureFluidComponent[index] = value
    PureFluidComponentProp = property(get_PureFluidComponent, set_PureFluidComponent)
    def get_PseudoFluidComponent(self): return self.PseudoFluidComponent
    def set_PseudoFluidComponent(self, PseudoFluidComponent): self.PseudoFluidComponent = PseudoFluidComponent
    def add_PseudoFluidComponent(self, value): self.PseudoFluidComponent.append(value)
    def insert_PseudoFluidComponent_at(self, index, value): self.PseudoFluidComponent.insert(index, value)
    def replace_PseudoFluidComponent_at(self, index, value): self.PseudoFluidComponent[index] = value
    PseudoFluidComponentProp = property(get_PseudoFluidComponent, set_PseudoFluidComponent)
    def get_PlusFluidComponent(self): return self.PlusFluidComponent
    def set_PlusFluidComponent(self, PlusFluidComponent): self.PlusFluidComponent = PlusFluidComponent
    def add_PlusFluidComponent(self, value): self.PlusFluidComponent.append(value)
    def insert_PlusFluidComponent_at(self, index, value): self.PlusFluidComponent.insert(index, value)
    def replace_PlusFluidComponent_at(self, index, value): self.PlusFluidComponent[index] = value
    PlusFluidComponentProp = property(get_PlusFluidComponent, set_PlusFluidComponent)
    def hasContent_(self):
        if (
            self.StockTankOil or
            self.NaturalGas or
            self.FormationWater or
            self.PureFluidComponent or
            self.PseudoFluidComponent or
            self.PlusFluidComponent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FluidComponentCatalog', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FluidComponentCatalog')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FluidComponentCatalog', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FluidComponentCatalog'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FluidComponentCatalog', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for StockTankOil_ in self.StockTankOil:
            StockTankOil_.export(outfile, level, namespace_, name_='StockTankOil', pretty_print=pretty_print)
        for NaturalGas_ in self.NaturalGas:
            NaturalGas_.export(outfile, level, namespace_, name_='NaturalGas', pretty_print=pretty_print)
        for FormationWater_ in self.FormationWater:
            FormationWater_.export(outfile, level, namespace_, name_='FormationWater', pretty_print=pretty_print)
        for PureFluidComponent_ in self.PureFluidComponent:
            PureFluidComponent_.export(outfile, level, namespace_, name_='PureFluidComponent', pretty_print=pretty_print)
        for PseudoFluidComponent_ in self.PseudoFluidComponent:
            PseudoFluidComponent_.export(outfile, level, namespace_, name_='PseudoFluidComponent', pretty_print=pretty_print)
        for PlusFluidComponent_ in self.PlusFluidComponent:
            PlusFluidComponent_.export(outfile, level, namespace_, name_='PlusFluidComponent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StockTankOil':
            obj_ = StockTankOil.factory()
            obj_.build(child_)
            self.StockTankOil.append(obj_)
            obj_.original_tagname_ = 'StockTankOil'
        elif nodeName_ == 'NaturalGas':
            obj_ = NaturalGas.factory()
            obj_.build(child_)
            self.NaturalGas.append(obj_)
            obj_.original_tagname_ = 'NaturalGas'
        elif nodeName_ == 'FormationWater':
            obj_ = FormationWater.factory()
            obj_.build(child_)
            self.FormationWater.append(obj_)
            obj_.original_tagname_ = 'FormationWater'
        elif nodeName_ == 'PureFluidComponent':
            obj_ = PureFluidComponent.factory()
            obj_.build(child_)
            self.PureFluidComponent.append(obj_)
            obj_.original_tagname_ = 'PureFluidComponent'
        elif nodeName_ == 'PseudoFluidComponent':
            obj_ = PseudoFluidComponent.factory()
            obj_.build(child_)
            self.PseudoFluidComponent.append(obj_)
            obj_.original_tagname_ = 'PseudoFluidComponent'
        elif nodeName_ == 'PlusFluidComponent':
            obj_ = PlusFluidComponent.factory()
            obj_.build(child_)
            self.PlusFluidComponent.append(obj_)
            obj_.original_tagname_ = 'PlusFluidComponent'
# end class FluidComponentCatalog


class FormationWater(AbstractFluidComponent):
    """The water in the formation."""
    subclass = None
    superclass = AbstractFluidComponent
    def __init__(self, uid=None, MassFraction=None, MoleFraction=None, SpecificGravity=None, Salinity=None, Remark=None):
        self.original_tagname_ = None
        super(FormationWater, self).__init__(uid, MassFraction, MoleFraction, )
        self.SpecificGravity = SpecificGravity
        self.Salinity = Salinity
        self.Remark = Remark
        self.validate_String2000(self.Remark)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FormationWater)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FormationWater.subclass:
            return FormationWater.subclass(*args_, **kwargs_)
        else:
            return FormationWater(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecificGravity(self): return self.SpecificGravity
    def set_SpecificGravity(self, SpecificGravity): self.SpecificGravity = SpecificGravity
    SpecificGravityProp = property(get_SpecificGravity, set_SpecificGravity)
    def get_Salinity(self): return self.Salinity
    def set_Salinity(self, Salinity): self.Salinity = Salinity
    SalinityProp = property(get_Salinity, set_Salinity)
    def get_Remark(self): return self.Remark
    def set_Remark(self, Remark): self.Remark = Remark
    RemarkProp = property(get_Remark, set_Remark)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.SpecificGravity is not None or
            self.Salinity is not None or
            self.Remark is not None or
            super(FormationWater, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FormationWater', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FormationWater')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FormationWater', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FormationWater'):
        super(FormationWater, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FormationWater')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FormationWater', fromsubclass_=False, pretty_print=True):
        super(FormationWater, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpecificGravity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpecificGravity>%s</%sSpecificGravity>%s' % (namespace_, self.gds_format_double(self.SpecificGravity, input_name='SpecificGravity'), namespace_, eol_))
        if self.Salinity is not None:
            self.Salinity.export(outfile, level, namespace_, name_='Salinity', pretty_print=pretty_print)
        if self.Remark is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRemark>%s</%sRemark>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Remark), input_name='Remark')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FormationWater, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecificGravity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SpecificGravity')
            self.SpecificGravity = fval_
        elif nodeName_ == 'Salinity':
            obj_ = MassPerMassMeasure.factory()
            obj_.build(child_)
            self.Salinity = obj_
            obj_.original_tagname_ = 'Salinity'
        elif nodeName_ == 'Remark':
            Remark_ = child_.text
            Remark_ = self.gds_validate_string(Remark_, node, 'Remark')
            self.Remark = Remark_
            # validate type String2000
            self.validate_String2000(self.Remark)
        super(FormationWater, self).buildChildren(child_, node, nodeName_, True)
# end class FormationWater


class GeneralAddress(GeneratedsSuper):
    """An general address structure. This form is appropriate for most
    countries.A unique identifier for this data element. It is not
    globally unique (not a uuid) and only need be unique within the
    context of the parent top-level object.The type of address:
    mailing, physical, or both. See AddressKindEnum."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, kind=None, Name=None, Street=None, City=None, Country=None, County=None, PostalCode=None, State=None, Province=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.kind = _cast(None, kind)
        self.Name = Name
        self.validate_String64(self.Name)
        if Street is None:
            self.Street = []
        else:
            self.Street = Street
        self.City = City
        self.validate_String64(self.City)
        self.Country = Country
        self.validate_String64(self.Country)
        self.County = County
        self.validate_String64(self.County)
        self.PostalCode = PostalCode
        self.validate_String64(self.PostalCode)
        self.State = State
        self.validate_String64(self.State)
        self.Province = Province
        self.validate_String64(self.Province)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralAddress)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralAddress.subclass:
            return GeneralAddress.subclass(*args_, **kwargs_)
        else:
            return GeneralAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_Street(self): return self.Street
    def set_Street(self, Street): self.Street = Street
    def add_Street(self, value): self.Street.append(value)
    def insert_Street_at(self, index, value): self.Street.insert(index, value)
    def replace_Street_at(self, index, value): self.Street[index] = value
    StreetProp = property(get_Street, set_Street)
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    CityProp = property(get_City, set_City)
    def get_Country(self): return self.Country
    def set_Country(self, Country): self.Country = Country
    CountryProp = property(get_Country, set_Country)
    def get_County(self): return self.County
    def set_County(self, County): self.County = County
    CountyProp = property(get_County, set_County)
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    PostalCodeProp = property(get_PostalCode, set_PostalCode)
    def get_State(self): return self.State
    def set_State(self, State): self.State = State
    StateProp = property(get_State, set_State)
    def get_Province(self): return self.Province
    def set_Province(self, Province): self.Province = Province
    ProvinceProp = property(get_Province, set_Province)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    kindProp = property(get_kind, set_kind)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Street or
            self.City is not None or
            self.Country is not None or
            self.County is not None or
            self.PostalCode is not None or
            self.State is not None or
            self.Province is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeneralAddress', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeneralAddress')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeneralAddress', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeneralAddress'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            outfile.write(' kind=%s' % (quote_attrib(self.kind), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeneralAddress', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        for Street_ in self.Street:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStreet>%s</%sStreet>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(Street_), input_name='Street')), namespace_, eol_))
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCity>%s</%sCity>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), namespace_, eol_))
        if self.Country is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCountry>%s</%sCountry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Country), input_name='Country')), namespace_, eol_))
        if self.County is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCounty>%s</%sCounty>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.County), input_name='County')), namespace_, eol_))
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPostalCode>%s</%sPostalCode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), namespace_, eol_))
        if self.State is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sState>%s</%sState>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.State), input_name='State')), namespace_, eol_))
        if self.Province is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProvince>%s</%sProvince>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Province), input_name='Province')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            self.kind = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'Street':
            Street_ = child_.text
            Street_ = self.gds_validate_string(Street_, node, 'Street')
            self.Street.append(Street_)
            # validate type String64
            self.validate_String64(self.Street[-1])
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
            # validate type String64
            self.validate_String64(self.City)
        elif nodeName_ == 'Country':
            Country_ = child_.text
            Country_ = self.gds_validate_string(Country_, node, 'Country')
            self.Country = Country_
            # validate type String64
            self.validate_String64(self.Country)
        elif nodeName_ == 'County':
            County_ = child_.text
            County_ = self.gds_validate_string(County_, node, 'County')
            self.County = County_
            # validate type String64
            self.validate_String64(self.County)
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
            # validate type String64
            self.validate_String64(self.PostalCode)
        elif nodeName_ == 'State':
            State_ = child_.text
            State_ = self.gds_validate_string(State_, node, 'State')
            self.State = State_
            # validate type String64
            self.validate_String64(self.State)
        elif nodeName_ == 'Province':
            Province_ = child_.text
            Province_ = self.gds_validate_string(Province_, node, 'Province')
            self.Province = Province_
            # validate type String64
            self.validate_String64(self.Province)
# end class GeneralAddress


class GeneralMeasureType(GeneratedsSuper):
    """General measure type. The unit of measure."""
    subclass = None
    superclass = None
    def __init__(self, uom=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralMeasureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralMeasureType.subclass:
            return GeneralMeasureType.subclass(*args_, **kwargs_)
        else:
            return GeneralMeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeneralMeasureType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeneralMeasureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeneralMeasureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeneralMeasureType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeneralMeasureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GeneralMeasureType


class GeographicContext(GeneratedsSuper):
    """A geographic context of a report."""
    subclass = None
    superclass = None
    def __init__(self, Country=None, State=None, County=None, Field=None, Comment=None, OffshoreLocation=None):
        self.original_tagname_ = None
        self.Country = Country
        self.validate_String64(self.Country)
        self.State = State
        self.validate_String64(self.State)
        self.County = County
        self.validate_String64(self.County)
        self.Field = Field
        self.Comment = Comment
        self.validate_String2000(self.Comment)
        self.OffshoreLocation = OffshoreLocation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeographicContext)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeographicContext.subclass:
            return GeographicContext.subclass(*args_, **kwargs_)
        else:
            return GeographicContext(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Country(self): return self.Country
    def set_Country(self, Country): self.Country = Country
    CountryProp = property(get_Country, set_Country)
    def get_State(self): return self.State
    def set_State(self, State): self.State = State
    StateProp = property(get_State, set_State)
    def get_County(self): return self.County
    def set_County(self, County): self.County = County
    CountyProp = property(get_County, set_County)
    def get_Field(self): return self.Field
    def set_Field(self, Field): self.Field = Field
    FieldProp = property(get_Field, set_Field)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_OffshoreLocation(self): return self.OffshoreLocation
    def set_OffshoreLocation(self, OffshoreLocation): self.OffshoreLocation = OffshoreLocation
    OffshoreLocationProp = property(get_OffshoreLocation, set_OffshoreLocation)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Country is not None or
            self.State is not None or
            self.County is not None or
            self.Field is not None or
            self.Comment is not None or
            self.OffshoreLocation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeographicContext', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeographicContext')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeographicContext', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeographicContext'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeographicContext', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Country is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCountry>%s</%sCountry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Country), input_name='Country')), namespace_, eol_))
        if self.State is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sState>%s</%sState>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.State), input_name='State')), namespace_, eol_))
        if self.County is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCounty>%s</%sCounty>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.County), input_name='County')), namespace_, eol_))
        if self.Field is not None:
            self.Field.export(outfile, level, namespace_, name_='Field', pretty_print=pretty_print)
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
        if self.OffshoreLocation is not None:
            self.OffshoreLocation.export(outfile, level, namespace_, name_='OffshoreLocation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Country':
            Country_ = child_.text
            Country_ = self.gds_validate_string(Country_, node, 'Country')
            self.Country = Country_
            # validate type String64
            self.validate_String64(self.Country)
        elif nodeName_ == 'State':
            State_ = child_.text
            State_ = self.gds_validate_string(State_, node, 'State')
            self.State = State_
            # validate type String64
            self.validate_String64(self.State)
        elif nodeName_ == 'County':
            County_ = child_.text
            County_ = self.gds_validate_string(County_, node, 'County')
            self.County = County_
            # validate type String64
            self.validate_String64(self.County)
        elif nodeName_ == 'Field':
            obj_ = NameStruct.factory()
            obj_.build(child_)
            self.Field = obj_
            obj_.original_tagname_ = 'Field'
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        elif nodeName_ == 'OffshoreLocation':
            obj_ = OffshoreLocation.factory()
            obj_.build(child_)
            self.OffshoreLocation = obj_
            obj_.original_tagname_ = 'OffshoreLocation'
# end class GeographicContext


class GeologyFeature(GeneratedsSuper):
    """Geology features found in the location of the borehole string.A
    unique identifier for this data element. It is not globally
    unique (not a uuid) and only need be unique within the context
    of the parent top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Name=None, GeologyType=None, MdTop=None, MdBottom=None, TvdTop=None, TvdBottom=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Name = Name
        self.validate_String64(self.Name)
        self.GeologyType = GeologyType
        self.validate_GeologyType(self.GeologyType)
        self.MdTop = MdTop
        self.MdBottom = MdBottom
        self.TvdTop = TvdTop
        self.TvdBottom = TvdBottom
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeologyFeature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeologyFeature.subclass:
            return GeologyFeature.subclass(*args_, **kwargs_)
        else:
            return GeologyFeature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_GeologyType(self): return self.GeologyType
    def set_GeologyType(self, GeologyType): self.GeologyType = GeologyType
    GeologyTypeProp = property(get_GeologyType, set_GeologyType)
    def get_MdTop(self): return self.MdTop
    def set_MdTop(self, MdTop): self.MdTop = MdTop
    MdTopProp = property(get_MdTop, set_MdTop)
    def get_MdBottom(self): return self.MdBottom
    def set_MdBottom(self, MdBottom): self.MdBottom = MdBottom
    MdBottomProp = property(get_MdBottom, set_MdBottom)
    def get_TvdTop(self): return self.TvdTop
    def set_TvdTop(self, TvdTop): self.TvdTop = TvdTop
    TvdTopProp = property(get_TvdTop, set_TvdTop)
    def get_TvdBottom(self): return self.TvdBottom
    def set_TvdBottom(self, TvdBottom): self.TvdBottom = TvdBottom
    TvdBottomProp = property(get_TvdBottom, set_TvdBottom)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_GeologyType(self, value):
        # Validate type GeologyType, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['aquifer', 'reservoir']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on GeologyType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.GeologyType is not None or
            self.MdTop is not None or
            self.MdBottom is not None or
            self.TvdTop is not None or
            self.TvdBottom is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeologyFeature', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeologyFeature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeologyFeature', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeologyFeature'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeologyFeature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.GeologyType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGeologyType>%s</%sGeologyType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.GeologyType), input_name='GeologyType')), namespace_, eol_))
        if self.MdTop is not None:
            self.MdTop.export(outfile, level, namespace_, name_='MdTop', pretty_print=pretty_print)
        if self.MdBottom is not None:
            self.MdBottom.export(outfile, level, namespace_, name_='MdBottom', pretty_print=pretty_print)
        if self.TvdTop is not None:
            self.TvdTop.export(outfile, level, namespace_, name_='TvdTop', pretty_print=pretty_print)
        if self.TvdBottom is not None:
            self.TvdBottom.export(outfile, level, namespace_, name_='TvdBottom', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'GeologyType':
            GeologyType_ = child_.text
            GeologyType_ = self.gds_validate_string(GeologyType_, node, 'GeologyType')
            self.GeologyType = GeologyType_
            # validate type GeologyType
            self.validate_GeologyType(self.GeologyType)
        elif nodeName_ == 'MdTop':
            obj_ = MeasuredDepthCoord.factory()
            obj_.build(child_)
            self.MdTop = obj_
            obj_.original_tagname_ = 'MdTop'
        elif nodeName_ == 'MdBottom':
            obj_ = MeasuredDepthCoord.factory()
            obj_.build(child_)
            self.MdBottom = obj_
            obj_.original_tagname_ = 'MdBottom'
        elif nodeName_ == 'TvdTop':
            obj_ = WellVerticalDepthCoord.factory()
            obj_.build(child_)
            self.TvdTop = obj_
            obj_.original_tagname_ = 'TvdTop'
        elif nodeName_ == 'TvdBottom':
            obj_ = WellVerticalDepthCoord.factory()
            obj_.build(child_)
            self.TvdBottom = obj_
            obj_.original_tagname_ = 'TvdBottom'
# end class GeologyFeature


class IndexedObject(GeneratedsSuper):
    """Indexed object.Index.Name.Unit of measure.Description."""
    subclass = None
    superclass = None
    def __init__(self, index=None, name=None, uom=None, description=None):
        self.original_tagname_ = None
        self.index = _cast(None, index)
        self.name = _cast(None, name)
        self.uom = _cast(None, uom)
        self.description = _cast(None, description)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndexedObject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndexedObject.subclass:
            return IndexedObject.subclass(*args_, **kwargs_)
        else:
            return IndexedObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_index(self): return self.index
    def set_index(self, index): self.index = index
    indexProp = property(get_index, set_index)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='IndexedObject', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndexedObject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='IndexedObject', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='IndexedObject'):
        if self.index is not None and 'index' not in already_processed:
            already_processed.add('index')
            outfile.write(' index=%s' % (quote_attrib(self.index), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='IndexedObject', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.add('index')
            self.index = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IndexedObject


class KeywordValueStruct(GeneratedsSuper):
    """A value for the specified keyword. That is, a keyword-value pair.
    The allowed length of the value is constrained by the
    keyword.The keyword within which the value is unique. The
    concept of a keyword is very close to the concept of a
    classification system."""
    subclass = None
    superclass = None
    def __init__(self, keyword=None, valueOf_=None):
        self.original_tagname_ = None
        self.keyword = _cast(None, keyword)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeywordValueStruct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeywordValueStruct.subclass:
            return KeywordValueStruct.subclass(*args_, **kwargs_)
        else:
            return KeywordValueStruct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_keyword(self): return self.keyword
    def set_keyword(self, keyword): self.keyword = keyword
    keywordProp = property(get_keyword, set_keyword)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='KeywordValueStruct', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeywordValueStruct')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='KeywordValueStruct', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='KeywordValueStruct'):
        if self.keyword is not None and 'keyword' not in already_processed:
            already_processed.add('keyword')
            outfile.write(' keyword=%s' % (quote_attrib(self.keyword), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='KeywordValueStruct', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('keyword', node)
        if value is not None and 'keyword' not in already_processed:
            already_processed.add('keyword')
            self.keyword = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class KeywordValueStruct


class LiquidComposition(GeneratedsSuper):
    """The composition of liquid"""
    subclass = None
    superclass = None
    def __init__(self, Remark=None, LiquidComponent=None):
        self.original_tagname_ = None
        self.Remark = Remark
        self.validate_String2000(self.Remark)
        if LiquidComponent is None:
            self.LiquidComponent = []
        else:
            self.LiquidComponent = LiquidComponent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LiquidComposition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LiquidComposition.subclass:
            return LiquidComposition.subclass(*args_, **kwargs_)
        else:
            return LiquidComposition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Remark(self): return self.Remark
    def set_Remark(self, Remark): self.Remark = Remark
    RemarkProp = property(get_Remark, set_Remark)
    def get_LiquidComponent(self): return self.LiquidComponent
    def set_LiquidComponent(self, LiquidComponent): self.LiquidComponent = LiquidComponent
    def add_LiquidComponent(self, value): self.LiquidComponent.append(value)
    def insert_LiquidComponent_at(self, index, value): self.LiquidComponent.insert(index, value)
    def replace_LiquidComponent_at(self, index, value): self.LiquidComponent[index] = value
    LiquidComponentProp = property(get_LiquidComponent, set_LiquidComponent)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Remark is not None or
            self.LiquidComponent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LiquidComposition', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LiquidComposition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LiquidComposition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LiquidComposition'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LiquidComposition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Remark is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRemark>%s</%sRemark>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Remark), input_name='Remark')), namespace_, eol_))
        for LiquidComponent_ in self.LiquidComponent:
            LiquidComponent_.export(outfile, level, namespace_, name_='LiquidComponent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Remark':
            Remark_ = child_.text
            Remark_ = self.gds_validate_string(Remark_, node, 'Remark')
            self.Remark = Remark_
            # validate type String2000
            self.validate_String2000(self.Remark)
        elif nodeName_ == 'LiquidComponent':
            obj_ = FluidComponent.factory()
            obj_.build(child_)
            self.LiquidComponent.append(obj_)
            obj_.original_tagname_ = 'LiquidComponent'
# end class LiquidComposition


class MeasuredDepthCoord(GeneratedsSuper):
    """A measured depth coordinate in a wellbore. Positive moving from the
    reference datum toward the bottomhole. All coordinates with the
    same datum (and same UOM) can be considered to be in the same
    coordinate reference system (CRS) and are thus directly
    comparable.The unit of measure of the measured depth coordinate."""
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasuredDepthCoord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasuredDepthCoord.subclass:
            return MeasuredDepthCoord.subclass(*args_, **kwargs_)
        else:
            return MeasuredDepthCoord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MeasuredDepthCoord', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasuredDepthCoord')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MeasuredDepthCoord', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MeasuredDepthCoord'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MeasuredDepthCoord', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MeasuredDepthCoord


class MeasureOrQuantity(GeneratedsSuper):
    """A measure with a UOM or a quantity (without a UOM). Use this only
    where the underlying class of data is captured elsewhere. For
    example, using a measure class.The unit of measure for the
    quantity. This value must conform to the values allowed by a
    measure class. If the value is a measure, then the UOM must be
    specified."""
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureOrQuantity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureOrQuantity.subclass:
            return MeasureOrQuantity.subclass(*args_, **kwargs_)
        else:
            return MeasureOrQuantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MeasureOrQuantity', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasureOrQuantity')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MeasureOrQuantity', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MeasureOrQuantity'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MeasureOrQuantity', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MeasureOrQuantity


class NameStruct(GeneratedsSuper):
    """The name of something within a naming system.The authority for the
    naming system, e.g., a company."""
    subclass = None
    superclass = None
    def __init__(self, authority=None, valueOf_=None):
        self.original_tagname_ = None
        self.authority = _cast(None, authority)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameStruct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameStruct.subclass:
            return NameStruct.subclass(*args_, **kwargs_)
        else:
            return NameStruct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_authority(self): return self.authority
    def set_authority(self, authority): self.authority = authority
    authorityProp = property(get_authority, set_authority)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='NameStruct', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameStruct')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='NameStruct', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='NameStruct'):
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (quote_attrib(self.authority), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='NameStruct', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameStruct


class NaturalGas(AbstractFluidComponent):
    """Natural gas."""
    subclass = None
    superclass = AbstractFluidComponent
    def __init__(self, uid=None, MassFraction=None, MoleFraction=None, GasGravity=None, MolecularWeight=None, GrossEnergyContentPerUnitMass=None, NetEnergyContentPerUnitMass=None, GrossEnergyContentPerUnitVolume=None, NetEnergyContentPerUnitVolume=None, Remark=None):
        self.original_tagname_ = None
        super(NaturalGas, self).__init__(uid, MassFraction, MoleFraction, )
        self.GasGravity = GasGravity
        self.MolecularWeight = MolecularWeight
        self.GrossEnergyContentPerUnitMass = GrossEnergyContentPerUnitMass
        self.NetEnergyContentPerUnitMass = NetEnergyContentPerUnitMass
        self.GrossEnergyContentPerUnitVolume = GrossEnergyContentPerUnitVolume
        self.NetEnergyContentPerUnitVolume = NetEnergyContentPerUnitVolume
        self.Remark = Remark
        self.validate_String2000(self.Remark)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NaturalGas)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NaturalGas.subclass:
            return NaturalGas.subclass(*args_, **kwargs_)
        else:
            return NaturalGas(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GasGravity(self): return self.GasGravity
    def set_GasGravity(self, GasGravity): self.GasGravity = GasGravity
    GasGravityProp = property(get_GasGravity, set_GasGravity)
    def get_MolecularWeight(self): return self.MolecularWeight
    def set_MolecularWeight(self, MolecularWeight): self.MolecularWeight = MolecularWeight
    MolecularWeightProp = property(get_MolecularWeight, set_MolecularWeight)
    def get_GrossEnergyContentPerUnitMass(self): return self.GrossEnergyContentPerUnitMass
    def set_GrossEnergyContentPerUnitMass(self, GrossEnergyContentPerUnitMass): self.GrossEnergyContentPerUnitMass = GrossEnergyContentPerUnitMass
    GrossEnergyContentPerUnitMassProp = property(get_GrossEnergyContentPerUnitMass, set_GrossEnergyContentPerUnitMass)
    def get_NetEnergyContentPerUnitMass(self): return self.NetEnergyContentPerUnitMass
    def set_NetEnergyContentPerUnitMass(self, NetEnergyContentPerUnitMass): self.NetEnergyContentPerUnitMass = NetEnergyContentPerUnitMass
    NetEnergyContentPerUnitMassProp = property(get_NetEnergyContentPerUnitMass, set_NetEnergyContentPerUnitMass)
    def get_GrossEnergyContentPerUnitVolume(self): return self.GrossEnergyContentPerUnitVolume
    def set_GrossEnergyContentPerUnitVolume(self, GrossEnergyContentPerUnitVolume): self.GrossEnergyContentPerUnitVolume = GrossEnergyContentPerUnitVolume
    GrossEnergyContentPerUnitVolumeProp = property(get_GrossEnergyContentPerUnitVolume, set_GrossEnergyContentPerUnitVolume)
    def get_NetEnergyContentPerUnitVolume(self): return self.NetEnergyContentPerUnitVolume
    def set_NetEnergyContentPerUnitVolume(self, NetEnergyContentPerUnitVolume): self.NetEnergyContentPerUnitVolume = NetEnergyContentPerUnitVolume
    NetEnergyContentPerUnitVolumeProp = property(get_NetEnergyContentPerUnitVolume, set_NetEnergyContentPerUnitVolume)
    def get_Remark(self): return self.Remark
    def set_Remark(self, Remark): self.Remark = Remark
    RemarkProp = property(get_Remark, set_Remark)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.GasGravity is not None or
            self.MolecularWeight is not None or
            self.GrossEnergyContentPerUnitMass is not None or
            self.NetEnergyContentPerUnitMass is not None or
            self.GrossEnergyContentPerUnitVolume is not None or
            self.NetEnergyContentPerUnitVolume is not None or
            self.Remark is not None or
            super(NaturalGas, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='NaturalGas', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NaturalGas')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='NaturalGas', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='NaturalGas'):
        super(NaturalGas, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NaturalGas')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='NaturalGas', fromsubclass_=False, pretty_print=True):
        super(NaturalGas, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GasGravity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGasGravity>%s</%sGasGravity>%s' % (namespace_, self.gds_format_double(self.GasGravity, input_name='GasGravity'), namespace_, eol_))
        if self.MolecularWeight is not None:
            self.MolecularWeight.export(outfile, level, namespace_, name_='MolecularWeight', pretty_print=pretty_print)
        if self.GrossEnergyContentPerUnitMass is not None:
            self.GrossEnergyContentPerUnitMass.export(outfile, level, namespace_, name_='GrossEnergyContentPerUnitMass', pretty_print=pretty_print)
        if self.NetEnergyContentPerUnitMass is not None:
            self.NetEnergyContentPerUnitMass.export(outfile, level, namespace_, name_='NetEnergyContentPerUnitMass', pretty_print=pretty_print)
        if self.GrossEnergyContentPerUnitVolume is not None:
            self.GrossEnergyContentPerUnitVolume.export(outfile, level, namespace_, name_='GrossEnergyContentPerUnitVolume', pretty_print=pretty_print)
        if self.NetEnergyContentPerUnitVolume is not None:
            self.NetEnergyContentPerUnitVolume.export(outfile, level, namespace_, name_='NetEnergyContentPerUnitVolume', pretty_print=pretty_print)
        if self.Remark is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRemark>%s</%sRemark>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Remark), input_name='Remark')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NaturalGas, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GasGravity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'GasGravity')
            self.GasGravity = fval_
        elif nodeName_ == 'MolecularWeight':
            obj_ = MolecularWeightMeasure.factory()
            obj_.build(child_)
            self.MolecularWeight = obj_
            obj_.original_tagname_ = 'MolecularWeight'
        elif nodeName_ == 'GrossEnergyContentPerUnitMass':
            obj_ = EnergyPerMassMeasure.factory()
            obj_.build(child_)
            self.GrossEnergyContentPerUnitMass = obj_
            obj_.original_tagname_ = 'GrossEnergyContentPerUnitMass'
        elif nodeName_ == 'NetEnergyContentPerUnitMass':
            obj_ = EnergyPerMassMeasure.factory()
            obj_.build(child_)
            self.NetEnergyContentPerUnitMass = obj_
            obj_.original_tagname_ = 'NetEnergyContentPerUnitMass'
        elif nodeName_ == 'GrossEnergyContentPerUnitVolume':
            obj_ = EnergyPerVolumeMeasure.factory()
            obj_.build(child_)
            self.GrossEnergyContentPerUnitVolume = obj_
            obj_.original_tagname_ = 'GrossEnergyContentPerUnitVolume'
        elif nodeName_ == 'NetEnergyContentPerUnitVolume':
            obj_ = EnergyPerVolumeMeasure.factory()
            obj_.build(child_)
            self.NetEnergyContentPerUnitVolume = obj_
            obj_.original_tagname_ = 'NetEnergyContentPerUnitVolume'
        elif nodeName_ == 'Remark':
            Remark_ = child_.text
            Remark_ = self.gds_validate_string(Remark_, node, 'Remark')
            self.Remark = Remark_
            # validate type String2000
            self.validate_String2000(self.Remark)
        super(NaturalGas, self).buildChildren(child_, node, nodeName_, True)
# end class NaturalGas


class NorthSeaOffshore(GeneratedsSuper):
    """A type of offshore location that captures the North Sea offshore
    terminology."""
    subclass = None
    superclass = None
    def __init__(self, AreaName=None, Quadrant=None, BlockSuffix=None):
        self.original_tagname_ = None
        self.AreaName = AreaName
        self.validate_String64(self.AreaName)
        self.Quadrant = Quadrant
        self.validate_String64(self.Quadrant)
        self.BlockSuffix = BlockSuffix
        self.validate_String64(self.BlockSuffix)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NorthSeaOffshore)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NorthSeaOffshore.subclass:
            return NorthSeaOffshore.subclass(*args_, **kwargs_)
        else:
            return NorthSeaOffshore(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AreaName(self): return self.AreaName
    def set_AreaName(self, AreaName): self.AreaName = AreaName
    AreaNameProp = property(get_AreaName, set_AreaName)
    def get_Quadrant(self): return self.Quadrant
    def set_Quadrant(self, Quadrant): self.Quadrant = Quadrant
    QuadrantProp = property(get_Quadrant, set_Quadrant)
    def get_BlockSuffix(self): return self.BlockSuffix
    def set_BlockSuffix(self, BlockSuffix): self.BlockSuffix = BlockSuffix
    BlockSuffixProp = property(get_BlockSuffix, set_BlockSuffix)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.AreaName is not None or
            self.Quadrant is not None or
            self.BlockSuffix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='NorthSeaOffshore', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NorthSeaOffshore')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='NorthSeaOffshore', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='NorthSeaOffshore'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='NorthSeaOffshore', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AreaName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAreaName>%s</%sAreaName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AreaName), input_name='AreaName')), namespace_, eol_))
        if self.Quadrant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQuadrant>%s</%sQuadrant>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Quadrant), input_name='Quadrant')), namespace_, eol_))
        if self.BlockSuffix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBlockSuffix>%s</%sBlockSuffix>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BlockSuffix), input_name='BlockSuffix')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AreaName':
            AreaName_ = child_.text
            AreaName_ = self.gds_validate_string(AreaName_, node, 'AreaName')
            self.AreaName = AreaName_
            # validate type String64
            self.validate_String64(self.AreaName)
        elif nodeName_ == 'Quadrant':
            Quadrant_ = child_.text
            Quadrant_ = self.gds_validate_string(Quadrant_, node, 'Quadrant')
            self.Quadrant = Quadrant_
            # validate type String64
            self.validate_String64(self.Quadrant)
        elif nodeName_ == 'BlockSuffix':
            BlockSuffix_ = child_.text
            BlockSuffix_ = self.gds_validate_string(BlockSuffix_, node, 'BlockSuffix')
            self.BlockSuffix = BlockSuffix_
            # validate type String64
            self.validate_String64(self.BlockSuffix)
# end class NorthSeaOffshore


class OffshoreLocation(GeneratedsSuper):
    """A generic type of offshore location. This allows an offshore
    location to be given by an area name, and up to four block
    names. A comment is also allowed."""
    subclass = None
    superclass = None
    def __init__(self, AreaName=None, BlockID=None, Comment=None, NorthSeaOffshore=None):
        self.original_tagname_ = None
        self.AreaName = AreaName
        self.validate_String64(self.AreaName)
        if BlockID is None:
            self.BlockID = []
        else:
            self.BlockID = BlockID
        self.Comment = Comment
        self.validate_String2000(self.Comment)
        self.NorthSeaOffshore = NorthSeaOffshore
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OffshoreLocation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OffshoreLocation.subclass:
            return OffshoreLocation.subclass(*args_, **kwargs_)
        else:
            return OffshoreLocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AreaName(self): return self.AreaName
    def set_AreaName(self, AreaName): self.AreaName = AreaName
    AreaNameProp = property(get_AreaName, set_AreaName)
    def get_BlockID(self): return self.BlockID
    def set_BlockID(self, BlockID): self.BlockID = BlockID
    def add_BlockID(self, value): self.BlockID.append(value)
    def insert_BlockID_at(self, index, value): self.BlockID.insert(index, value)
    def replace_BlockID_at(self, index, value): self.BlockID[index] = value
    BlockIDProp = property(get_BlockID, set_BlockID)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_NorthSeaOffshore(self): return self.NorthSeaOffshore
    def set_NorthSeaOffshore(self, NorthSeaOffshore): self.NorthSeaOffshore = NorthSeaOffshore
    NorthSeaOffshoreProp = property(get_NorthSeaOffshore, set_NorthSeaOffshore)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.AreaName is not None or
            self.BlockID or
            self.Comment is not None or
            self.NorthSeaOffshore is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='OffshoreLocation', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OffshoreLocation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='OffshoreLocation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='OffshoreLocation'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='OffshoreLocation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AreaName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAreaName>%s</%sAreaName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AreaName), input_name='AreaName')), namespace_, eol_))
        for BlockID_ in self.BlockID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBlockID>%s</%sBlockID>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(BlockID_), input_name='BlockID')), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
        if self.NorthSeaOffshore is not None:
            self.NorthSeaOffshore.export(outfile, level, namespace_, name_='NorthSeaOffshore', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AreaName':
            AreaName_ = child_.text
            AreaName_ = self.gds_validate_string(AreaName_, node, 'AreaName')
            self.AreaName = AreaName_
            # validate type String64
            self.validate_String64(self.AreaName)
        elif nodeName_ == 'BlockID':
            BlockID_ = child_.text
            BlockID_ = self.gds_validate_string(BlockID_, node, 'BlockID')
            self.BlockID.append(BlockID_)
            # validate type String64
            self.validate_String64(self.BlockID[-1])
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        elif nodeName_ == 'NorthSeaOffshore':
            obj_ = NorthSeaOffshore.factory()
            obj_.build(child_)
            self.NorthSeaOffshore = obj_
            obj_.original_tagname_ = 'NorthSeaOffshore'
# end class OffshoreLocation


class OverallComposition(GeneratedsSuper):
    """Overall composition."""
    subclass = None
    superclass = None
    def __init__(self, Remark=None, FluidComponent=None):
        self.original_tagname_ = None
        self.Remark = Remark
        self.validate_String2000(self.Remark)
        if FluidComponent is None:
            self.FluidComponent = []
        else:
            self.FluidComponent = FluidComponent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OverallComposition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OverallComposition.subclass:
            return OverallComposition.subclass(*args_, **kwargs_)
        else:
            return OverallComposition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Remark(self): return self.Remark
    def set_Remark(self, Remark): self.Remark = Remark
    RemarkProp = property(get_Remark, set_Remark)
    def get_FluidComponent(self): return self.FluidComponent
    def set_FluidComponent(self, FluidComponent): self.FluidComponent = FluidComponent
    def add_FluidComponent(self, value): self.FluidComponent.append(value)
    def insert_FluidComponent_at(self, index, value): self.FluidComponent.insert(index, value)
    def replace_FluidComponent_at(self, index, value): self.FluidComponent[index] = value
    FluidComponentProp = property(get_FluidComponent, set_FluidComponent)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Remark is not None or
            self.FluidComponent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='OverallComposition', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OverallComposition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='OverallComposition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='OverallComposition'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='OverallComposition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Remark is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRemark>%s</%sRemark>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Remark), input_name='Remark')), namespace_, eol_))
        for FluidComponent_ in self.FluidComponent:
            FluidComponent_.export(outfile, level, namespace_, name_='FluidComponent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Remark':
            Remark_ = child_.text
            Remark_ = self.gds_validate_string(Remark_, node, 'Remark')
            self.Remark = Remark_
            # validate type String2000
            self.validate_String2000(self.Remark)
        elif nodeName_ == 'FluidComponent':
            obj_ = FluidComponent.factory()
            obj_.build(child_)
            self.FluidComponent.append(obj_)
            obj_.original_tagname_ = 'FluidComponent'
# end class OverallComposition


class PersonName(GeneratedsSuper):
    """The components of a person's name."""
    subclass = None
    superclass = None
    def __init__(self, Prefix=None, First=None, Middle=None, Last=None, Suffix=None):
        self.original_tagname_ = None
        self.Prefix = Prefix
        self.validate_String64(self.Prefix)
        self.First = First
        self.validate_String64(self.First)
        self.Middle = Middle
        self.validate_String64(self.Middle)
        self.Last = Last
        self.validate_String64(self.Last)
        if Suffix is None:
            self.Suffix = []
        else:
            self.Suffix = Suffix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonName.subclass:
            return PersonName.subclass(*args_, **kwargs_)
        else:
            return PersonName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Prefix(self): return self.Prefix
    def set_Prefix(self, Prefix): self.Prefix = Prefix
    PrefixProp = property(get_Prefix, set_Prefix)
    def get_First(self): return self.First
    def set_First(self, First): self.First = First
    FirstProp = property(get_First, set_First)
    def get_Middle(self): return self.Middle
    def set_Middle(self, Middle): self.Middle = Middle
    MiddleProp = property(get_Middle, set_Middle)
    def get_Last(self): return self.Last
    def set_Last(self, Last): self.Last = Last
    LastProp = property(get_Last, set_Last)
    def get_Suffix(self): return self.Suffix
    def set_Suffix(self, Suffix): self.Suffix = Suffix
    def add_Suffix(self, value): self.Suffix.append(value)
    def insert_Suffix_at(self, index, value): self.Suffix.insert(index, value)
    def replace_Suffix_at(self, index, value): self.Suffix[index] = value
    SuffixProp = property(get_Suffix, set_Suffix)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Prefix is not None or
            self.First is not None or
            self.Middle is not None or
            self.Last is not None or
            self.Suffix
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PersonName', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonName')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PersonName', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PersonName'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PersonName', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Prefix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrefix>%s</%sPrefix>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Prefix), input_name='Prefix')), namespace_, eol_))
        if self.First is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFirst>%s</%sFirst>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.First), input_name='First')), namespace_, eol_))
        if self.Middle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMiddle>%s</%sMiddle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Middle), input_name='Middle')), namespace_, eol_))
        if self.Last is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLast>%s</%sLast>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Last), input_name='Last')), namespace_, eol_))
        for Suffix_ in self.Suffix:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSuffix>%s</%sSuffix>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(Suffix_), input_name='Suffix')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Prefix':
            Prefix_ = child_.text
            Prefix_ = self.gds_validate_string(Prefix_, node, 'Prefix')
            self.Prefix = Prefix_
            # validate type String64
            self.validate_String64(self.Prefix)
        elif nodeName_ == 'First':
            First_ = child_.text
            First_ = self.gds_validate_string(First_, node, 'First')
            self.First = First_
            # validate type String64
            self.validate_String64(self.First)
        elif nodeName_ == 'Middle':
            Middle_ = child_.text
            Middle_ = self.gds_validate_string(Middle_, node, 'Middle')
            self.Middle = Middle_
            # validate type String64
            self.validate_String64(self.Middle)
        elif nodeName_ == 'Last':
            Last_ = child_.text
            Last_ = self.gds_validate_string(Last_, node, 'Last')
            self.Last = Last_
            # validate type String64
            self.validate_String64(self.Last)
        elif nodeName_ == 'Suffix':
            Suffix_ = child_.text
            Suffix_ = self.gds_validate_string(Suffix_, node, 'Suffix')
            self.Suffix.append(Suffix_)
            # validate type String64
            self.validate_String64(self.Suffix[-1])
# end class PersonName


class PhoneNumberStruct(GeneratedsSuper):
    """A phone number with two attributes, used to "type" and "qualify" a
    phone number. The type would carry information such as fax,
    modem, voice, and the qualifier would carry information such as
    home or office.The kind of phone such as voice or fax.Indicates
    whether the number is personal, business or both.The phone
    number extension."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, qualifier=None, extension=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.qualifier = _cast(None, qualifier)
        self.extension = _cast(None, extension)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhoneNumberStruct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhoneNumberStruct.subclass:
            return PhoneNumberStruct.subclass(*args_, **kwargs_)
        else:
            return PhoneNumberStruct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    qualifierProp = property(get_qualifier, set_qualifier)
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    extensionProp = property(get_extension, set_extension)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PhoneNumberStruct', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhoneNumberStruct')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PhoneNumberStruct'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            outfile.write(' qualifier=%s' % (quote_attrib(self.qualifier), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (quote_attrib(self.extension), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PhoneNumberStruct', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('qualifier', node)
        if value is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            self.qualifier = value
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class PhoneNumberStruct


class PlusFluidComponent(AbstractFluidComponent):
    """Plus fluid component."""
    subclass = None
    superclass = AbstractFluidComponent
    def __init__(self, uid=None, MassFraction=None, MoleFraction=None, Kind=None, SpecificGravity=None, StartingCarbonNumber=None, StartingBoilingPoint=None, AvgDensity=None, AvgMolecularWeight=None, Remark=None):
        self.original_tagname_ = None
        super(PlusFluidComponent, self).__init__(uid, MassFraction, MoleFraction, )
        self.Kind = Kind
        self.validate_PlusComponentEnumExt(self.Kind)
        self.SpecificGravity = SpecificGravity
        self.StartingCarbonNumber = StartingCarbonNumber
        self.validate_NonNegativeLong(self.StartingCarbonNumber)
        self.StartingBoilingPoint = StartingBoilingPoint
        self.AvgDensity = AvgDensity
        self.AvgMolecularWeight = AvgMolecularWeight
        self.Remark = Remark
        self.validate_String2000(self.Remark)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlusFluidComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlusFluidComponent.subclass:
            return PlusFluidComponent.subclass(*args_, **kwargs_)
        else:
            return PlusFluidComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    KindProp = property(get_Kind, set_Kind)
    def get_SpecificGravity(self): return self.SpecificGravity
    def set_SpecificGravity(self, SpecificGravity): self.SpecificGravity = SpecificGravity
    SpecificGravityProp = property(get_SpecificGravity, set_SpecificGravity)
    def get_StartingCarbonNumber(self): return self.StartingCarbonNumber
    def set_StartingCarbonNumber(self, StartingCarbonNumber): self.StartingCarbonNumber = StartingCarbonNumber
    StartingCarbonNumberProp = property(get_StartingCarbonNumber, set_StartingCarbonNumber)
    def get_StartingBoilingPoint(self): return self.StartingBoilingPoint
    def set_StartingBoilingPoint(self, StartingBoilingPoint): self.StartingBoilingPoint = StartingBoilingPoint
    StartingBoilingPointProp = property(get_StartingBoilingPoint, set_StartingBoilingPoint)
    def get_AvgDensity(self): return self.AvgDensity
    def set_AvgDensity(self, AvgDensity): self.AvgDensity = AvgDensity
    AvgDensityProp = property(get_AvgDensity, set_AvgDensity)
    def get_AvgMolecularWeight(self): return self.AvgMolecularWeight
    def set_AvgMolecularWeight(self, AvgMolecularWeight): self.AvgMolecularWeight = AvgMolecularWeight
    AvgMolecularWeightProp = property(get_AvgMolecularWeight, set_AvgMolecularWeight)
    def get_Remark(self): return self.Remark
    def set_Remark(self, Remark): self.Remark = Remark
    RemarkProp = property(get_Remark, set_Remark)
    def validate_PlusComponentEnumExt(self, value):
        # Validate type PlusComponentEnumExt, a restriction on None.
        pass
    def validate_NonNegativeLong(self, value):
        # Validate type NonNegativeLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeLong' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Kind is not None or
            self.SpecificGravity is not None or
            self.StartingCarbonNumber is not None or
            self.StartingBoilingPoint is not None or
            self.AvgDensity is not None or
            self.AvgMolecularWeight is not None or
            self.Remark is not None or
            super(PlusFluidComponent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PlusFluidComponent', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlusFluidComponent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PlusFluidComponent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PlusFluidComponent'):
        super(PlusFluidComponent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PlusFluidComponent')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PlusFluidComponent', fromsubclass_=False, pretty_print=True):
        super(PlusFluidComponent, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKind>%s</%sKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Kind), input_name='Kind')), namespace_, eol_))
        if self.SpecificGravity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpecificGravity>%s</%sSpecificGravity>%s' % (namespace_, self.gds_format_double(self.SpecificGravity, input_name='SpecificGravity'), namespace_, eol_))
        if self.StartingCarbonNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartingCarbonNumber>%s</%sStartingCarbonNumber>%s' % (namespace_, self.gds_format_integer(self.StartingCarbonNumber, input_name='StartingCarbonNumber'), namespace_, eol_))
        if self.StartingBoilingPoint is not None:
            self.StartingBoilingPoint.export(outfile, level, namespace_, name_='StartingBoilingPoint', pretty_print=pretty_print)
        if self.AvgDensity is not None:
            self.AvgDensity.export(outfile, level, namespace_, name_='AvgDensity', pretty_print=pretty_print)
        if self.AvgMolecularWeight is not None:
            self.AvgMolecularWeight.export(outfile, level, namespace_, name_='AvgMolecularWeight', pretty_print=pretty_print)
        if self.Remark is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRemark>%s</%sRemark>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Remark), input_name='Remark')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PlusFluidComponent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Kind':
            Kind_ = child_.text
            Kind_ = self.gds_validate_string(Kind_, node, 'Kind')
            self.Kind = Kind_
            # validate type PlusComponentEnumExt
            self.validate_PlusComponentEnumExt(self.Kind)
        elif nodeName_ == 'SpecificGravity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SpecificGravity')
            self.SpecificGravity = fval_
        elif nodeName_ == 'StartingCarbonNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StartingCarbonNumber')
            self.StartingCarbonNumber = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.StartingCarbonNumber)
        elif nodeName_ == 'StartingBoilingPoint':
            obj_ = ThermodynamicTemperatureMeasure.factory()
            obj_.build(child_)
            self.StartingBoilingPoint = obj_
            obj_.original_tagname_ = 'StartingBoilingPoint'
        elif nodeName_ == 'AvgDensity':
            obj_ = MassPerVolumeMeasure.factory()
            obj_.build(child_)
            self.AvgDensity = obj_
            obj_.original_tagname_ = 'AvgDensity'
        elif nodeName_ == 'AvgMolecularWeight':
            obj_ = MolecularWeightMeasure.factory()
            obj_.build(child_)
            self.AvgMolecularWeight = obj_
            obj_.original_tagname_ = 'AvgMolecularWeight'
        elif nodeName_ == 'Remark':
            Remark_ = child_.text
            Remark_ = self.gds_validate_string(Remark_, node, 'Remark')
            self.Remark = Remark_
            # validate type String2000
            self.validate_String2000(self.Remark)
        super(PlusFluidComponent, self).buildChildren(child_, node, nodeName_, True)
# end class PlusFluidComponent


class ProductFlowExternalReference(GeneratedsSuper):
    """A reference to an external port in a different product flow
    model.This value represents a foreign key from one element to
    another.A unique identifier for this data element. It is not
    globally unique (not a uuid) and only need be unique within the
    context of the parent top level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, PortReference=None, ConnectedPortReference=None, ConnectedModelReference=None, ConnectedInstallation=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.PortReference = PortReference
        self.validate_String64(self.PortReference)
        self.ConnectedPortReference = ConnectedPortReference
        self.validate_String64(self.ConnectedPortReference)
        self.ConnectedModelReference = ConnectedModelReference
        self.validate_String64(self.ConnectedModelReference)
        self.ConnectedInstallation = ConnectedInstallation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductFlowExternalReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductFlowExternalReference.subclass:
            return ProductFlowExternalReference.subclass(*args_, **kwargs_)
        else:
            return ProductFlowExternalReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PortReference(self): return self.PortReference
    def set_PortReference(self, PortReference): self.PortReference = PortReference
    PortReferenceProp = property(get_PortReference, set_PortReference)
    def get_ConnectedPortReference(self): return self.ConnectedPortReference
    def set_ConnectedPortReference(self, ConnectedPortReference): self.ConnectedPortReference = ConnectedPortReference
    ConnectedPortReferenceProp = property(get_ConnectedPortReference, set_ConnectedPortReference)
    def get_ConnectedModelReference(self): return self.ConnectedModelReference
    def set_ConnectedModelReference(self, ConnectedModelReference): self.ConnectedModelReference = ConnectedModelReference
    ConnectedModelReferenceProp = property(get_ConnectedModelReference, set_ConnectedModelReference)
    def get_ConnectedInstallation(self): return self.ConnectedInstallation
    def set_ConnectedInstallation(self, ConnectedInstallation): self.ConnectedInstallation = ConnectedInstallation
    ConnectedInstallationProp = property(get_ConnectedInstallation, set_ConnectedInstallation)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.PortReference is not None or
            self.ConnectedPortReference is not None or
            self.ConnectedModelReference is not None or
            self.ConnectedInstallation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductFlowExternalReference', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductFlowExternalReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductFlowExternalReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductFlowExternalReference'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductFlowExternalReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PortReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPortReference>%s</%sPortReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PortReference), input_name='PortReference')), namespace_, eol_))
        if self.ConnectedPortReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConnectedPortReference>%s</%sConnectedPortReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ConnectedPortReference), input_name='ConnectedPortReference')), namespace_, eol_))
        if self.ConnectedModelReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConnectedModelReference>%s</%sConnectedModelReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ConnectedModelReference), input_name='ConnectedModelReference')), namespace_, eol_))
        if self.ConnectedInstallation is not None:
            self.ConnectedInstallation.export(outfile, level, namespace_, name_='ConnectedInstallation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PortReference':
            PortReference_ = child_.text
            PortReference_ = self.gds_validate_string(PortReference_, node, 'PortReference')
            self.PortReference = PortReference_
            # validate type String64
            self.validate_String64(self.PortReference)
        elif nodeName_ == 'ConnectedPortReference':
            ConnectedPortReference_ = child_.text
            ConnectedPortReference_ = self.gds_validate_string(ConnectedPortReference_, node, 'ConnectedPortReference')
            self.ConnectedPortReference = ConnectedPortReference_
            # validate type String64
            self.validate_String64(self.ConnectedPortReference)
        elif nodeName_ == 'ConnectedModelReference':
            ConnectedModelReference_ = child_.text
            ConnectedModelReference_ = self.gds_validate_string(ConnectedModelReference_, node, 'ConnectedModelReference')
            self.ConnectedModelReference = ConnectedModelReference_
            # validate type String64
            self.validate_String64(self.ConnectedModelReference)
        elif nodeName_ == 'ConnectedInstallation':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.ConnectedInstallation = obj_
            obj_.original_tagname_ = 'ConnectedInstallation'
# end class ProductFlowExternalReference


class ProductFlowNetwork(GeneratedsSuper):
    """The non-contextual content of a product flow network object.A unique
    identifier for this data element. It is not globally unique (not
    a uuid) and only need be unique within the context of the parent
    top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Name=None, PlanName=None, ParentNetworkReference=None, Comment=None, Port=None, Plan=None, ChangeLog=None, Unit=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Name = Name
        self.validate_String64(self.Name)
        self.PlanName = PlanName
        self.validate_String64(self.PlanName)
        self.ParentNetworkReference = ParentNetworkReference
        self.validate_String64(self.ParentNetworkReference)
        self.Comment = Comment
        self.validate_String2000(self.Comment)
        if Port is None:
            self.Port = []
        else:
            self.Port = Port
        if Plan is None:
            self.Plan = []
        else:
            self.Plan = Plan
        if ChangeLog is None:
            self.ChangeLog = []
        else:
            self.ChangeLog = ChangeLog
        if Unit is None:
            self.Unit = []
        else:
            self.Unit = Unit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductFlowNetwork)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductFlowNetwork.subclass:
            return ProductFlowNetwork.subclass(*args_, **kwargs_)
        else:
            return ProductFlowNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_PlanName(self): return self.PlanName
    def set_PlanName(self, PlanName): self.PlanName = PlanName
    PlanNameProp = property(get_PlanName, set_PlanName)
    def get_ParentNetworkReference(self): return self.ParentNetworkReference
    def set_ParentNetworkReference(self, ParentNetworkReference): self.ParentNetworkReference = ParentNetworkReference
    ParentNetworkReferenceProp = property(get_ParentNetworkReference, set_ParentNetworkReference)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    def add_Port(self, value): self.Port.append(value)
    def insert_Port_at(self, index, value): self.Port.insert(index, value)
    def replace_Port_at(self, index, value): self.Port[index] = value
    PortProp = property(get_Port, set_Port)
    def get_Plan(self): return self.Plan
    def set_Plan(self, Plan): self.Plan = Plan
    def add_Plan(self, value): self.Plan.append(value)
    def insert_Plan_at(self, index, value): self.Plan.insert(index, value)
    def replace_Plan_at(self, index, value): self.Plan[index] = value
    PlanProp = property(get_Plan, set_Plan)
    def get_ChangeLog(self): return self.ChangeLog
    def set_ChangeLog(self, ChangeLog): self.ChangeLog = ChangeLog
    def add_ChangeLog(self, value): self.ChangeLog.append(value)
    def insert_ChangeLog_at(self, index, value): self.ChangeLog.insert(index, value)
    def replace_ChangeLog_at(self, index, value): self.ChangeLog[index] = value
    ChangeLogProp = property(get_ChangeLog, set_ChangeLog)
    def get_Unit(self): return self.Unit
    def set_Unit(self, Unit): self.Unit = Unit
    def add_Unit(self, value): self.Unit.append(value)
    def insert_Unit_at(self, index, value): self.Unit.insert(index, value)
    def replace_Unit_at(self, index, value): self.Unit[index] = value
    UnitProp = property(get_Unit, set_Unit)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.PlanName is not None or
            self.ParentNetworkReference is not None or
            self.Comment is not None or
            self.Port or
            self.Plan or
            self.ChangeLog or
            self.Unit
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductFlowNetwork', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductFlowNetwork')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductFlowNetwork', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductFlowNetwork'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductFlowNetwork', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.PlanName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlanName>%s</%sPlanName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PlanName), input_name='PlanName')), namespace_, eol_))
        if self.ParentNetworkReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sParentNetworkReference>%s</%sParentNetworkReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ParentNetworkReference), input_name='ParentNetworkReference')), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
        for Port_ in self.Port:
            Port_.export(outfile, level, namespace_, name_='Port', pretty_print=pretty_print)
        for Plan_ in self.Plan:
            Plan_.export(outfile, level, namespace_, name_='Plan', pretty_print=pretty_print)
        for ChangeLog_ in self.ChangeLog:
            ChangeLog_.export(outfile, level, namespace_, name_='ChangeLog', pretty_print=pretty_print)
        for Unit_ in self.Unit:
            Unit_.export(outfile, level, namespace_, name_='Unit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'PlanName':
            PlanName_ = child_.text
            PlanName_ = self.gds_validate_string(PlanName_, node, 'PlanName')
            self.PlanName = PlanName_
            # validate type String64
            self.validate_String64(self.PlanName)
        elif nodeName_ == 'ParentNetworkReference':
            ParentNetworkReference_ = child_.text
            ParentNetworkReference_ = self.gds_validate_string(ParentNetworkReference_, node, 'ParentNetworkReference')
            self.ParentNetworkReference = ParentNetworkReference_
            # validate type String64
            self.validate_String64(self.ParentNetworkReference)
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        elif nodeName_ == 'Port':
            obj_ = ProductFlowExternalPort.factory()
            obj_.build(child_)
            self.Port.append(obj_)
            obj_.original_tagname_ = 'Port'
        elif nodeName_ == 'Plan':
            obj_ = ProductFlowNetworkPlan.factory()
            obj_.build(child_)
            self.Plan.append(obj_)
            obj_.original_tagname_ = 'Plan'
        elif nodeName_ == 'ChangeLog':
            obj_ = ProductFlowChangeLog.factory()
            obj_.build(child_)
            self.ChangeLog.append(obj_)
            obj_.original_tagname_ = 'ChangeLog'
        elif nodeName_ == 'Unit':
            obj_ = ProductFlowUnit.factory()
            obj_.build(child_)
            self.Unit.append(obj_)
            obj_.original_tagname_ = 'Unit'
# end class ProductFlowNetwork


class PseudoFluidComponent(AbstractFluidComponent):
    """Pseudo fluid component."""
    subclass = None
    superclass = AbstractFluidComponent
    def __init__(self, uid=None, MassFraction=None, MoleFraction=None, Kind=None, SpecificGravity=None, StartingCarbonNumber=None, EndingCarbonNumber=None, AvgMolecularWeight=None, AvgDensity=None, StartingBoilingPoint=None, EndingBoilingPoint=None, AvgBoilingPoint=None, Remark=None):
        self.original_tagname_ = None
        super(PseudoFluidComponent, self).__init__(uid, MassFraction, MoleFraction, )
        self.Kind = Kind
        self.validate_PseudoComponentEnumExt(self.Kind)
        self.SpecificGravity = SpecificGravity
        self.StartingCarbonNumber = StartingCarbonNumber
        self.validate_NonNegativeLong(self.StartingCarbonNumber)
        self.EndingCarbonNumber = EndingCarbonNumber
        self.validate_NonNegativeLong(self.EndingCarbonNumber)
        self.AvgMolecularWeight = AvgMolecularWeight
        self.AvgDensity = AvgDensity
        self.StartingBoilingPoint = StartingBoilingPoint
        self.EndingBoilingPoint = EndingBoilingPoint
        self.AvgBoilingPoint = AvgBoilingPoint
        self.Remark = Remark
        self.validate_String2000(self.Remark)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PseudoFluidComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PseudoFluidComponent.subclass:
            return PseudoFluidComponent.subclass(*args_, **kwargs_)
        else:
            return PseudoFluidComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    KindProp = property(get_Kind, set_Kind)
    def get_SpecificGravity(self): return self.SpecificGravity
    def set_SpecificGravity(self, SpecificGravity): self.SpecificGravity = SpecificGravity
    SpecificGravityProp = property(get_SpecificGravity, set_SpecificGravity)
    def get_StartingCarbonNumber(self): return self.StartingCarbonNumber
    def set_StartingCarbonNumber(self, StartingCarbonNumber): self.StartingCarbonNumber = StartingCarbonNumber
    StartingCarbonNumberProp = property(get_StartingCarbonNumber, set_StartingCarbonNumber)
    def get_EndingCarbonNumber(self): return self.EndingCarbonNumber
    def set_EndingCarbonNumber(self, EndingCarbonNumber): self.EndingCarbonNumber = EndingCarbonNumber
    EndingCarbonNumberProp = property(get_EndingCarbonNumber, set_EndingCarbonNumber)
    def get_AvgMolecularWeight(self): return self.AvgMolecularWeight
    def set_AvgMolecularWeight(self, AvgMolecularWeight): self.AvgMolecularWeight = AvgMolecularWeight
    AvgMolecularWeightProp = property(get_AvgMolecularWeight, set_AvgMolecularWeight)
    def get_AvgDensity(self): return self.AvgDensity
    def set_AvgDensity(self, AvgDensity): self.AvgDensity = AvgDensity
    AvgDensityProp = property(get_AvgDensity, set_AvgDensity)
    def get_StartingBoilingPoint(self): return self.StartingBoilingPoint
    def set_StartingBoilingPoint(self, StartingBoilingPoint): self.StartingBoilingPoint = StartingBoilingPoint
    StartingBoilingPointProp = property(get_StartingBoilingPoint, set_StartingBoilingPoint)
    def get_EndingBoilingPoint(self): return self.EndingBoilingPoint
    def set_EndingBoilingPoint(self, EndingBoilingPoint): self.EndingBoilingPoint = EndingBoilingPoint
    EndingBoilingPointProp = property(get_EndingBoilingPoint, set_EndingBoilingPoint)
    def get_AvgBoilingPoint(self): return self.AvgBoilingPoint
    def set_AvgBoilingPoint(self, AvgBoilingPoint): self.AvgBoilingPoint = AvgBoilingPoint
    AvgBoilingPointProp = property(get_AvgBoilingPoint, set_AvgBoilingPoint)
    def get_Remark(self): return self.Remark
    def set_Remark(self, Remark): self.Remark = Remark
    RemarkProp = property(get_Remark, set_Remark)
    def validate_PseudoComponentEnumExt(self, value):
        # Validate type PseudoComponentEnumExt, a restriction on None.
        pass
    def validate_NonNegativeLong(self, value):
        # Validate type NonNegativeLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeLong' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Kind is not None or
            self.SpecificGravity is not None or
            self.StartingCarbonNumber is not None or
            self.EndingCarbonNumber is not None or
            self.AvgMolecularWeight is not None or
            self.AvgDensity is not None or
            self.StartingBoilingPoint is not None or
            self.EndingBoilingPoint is not None or
            self.AvgBoilingPoint is not None or
            self.Remark is not None or
            super(PseudoFluidComponent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PseudoFluidComponent', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PseudoFluidComponent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PseudoFluidComponent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PseudoFluidComponent'):
        super(PseudoFluidComponent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PseudoFluidComponent')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PseudoFluidComponent', fromsubclass_=False, pretty_print=True):
        super(PseudoFluidComponent, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKind>%s</%sKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Kind), input_name='Kind')), namespace_, eol_))
        if self.SpecificGravity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpecificGravity>%s</%sSpecificGravity>%s' % (namespace_, self.gds_format_double(self.SpecificGravity, input_name='SpecificGravity'), namespace_, eol_))
        if self.StartingCarbonNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartingCarbonNumber>%s</%sStartingCarbonNumber>%s' % (namespace_, self.gds_format_integer(self.StartingCarbonNumber, input_name='StartingCarbonNumber'), namespace_, eol_))
        if self.EndingCarbonNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndingCarbonNumber>%s</%sEndingCarbonNumber>%s' % (namespace_, self.gds_format_integer(self.EndingCarbonNumber, input_name='EndingCarbonNumber'), namespace_, eol_))
        if self.AvgMolecularWeight is not None:
            self.AvgMolecularWeight.export(outfile, level, namespace_, name_='AvgMolecularWeight', pretty_print=pretty_print)
        if self.AvgDensity is not None:
            self.AvgDensity.export(outfile, level, namespace_, name_='AvgDensity', pretty_print=pretty_print)
        if self.StartingBoilingPoint is not None:
            self.StartingBoilingPoint.export(outfile, level, namespace_, name_='StartingBoilingPoint', pretty_print=pretty_print)
        if self.EndingBoilingPoint is not None:
            self.EndingBoilingPoint.export(outfile, level, namespace_, name_='EndingBoilingPoint', pretty_print=pretty_print)
        if self.AvgBoilingPoint is not None:
            self.AvgBoilingPoint.export(outfile, level, namespace_, name_='AvgBoilingPoint', pretty_print=pretty_print)
        if self.Remark is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRemark>%s</%sRemark>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Remark), input_name='Remark')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PseudoFluidComponent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Kind':
            Kind_ = child_.text
            Kind_ = self.gds_validate_string(Kind_, node, 'Kind')
            self.Kind = Kind_
            # validate type PseudoComponentEnumExt
            self.validate_PseudoComponentEnumExt(self.Kind)
        elif nodeName_ == 'SpecificGravity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SpecificGravity')
            self.SpecificGravity = fval_
        elif nodeName_ == 'StartingCarbonNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StartingCarbonNumber')
            self.StartingCarbonNumber = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.StartingCarbonNumber)
        elif nodeName_ == 'EndingCarbonNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'EndingCarbonNumber')
            self.EndingCarbonNumber = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.EndingCarbonNumber)
        elif nodeName_ == 'AvgMolecularWeight':
            obj_ = MolecularWeightMeasure.factory()
            obj_.build(child_)
            self.AvgMolecularWeight = obj_
            obj_.original_tagname_ = 'AvgMolecularWeight'
        elif nodeName_ == 'AvgDensity':
            obj_ = MassPerVolumeMeasure.factory()
            obj_.build(child_)
            self.AvgDensity = obj_
            obj_.original_tagname_ = 'AvgDensity'
        elif nodeName_ == 'StartingBoilingPoint':
            obj_ = ThermodynamicTemperatureMeasure.factory()
            obj_.build(child_)
            self.StartingBoilingPoint = obj_
            obj_.original_tagname_ = 'StartingBoilingPoint'
        elif nodeName_ == 'EndingBoilingPoint':
            obj_ = ThermodynamicTemperatureMeasure.factory()
            obj_.build(child_)
            self.EndingBoilingPoint = obj_
            obj_.original_tagname_ = 'EndingBoilingPoint'
        elif nodeName_ == 'AvgBoilingPoint':
            obj_ = ThermodynamicTemperatureMeasure.factory()
            obj_.build(child_)
            self.AvgBoilingPoint = obj_
            obj_.original_tagname_ = 'AvgBoilingPoint'
        elif nodeName_ == 'Remark':
            Remark_ = child_.text
            Remark_ = self.gds_validate_string(Remark_, node, 'Remark')
            self.Remark = Remark_
            # validate type String2000
            self.validate_String2000(self.Remark)
        super(PseudoFluidComponent, self).buildChildren(child_, node, nodeName_, True)
# end class PseudoFluidComponent


class PureFluidComponent(AbstractFluidComponent):
    """Pure fluid component."""
    subclass = None
    superclass = AbstractFluidComponent
    def __init__(self, uid=None, MassFraction=None, MoleFraction=None, Kind=None, MolecularWeight=None, HydrocarbonFlag=None, Remark=None):
        self.original_tagname_ = None
        super(PureFluidComponent, self).__init__(uid, MassFraction, MoleFraction, )
        self.Kind = Kind
        self.validate_PureComponentEnumExt(self.Kind)
        self.MolecularWeight = MolecularWeight
        self.HydrocarbonFlag = HydrocarbonFlag
        self.Remark = Remark
        self.validate_String2000(self.Remark)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PureFluidComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PureFluidComponent.subclass:
            return PureFluidComponent.subclass(*args_, **kwargs_)
        else:
            return PureFluidComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    KindProp = property(get_Kind, set_Kind)
    def get_MolecularWeight(self): return self.MolecularWeight
    def set_MolecularWeight(self, MolecularWeight): self.MolecularWeight = MolecularWeight
    MolecularWeightProp = property(get_MolecularWeight, set_MolecularWeight)
    def get_HydrocarbonFlag(self): return self.HydrocarbonFlag
    def set_HydrocarbonFlag(self, HydrocarbonFlag): self.HydrocarbonFlag = HydrocarbonFlag
    HydrocarbonFlagProp = property(get_HydrocarbonFlag, set_HydrocarbonFlag)
    def get_Remark(self): return self.Remark
    def set_Remark(self, Remark): self.Remark = Remark
    RemarkProp = property(get_Remark, set_Remark)
    def validate_PureComponentEnumExt(self, value):
        # Validate type PureComponentEnumExt, a restriction on None.
        pass
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Kind is not None or
            self.MolecularWeight is not None or
            self.HydrocarbonFlag is not None or
            self.Remark is not None or
            super(PureFluidComponent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PureFluidComponent', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PureFluidComponent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PureFluidComponent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PureFluidComponent'):
        super(PureFluidComponent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PureFluidComponent')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PureFluidComponent', fromsubclass_=False, pretty_print=True):
        super(PureFluidComponent, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKind>%s</%sKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Kind), input_name='Kind')), namespace_, eol_))
        if self.MolecularWeight is not None:
            self.MolecularWeight.export(outfile, level, namespace_, name_='MolecularWeight', pretty_print=pretty_print)
        if self.HydrocarbonFlag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHydrocarbonFlag>%s</%sHydrocarbonFlag>%s' % (namespace_, self.gds_format_boolean(self.HydrocarbonFlag, input_name='HydrocarbonFlag'), namespace_, eol_))
        if self.Remark is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRemark>%s</%sRemark>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Remark), input_name='Remark')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PureFluidComponent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Kind':
            Kind_ = child_.text
            Kind_ = self.gds_validate_string(Kind_, node, 'Kind')
            self.Kind = Kind_
            # validate type PureComponentEnumExt
            self.validate_PureComponentEnumExt(self.Kind)
        elif nodeName_ == 'MolecularWeight':
            obj_ = MolecularWeightMeasure.factory()
            obj_.build(child_)
            self.MolecularWeight = obj_
            obj_.original_tagname_ = 'MolecularWeight'
        elif nodeName_ == 'HydrocarbonFlag':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'HydrocarbonFlag')
            self.HydrocarbonFlag = ival_
        elif nodeName_ == 'Remark':
            Remark_ = child_.text
            Remark_ = self.gds_validate_string(Remark_, node, 'Remark')
            self.Remark = Remark_
            # validate type String2000
            self.validate_String2000(self.Remark)
        super(PureFluidComponent, self).buildChildren(child_, node, nodeName_, True)
# end class PureFluidComponent


class StartEndDate(AbstractDateTimeClass):
    """The start and end date for a reporting period."""
    subclass = None
    superclass = AbstractDateTimeClass
    def __init__(self, DTime=None, Date=None, Month=None, DateStart=None, DateEnd=None):
        self.original_tagname_ = None
        super(StartEndDate, self).__init__(DTime, Date, Month, )
        if isinstance(DateStart, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DateStart, '%Y-%m-%d').date()
        else:
            initvalue_ = DateStart
        self.DateStart = initvalue_
        if isinstance(DateEnd, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DateEnd, '%Y-%m-%d').date()
        else:
            initvalue_ = DateEnd
        self.DateEnd = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StartEndDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StartEndDate.subclass:
            return StartEndDate.subclass(*args_, **kwargs_)
        else:
            return StartEndDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DateStart(self): return self.DateStart
    def set_DateStart(self, DateStart): self.DateStart = DateStart
    DateStartProp = property(get_DateStart, set_DateStart)
    def get_DateEnd(self): return self.DateEnd
    def set_DateEnd(self, DateEnd): self.DateEnd = DateEnd
    DateEndProp = property(get_DateEnd, set_DateEnd)
    def hasContent_(self):
        if (
            self.DateStart is not None or
            self.DateEnd is not None or
            super(StartEndDate, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='StartEndDate', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StartEndDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='StartEndDate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='StartEndDate'):
        super(StartEndDate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StartEndDate')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='StartEndDate', fromsubclass_=False, pretty_print=True):
        super(StartEndDate, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DateStart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateStart>%s</%sDateStart>%s' % (namespace_, self.gds_format_date(self.DateStart, input_name='DateStart'), namespace_, eol_))
        if self.DateEnd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateEnd>%s</%sDateEnd>%s' % (namespace_, self.gds_format_date(self.DateEnd, input_name='DateEnd'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StartEndDate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DateStart':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DateStart = dval_
        elif nodeName_ == 'DateEnd':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DateEnd = dval_
        super(StartEndDate, self).buildChildren(child_, node, nodeName_, True)
# end class StartEndDate


class StartEndTime(AbstractDateTimeClass):
    """Start and end time of a reporting period."""
    subclass = None
    superclass = AbstractDateTimeClass
    def __init__(self, DTime=None, Date=None, Month=None, DTimStart=None, DTimEnd=None):
        self.original_tagname_ = None
        super(StartEndTime, self).__init__(DTime, Date, Month, )
        self.DTimStart = DTimStart
        self.validate_TimeStamp(self.DTimStart)
        self.DTimEnd = DTimEnd
        self.validate_TimeStamp(self.DTimEnd)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StartEndTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StartEndTime.subclass:
            return StartEndTime.subclass(*args_, **kwargs_)
        else:
            return StartEndTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DTimStart(self): return self.DTimStart
    def set_DTimStart(self, DTimStart): self.DTimStart = DTimStart
    DTimStartProp = property(get_DTimStart, set_DTimStart)
    def get_DTimEnd(self): return self.DTimEnd
    def set_DTimEnd(self, DTimEnd): self.DTimEnd = DTimEnd
    DTimEndProp = property(get_DTimEnd, set_DTimEnd)
    def validate_TimeStamp(self, value):
        # Validate type TimeStamp, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TimeStamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TimeStamp_patterns_, ))
    validate_TimeStamp_patterns_ = [['^.+T.+[Z+\\-].*$']]
    def hasContent_(self):
        if (
            self.DTimStart is not None or
            self.DTimEnd is not None or
            super(StartEndTime, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='StartEndTime', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StartEndTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='StartEndTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='StartEndTime'):
        super(StartEndTime, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StartEndTime')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='StartEndTime', fromsubclass_=False, pretty_print=True):
        super(StartEndTime, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DTimStart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTimStart>%s</%sDTimStart>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DTimStart), input_name='DTimStart')), namespace_, eol_))
        if self.DTimEnd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTimEnd>%s</%sDTimEnd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DTimEnd), input_name='DTimEnd')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StartEndTime, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DTimStart':
            DTimStart_ = child_.text
            DTimStart_ = self.gds_validate_string(DTimStart_, node, 'DTimStart')
            self.DTimStart = DTimStart_
            # validate type TimeStamp
            self.validate_TimeStamp(self.DTimStart)
        elif nodeName_ == 'DTimEnd':
            DTimEnd_ = child_.text
            DTimEnd_ = self.gds_validate_string(DTimEnd_, node, 'DTimEnd')
            self.DTimEnd = DTimEnd_
            # validate type TimeStamp
            self.validate_TimeStamp(self.DTimEnd)
        super(StartEndTime, self).buildChildren(child_, node, nodeName_, True)
# end class StartEndTime


class StockTankOil(AbstractFluidComponent):
    """Stock tank oil (STO)."""
    subclass = None
    superclass = AbstractFluidComponent
    def __init__(self, uid=None, MassFraction=None, MoleFraction=None, APIGravity=None, MolecularWeight=None, GrossEnergyContentPerUnitMass=None, NetEnergyContentPerUnitMass=None, GrossEnergyContentPerUnitVolume=None, NetEnergyContentPerUnitVolume=None, Remark=None):
        self.original_tagname_ = None
        super(StockTankOil, self).__init__(uid, MassFraction, MoleFraction, )
        self.APIGravity = APIGravity
        self.MolecularWeight = MolecularWeight
        self.GrossEnergyContentPerUnitMass = GrossEnergyContentPerUnitMass
        self.NetEnergyContentPerUnitMass = NetEnergyContentPerUnitMass
        self.GrossEnergyContentPerUnitVolume = GrossEnergyContentPerUnitVolume
        self.NetEnergyContentPerUnitVolume = NetEnergyContentPerUnitVolume
        self.Remark = Remark
        self.validate_String2000(self.Remark)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StockTankOil)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StockTankOil.subclass:
            return StockTankOil.subclass(*args_, **kwargs_)
        else:
            return StockTankOil(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_APIGravity(self): return self.APIGravity
    def set_APIGravity(self, APIGravity): self.APIGravity = APIGravity
    APIGravityProp = property(get_APIGravity, set_APIGravity)
    def get_MolecularWeight(self): return self.MolecularWeight
    def set_MolecularWeight(self, MolecularWeight): self.MolecularWeight = MolecularWeight
    MolecularWeightProp = property(get_MolecularWeight, set_MolecularWeight)
    def get_GrossEnergyContentPerUnitMass(self): return self.GrossEnergyContentPerUnitMass
    def set_GrossEnergyContentPerUnitMass(self, GrossEnergyContentPerUnitMass): self.GrossEnergyContentPerUnitMass = GrossEnergyContentPerUnitMass
    GrossEnergyContentPerUnitMassProp = property(get_GrossEnergyContentPerUnitMass, set_GrossEnergyContentPerUnitMass)
    def get_NetEnergyContentPerUnitMass(self): return self.NetEnergyContentPerUnitMass
    def set_NetEnergyContentPerUnitMass(self, NetEnergyContentPerUnitMass): self.NetEnergyContentPerUnitMass = NetEnergyContentPerUnitMass
    NetEnergyContentPerUnitMassProp = property(get_NetEnergyContentPerUnitMass, set_NetEnergyContentPerUnitMass)
    def get_GrossEnergyContentPerUnitVolume(self): return self.GrossEnergyContentPerUnitVolume
    def set_GrossEnergyContentPerUnitVolume(self, GrossEnergyContentPerUnitVolume): self.GrossEnergyContentPerUnitVolume = GrossEnergyContentPerUnitVolume
    GrossEnergyContentPerUnitVolumeProp = property(get_GrossEnergyContentPerUnitVolume, set_GrossEnergyContentPerUnitVolume)
    def get_NetEnergyContentPerUnitVolume(self): return self.NetEnergyContentPerUnitVolume
    def set_NetEnergyContentPerUnitVolume(self, NetEnergyContentPerUnitVolume): self.NetEnergyContentPerUnitVolume = NetEnergyContentPerUnitVolume
    NetEnergyContentPerUnitVolumeProp = property(get_NetEnergyContentPerUnitVolume, set_NetEnergyContentPerUnitVolume)
    def get_Remark(self): return self.Remark
    def set_Remark(self, Remark): self.Remark = Remark
    RemarkProp = property(get_Remark, set_Remark)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.APIGravity is not None or
            self.MolecularWeight is not None or
            self.GrossEnergyContentPerUnitMass is not None or
            self.NetEnergyContentPerUnitMass is not None or
            self.GrossEnergyContentPerUnitVolume is not None or
            self.NetEnergyContentPerUnitVolume is not None or
            self.Remark is not None or
            super(StockTankOil, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='StockTankOil', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StockTankOil')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='StockTankOil', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='StockTankOil'):
        super(StockTankOil, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StockTankOil')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='StockTankOil', fromsubclass_=False, pretty_print=True):
        super(StockTankOil, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.APIGravity is not None:
            self.APIGravity.export(outfile, level, namespace_, name_='APIGravity', pretty_print=pretty_print)
        if self.MolecularWeight is not None:
            self.MolecularWeight.export(outfile, level, namespace_, name_='MolecularWeight', pretty_print=pretty_print)
        if self.GrossEnergyContentPerUnitMass is not None:
            self.GrossEnergyContentPerUnitMass.export(outfile, level, namespace_, name_='GrossEnergyContentPerUnitMass', pretty_print=pretty_print)
        if self.NetEnergyContentPerUnitMass is not None:
            self.NetEnergyContentPerUnitMass.export(outfile, level, namespace_, name_='NetEnergyContentPerUnitMass', pretty_print=pretty_print)
        if self.GrossEnergyContentPerUnitVolume is not None:
            self.GrossEnergyContentPerUnitVolume.export(outfile, level, namespace_, name_='GrossEnergyContentPerUnitVolume', pretty_print=pretty_print)
        if self.NetEnergyContentPerUnitVolume is not None:
            self.NetEnergyContentPerUnitVolume.export(outfile, level, namespace_, name_='NetEnergyContentPerUnitVolume', pretty_print=pretty_print)
        if self.Remark is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRemark>%s</%sRemark>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Remark), input_name='Remark')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StockTankOil, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'APIGravity':
            obj_ = APIGravityMeasure.factory()
            obj_.build(child_)
            self.APIGravity = obj_
            obj_.original_tagname_ = 'APIGravity'
        elif nodeName_ == 'MolecularWeight':
            obj_ = MolecularWeightMeasure.factory()
            obj_.build(child_)
            self.MolecularWeight = obj_
            obj_.original_tagname_ = 'MolecularWeight'
        elif nodeName_ == 'GrossEnergyContentPerUnitMass':
            obj_ = EnergyPerMassMeasure.factory()
            obj_.build(child_)
            self.GrossEnergyContentPerUnitMass = obj_
            obj_.original_tagname_ = 'GrossEnergyContentPerUnitMass'
        elif nodeName_ == 'NetEnergyContentPerUnitMass':
            obj_ = EnergyPerMassMeasure.factory()
            obj_.build(child_)
            self.NetEnergyContentPerUnitMass = obj_
            obj_.original_tagname_ = 'NetEnergyContentPerUnitMass'
        elif nodeName_ == 'GrossEnergyContentPerUnitVolume':
            obj_ = EnergyPerVolumeMeasure.factory()
            obj_.build(child_)
            self.GrossEnergyContentPerUnitVolume = obj_
            obj_.original_tagname_ = 'GrossEnergyContentPerUnitVolume'
        elif nodeName_ == 'NetEnergyContentPerUnitVolume':
            obj_ = EnergyPerVolumeMeasure.factory()
            obj_.build(child_)
            self.NetEnergyContentPerUnitVolume = obj_
            obj_.original_tagname_ = 'NetEnergyContentPerUnitVolume'
        elif nodeName_ == 'Remark':
            Remark_ = child_.text
            Remark_ = self.gds_validate_string(Remark_, node, 'Remark')
            self.Remark = Remark_
            # validate type String2000
            self.validate_String2000(self.Remark)
        super(StockTankOil, self).buildChildren(child_, node, nodeName_, True)
# end class StockTankOil


class VaporComposition(GeneratedsSuper):
    """Vapor composition."""
    subclass = None
    superclass = None
    def __init__(self, Remark=None, VaporComponent=None):
        self.original_tagname_ = None
        self.Remark = Remark
        self.validate_String2000(self.Remark)
        if VaporComponent is None:
            self.VaporComponent = []
        else:
            self.VaporComponent = VaporComponent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VaporComposition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VaporComposition.subclass:
            return VaporComposition.subclass(*args_, **kwargs_)
        else:
            return VaporComposition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Remark(self): return self.Remark
    def set_Remark(self, Remark): self.Remark = Remark
    RemarkProp = property(get_Remark, set_Remark)
    def get_VaporComponent(self): return self.VaporComponent
    def set_VaporComponent(self, VaporComponent): self.VaporComponent = VaporComponent
    def add_VaporComponent(self, value): self.VaporComponent.append(value)
    def insert_VaporComponent_at(self, index, value): self.VaporComponent.insert(index, value)
    def replace_VaporComponent_at(self, index, value): self.VaporComponent[index] = value
    VaporComponentProp = property(get_VaporComponent, set_VaporComponent)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Remark is not None or
            self.VaporComponent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VaporComposition', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VaporComposition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VaporComposition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VaporComposition'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VaporComposition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Remark is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRemark>%s</%sRemark>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Remark), input_name='Remark')), namespace_, eol_))
        for VaporComponent_ in self.VaporComponent:
            VaporComponent_.export(outfile, level, namespace_, name_='VaporComponent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Remark':
            Remark_ = child_.text
            Remark_ = self.gds_validate_string(Remark_, node, 'Remark')
            self.Remark = Remark_
            # validate type String2000
            self.validate_String2000(self.Remark)
        elif nodeName_ == 'VaporComponent':
            obj_ = FluidComponent.factory()
            obj_.build(child_)
            self.VaporComponent.append(obj_)
            obj_.original_tagname_ = 'VaporComponent'
# end class VaporComposition


class VolumeQualifiedMeasure(GeneratedsSuper):
    """A volume flow rate which may have a quality status. If the 'status'
    attribute is absent and the value is not "NaN", the data value
    can be assumed to be good with no restrictions.An indicator of
    the quality of the value."""
    subclass = None
    superclass = None
    def __init__(self, status=None):
        self.original_tagname_ = None
        self.status = _cast(None, status)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumeQualifiedMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumeQualifiedMeasure.subclass:
            return VolumeQualifiedMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumeQualifiedMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    statusProp = property(get_status, set_status)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumeQualifiedMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumeQualifiedMeasure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumeQualifiedMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumeQualifiedMeasure'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumeQualifiedMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumeQualifiedMeasure


class WellElevationCoord(GeneratedsSuper):
    """A vertical (gravity-based) elevation coordinate within the context
    of a well. Positive moving upward from the reference datum. All
    coordinates with the same datum (and same UOM) can be considered
    to be in the same coordinate reference system (CRS) and are thus
    directly comparable.The unit of measure of the quantity value.
    If not given then the default unit of measure of the explicitly
    or implicitly given datum must be assumed."""
    subclass = None
    superclass = None
    def __init__(self, uom=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WellElevationCoord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WellElevationCoord.subclass:
            return WellElevationCoord.subclass(*args_, **kwargs_)
        else:
            return WellElevationCoord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='WellElevationCoord', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WellElevationCoord')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='WellElevationCoord', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='WellElevationCoord'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='WellElevationCoord', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WellElevationCoord


class WellVerticalDepthCoord(GeneratedsSuper):
    """A vertical (gravity-based) depth coordinate within the context of a
    well. Positive moving downward from the reference datum. All
    coordinates with the same datum (and same UOM) can be considered
    to be in the same coordinate reference system (CRS) and are thus
    directly comparable.The unit of measure of the quantity value."""
    subclass = None
    superclass = None
    def __init__(self, uom=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WellVerticalDepthCoord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WellVerticalDepthCoord.subclass:
            return WellVerticalDepthCoord.subclass(*args_, **kwargs_)
        else:
            return WellVerticalDepthCoord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='WellVerticalDepthCoord', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WellVerticalDepthCoord')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='WellVerticalDepthCoord', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='WellVerticalDepthCoord'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='WellVerticalDepthCoord', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WellVerticalDepthCoord


class CommonPropertiesProductVolume(GeneratedsSuper):
    """Properties that are common to multiple structures in the product
    volume schema."""
    subclass = None
    superclass = None
    def __init__(self, Gor=None, GorMTD=None, GasLiquidRatio=None, WaterConcMass=None, WaterConcVol=None, Atmosphere=None, Temp=None, Pres=None, AbsoluteMinPres=None, Mass=None, Work=None, Efficiency=None, Rvp=None, Tvp=None, Bsw=None, BswPrevious=None, DensityFlowRate=None, Concentration=None, MolecularWeight=None, WeightPercent=None, MolePercent=None, MoleAmt=None, Sg=None, HcDewpoint=None, WaterDewpoint=None, WobbeIndex=None, GrossCalorificValueStd=None, RvpStabilizedCrude=None, BswStabilizedCrude=None, DensityStabilizedCrude=None, DensityValue=None, PortDiff=None, VolumeValue=None, FlowRateValue=None):
        self.original_tagname_ = None
        self.Gor = Gor
        self.GorMTD = GorMTD
        self.GasLiquidRatio = GasLiquidRatio
        self.WaterConcMass = WaterConcMass
        self.WaterConcVol = WaterConcVol
        self.Atmosphere = Atmosphere
        self.Temp = Temp
        self.Pres = Pres
        self.AbsoluteMinPres = AbsoluteMinPres
        self.Mass = Mass
        self.Work = Work
        self.Efficiency = Efficiency
        self.Rvp = Rvp
        self.Tvp = Tvp
        self.Bsw = Bsw
        self.BswPrevious = BswPrevious
        self.DensityFlowRate = DensityFlowRate
        self.Concentration = Concentration
        self.MolecularWeight = MolecularWeight
        self.WeightPercent = WeightPercent
        self.MolePercent = MolePercent
        self.MoleAmt = MoleAmt
        self.Sg = Sg
        self.HcDewpoint = HcDewpoint
        self.WaterDewpoint = WaterDewpoint
        self.WobbeIndex = WobbeIndex
        self.GrossCalorificValueStd = GrossCalorificValueStd
        self.RvpStabilizedCrude = RvpStabilizedCrude
        self.BswStabilizedCrude = BswStabilizedCrude
        self.DensityStabilizedCrude = DensityStabilizedCrude
        if DensityValue is None:
            self.DensityValue = []
        else:
            self.DensityValue = DensityValue
        if PortDiff is None:
            self.PortDiff = []
        else:
            self.PortDiff = PortDiff
        if VolumeValue is None:
            self.VolumeValue = []
        else:
            self.VolumeValue = VolumeValue
        if FlowRateValue is None:
            self.FlowRateValue = []
        else:
            self.FlowRateValue = FlowRateValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommonPropertiesProductVolume)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommonPropertiesProductVolume.subclass:
            return CommonPropertiesProductVolume.subclass(*args_, **kwargs_)
        else:
            return CommonPropertiesProductVolume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Gor(self): return self.Gor
    def set_Gor(self, Gor): self.Gor = Gor
    GorProp = property(get_Gor, set_Gor)
    def get_GorMTD(self): return self.GorMTD
    def set_GorMTD(self, GorMTD): self.GorMTD = GorMTD
    GorMTDProp = property(get_GorMTD, set_GorMTD)
    def get_GasLiquidRatio(self): return self.GasLiquidRatio
    def set_GasLiquidRatio(self, GasLiquidRatio): self.GasLiquidRatio = GasLiquidRatio
    GasLiquidRatioProp = property(get_GasLiquidRatio, set_GasLiquidRatio)
    def get_WaterConcMass(self): return self.WaterConcMass
    def set_WaterConcMass(self, WaterConcMass): self.WaterConcMass = WaterConcMass
    WaterConcMassProp = property(get_WaterConcMass, set_WaterConcMass)
    def get_WaterConcVol(self): return self.WaterConcVol
    def set_WaterConcVol(self, WaterConcVol): self.WaterConcVol = WaterConcVol
    WaterConcVolProp = property(get_WaterConcVol, set_WaterConcVol)
    def get_Atmosphere(self): return self.Atmosphere
    def set_Atmosphere(self, Atmosphere): self.Atmosphere = Atmosphere
    AtmosphereProp = property(get_Atmosphere, set_Atmosphere)
    def get_Temp(self): return self.Temp
    def set_Temp(self, Temp): self.Temp = Temp
    TempProp = property(get_Temp, set_Temp)
    def get_Pres(self): return self.Pres
    def set_Pres(self, Pres): self.Pres = Pres
    PresProp = property(get_Pres, set_Pres)
    def get_AbsoluteMinPres(self): return self.AbsoluteMinPres
    def set_AbsoluteMinPres(self, AbsoluteMinPres): self.AbsoluteMinPres = AbsoluteMinPres
    AbsoluteMinPresProp = property(get_AbsoluteMinPres, set_AbsoluteMinPres)
    def get_Mass(self): return self.Mass
    def set_Mass(self, Mass): self.Mass = Mass
    MassProp = property(get_Mass, set_Mass)
    def get_Work(self): return self.Work
    def set_Work(self, Work): self.Work = Work
    WorkProp = property(get_Work, set_Work)
    def get_Efficiency(self): return self.Efficiency
    def set_Efficiency(self, Efficiency): self.Efficiency = Efficiency
    EfficiencyProp = property(get_Efficiency, set_Efficiency)
    def get_Rvp(self): return self.Rvp
    def set_Rvp(self, Rvp): self.Rvp = Rvp
    RvpProp = property(get_Rvp, set_Rvp)
    def get_Tvp(self): return self.Tvp
    def set_Tvp(self, Tvp): self.Tvp = Tvp
    TvpProp = property(get_Tvp, set_Tvp)
    def get_Bsw(self): return self.Bsw
    def set_Bsw(self, Bsw): self.Bsw = Bsw
    BswProp = property(get_Bsw, set_Bsw)
    def get_BswPrevious(self): return self.BswPrevious
    def set_BswPrevious(self, BswPrevious): self.BswPrevious = BswPrevious
    BswPreviousProp = property(get_BswPrevious, set_BswPrevious)
    def get_DensityFlowRate(self): return self.DensityFlowRate
    def set_DensityFlowRate(self, DensityFlowRate): self.DensityFlowRate = DensityFlowRate
    DensityFlowRateProp = property(get_DensityFlowRate, set_DensityFlowRate)
    def get_Concentration(self): return self.Concentration
    def set_Concentration(self, Concentration): self.Concentration = Concentration
    ConcentrationProp = property(get_Concentration, set_Concentration)
    def get_MolecularWeight(self): return self.MolecularWeight
    def set_MolecularWeight(self, MolecularWeight): self.MolecularWeight = MolecularWeight
    MolecularWeightProp = property(get_MolecularWeight, set_MolecularWeight)
    def get_WeightPercent(self): return self.WeightPercent
    def set_WeightPercent(self, WeightPercent): self.WeightPercent = WeightPercent
    WeightPercentProp = property(get_WeightPercent, set_WeightPercent)
    def get_MolePercent(self): return self.MolePercent
    def set_MolePercent(self, MolePercent): self.MolePercent = MolePercent
    MolePercentProp = property(get_MolePercent, set_MolePercent)
    def get_MoleAmt(self): return self.MoleAmt
    def set_MoleAmt(self, MoleAmt): self.MoleAmt = MoleAmt
    MoleAmtProp = property(get_MoleAmt, set_MoleAmt)
    def get_Sg(self): return self.Sg
    def set_Sg(self, Sg): self.Sg = Sg
    SgProp = property(get_Sg, set_Sg)
    def get_HcDewpoint(self): return self.HcDewpoint
    def set_HcDewpoint(self, HcDewpoint): self.HcDewpoint = HcDewpoint
    HcDewpointProp = property(get_HcDewpoint, set_HcDewpoint)
    def get_WaterDewpoint(self): return self.WaterDewpoint
    def set_WaterDewpoint(self, WaterDewpoint): self.WaterDewpoint = WaterDewpoint
    WaterDewpointProp = property(get_WaterDewpoint, set_WaterDewpoint)
    def get_WobbeIndex(self): return self.WobbeIndex
    def set_WobbeIndex(self, WobbeIndex): self.WobbeIndex = WobbeIndex
    WobbeIndexProp = property(get_WobbeIndex, set_WobbeIndex)
    def get_GrossCalorificValueStd(self): return self.GrossCalorificValueStd
    def set_GrossCalorificValueStd(self, GrossCalorificValueStd): self.GrossCalorificValueStd = GrossCalorificValueStd
    GrossCalorificValueStdProp = property(get_GrossCalorificValueStd, set_GrossCalorificValueStd)
    def get_RvpStabilizedCrude(self): return self.RvpStabilizedCrude
    def set_RvpStabilizedCrude(self, RvpStabilizedCrude): self.RvpStabilizedCrude = RvpStabilizedCrude
    RvpStabilizedCrudeProp = property(get_RvpStabilizedCrude, set_RvpStabilizedCrude)
    def get_BswStabilizedCrude(self): return self.BswStabilizedCrude
    def set_BswStabilizedCrude(self, BswStabilizedCrude): self.BswStabilizedCrude = BswStabilizedCrude
    BswStabilizedCrudeProp = property(get_BswStabilizedCrude, set_BswStabilizedCrude)
    def get_DensityStabilizedCrude(self): return self.DensityStabilizedCrude
    def set_DensityStabilizedCrude(self, DensityStabilizedCrude): self.DensityStabilizedCrude = DensityStabilizedCrude
    DensityStabilizedCrudeProp = property(get_DensityStabilizedCrude, set_DensityStabilizedCrude)
    def get_DensityValue(self): return self.DensityValue
    def set_DensityValue(self, DensityValue): self.DensityValue = DensityValue
    def add_DensityValue(self, value): self.DensityValue.append(value)
    def insert_DensityValue_at(self, index, value): self.DensityValue.insert(index, value)
    def replace_DensityValue_at(self, index, value): self.DensityValue[index] = value
    DensityValueProp = property(get_DensityValue, set_DensityValue)
    def get_PortDiff(self): return self.PortDiff
    def set_PortDiff(self, PortDiff): self.PortDiff = PortDiff
    def add_PortDiff(self, value): self.PortDiff.append(value)
    def insert_PortDiff_at(self, index, value): self.PortDiff.insert(index, value)
    def replace_PortDiff_at(self, index, value): self.PortDiff[index] = value
    PortDiffProp = property(get_PortDiff, set_PortDiff)
    def get_VolumeValue(self): return self.VolumeValue
    def set_VolumeValue(self, VolumeValue): self.VolumeValue = VolumeValue
    def add_VolumeValue(self, value): self.VolumeValue.append(value)
    def insert_VolumeValue_at(self, index, value): self.VolumeValue.insert(index, value)
    def replace_VolumeValue_at(self, index, value): self.VolumeValue[index] = value
    VolumeValueProp = property(get_VolumeValue, set_VolumeValue)
    def get_FlowRateValue(self): return self.FlowRateValue
    def set_FlowRateValue(self, FlowRateValue): self.FlowRateValue = FlowRateValue
    def add_FlowRateValue(self, value): self.FlowRateValue.append(value)
    def insert_FlowRateValue_at(self, index, value): self.FlowRateValue.insert(index, value)
    def replace_FlowRateValue_at(self, index, value): self.FlowRateValue[index] = value
    FlowRateValueProp = property(get_FlowRateValue, set_FlowRateValue)
    def hasContent_(self):
        if (
            self.Gor is not None or
            self.GorMTD is not None or
            self.GasLiquidRatio is not None or
            self.WaterConcMass is not None or
            self.WaterConcVol is not None or
            self.Atmosphere is not None or
            self.Temp is not None or
            self.Pres is not None or
            self.AbsoluteMinPres is not None or
            self.Mass is not None or
            self.Work is not None or
            self.Efficiency is not None or
            self.Rvp is not None or
            self.Tvp is not None or
            self.Bsw is not None or
            self.BswPrevious is not None or
            self.DensityFlowRate is not None or
            self.Concentration is not None or
            self.MolecularWeight is not None or
            self.WeightPercent is not None or
            self.MolePercent is not None or
            self.MoleAmt is not None or
            self.Sg is not None or
            self.HcDewpoint is not None or
            self.WaterDewpoint is not None or
            self.WobbeIndex is not None or
            self.GrossCalorificValueStd is not None or
            self.RvpStabilizedCrude is not None or
            self.BswStabilizedCrude is not None or
            self.DensityStabilizedCrude is not None or
            self.DensityValue or
            self.PortDiff or
            self.VolumeValue or
            self.FlowRateValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CommonPropertiesProductVolume', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommonPropertiesProductVolume')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CommonPropertiesProductVolume', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CommonPropertiesProductVolume'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CommonPropertiesProductVolume', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Gor is not None:
            self.Gor.export(outfile, level, namespace_, name_='Gor', pretty_print=pretty_print)
        if self.GorMTD is not None:
            self.GorMTD.export(outfile, level, namespace_, name_='GorMTD', pretty_print=pretty_print)
        if self.GasLiquidRatio is not None:
            self.GasLiquidRatio.export(outfile, level, namespace_, name_='GasLiquidRatio', pretty_print=pretty_print)
        if self.WaterConcMass is not None:
            self.WaterConcMass.export(outfile, level, namespace_, name_='WaterConcMass', pretty_print=pretty_print)
        if self.WaterConcVol is not None:
            self.WaterConcVol.export(outfile, level, namespace_, name_='WaterConcVol', pretty_print=pretty_print)
        if self.Atmosphere is not None:
            self.Atmosphere.export(outfile, level, namespace_, name_='Atmosphere', pretty_print=pretty_print)
        if self.Temp is not None:
            self.Temp.export(outfile, level, namespace_, name_='Temp', pretty_print=pretty_print)
        if self.Pres is not None:
            self.Pres.export(outfile, level, namespace_, name_='Pres', pretty_print=pretty_print)
        if self.AbsoluteMinPres is not None:
            self.AbsoluteMinPres.export(outfile, level, namespace_, name_='AbsoluteMinPres', pretty_print=pretty_print)
        if self.Mass is not None:
            self.Mass.export(outfile, level, namespace_, name_='Mass', pretty_print=pretty_print)
        if self.Work is not None:
            self.Work.export(outfile, level, namespace_, name_='Work', pretty_print=pretty_print)
        if self.Efficiency is not None:
            self.Efficiency.export(outfile, level, namespace_, name_='Efficiency', pretty_print=pretty_print)
        if self.Rvp is not None:
            self.Rvp.export(outfile, level, namespace_, name_='Rvp', pretty_print=pretty_print)
        if self.Tvp is not None:
            self.Tvp.export(outfile, level, namespace_, name_='Tvp', pretty_print=pretty_print)
        if self.Bsw is not None:
            self.Bsw.export(outfile, level, namespace_, name_='Bsw', pretty_print=pretty_print)
        if self.BswPrevious is not None:
            self.BswPrevious.export(outfile, level, namespace_, name_='BswPrevious', pretty_print=pretty_print)
        if self.DensityFlowRate is not None:
            self.DensityFlowRate.export(outfile, level, namespace_, name_='DensityFlowRate', pretty_print=pretty_print)
        if self.Concentration is not None:
            self.Concentration.export(outfile, level, namespace_, name_='Concentration', pretty_print=pretty_print)
        if self.MolecularWeight is not None:
            self.MolecularWeight.export(outfile, level, namespace_, name_='MolecularWeight', pretty_print=pretty_print)
        if self.WeightPercent is not None:
            self.WeightPercent.export(outfile, level, namespace_, name_='WeightPercent', pretty_print=pretty_print)
        if self.MolePercent is not None:
            self.MolePercent.export(outfile, level, namespace_, name_='MolePercent', pretty_print=pretty_print)
        if self.MoleAmt is not None:
            self.MoleAmt.export(outfile, level, namespace_, name_='MoleAmt', pretty_print=pretty_print)
        if self.Sg is not None:
            self.Sg.export(outfile, level, namespace_, name_='Sg', pretty_print=pretty_print)
        if self.HcDewpoint is not None:
            self.HcDewpoint.export(outfile, level, namespace_, name_='HcDewpoint', pretty_print=pretty_print)
        if self.WaterDewpoint is not None:
            self.WaterDewpoint.export(outfile, level, namespace_, name_='WaterDewpoint', pretty_print=pretty_print)
        if self.WobbeIndex is not None:
            self.WobbeIndex.export(outfile, level, namespace_, name_='WobbeIndex', pretty_print=pretty_print)
        if self.GrossCalorificValueStd is not None:
            self.GrossCalorificValueStd.export(outfile, level, namespace_, name_='GrossCalorificValueStd', pretty_print=pretty_print)
        if self.RvpStabilizedCrude is not None:
            self.RvpStabilizedCrude.export(outfile, level, namespace_, name_='RvpStabilizedCrude', pretty_print=pretty_print)
        if self.BswStabilizedCrude is not None:
            self.BswStabilizedCrude.export(outfile, level, namespace_, name_='BswStabilizedCrude', pretty_print=pretty_print)
        if self.DensityStabilizedCrude is not None:
            self.DensityStabilizedCrude.export(outfile, level, namespace_, name_='DensityStabilizedCrude', pretty_print=pretty_print)
        for DensityValue_ in self.DensityValue:
            DensityValue_.export(outfile, level, namespace_, name_='DensityValue', pretty_print=pretty_print)
        for PortDiff_ in self.PortDiff:
            PortDiff_.export(outfile, level, namespace_, name_='PortDiff', pretty_print=pretty_print)
        for VolumeValue_ in self.VolumeValue:
            VolumeValue_.export(outfile, level, namespace_, name_='VolumeValue', pretty_print=pretty_print)
        for FlowRateValue_ in self.FlowRateValue:
            FlowRateValue_.export(outfile, level, namespace_, name_='FlowRateValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Gor':
            obj_ = VolumePerVolumeMeasure.factory()
            obj_.build(child_)
            self.Gor = obj_
            obj_.original_tagname_ = 'Gor'
        elif nodeName_ == 'GorMTD':
            obj_ = VolumePerVolumeMeasure.factory()
            obj_.build(child_)
            self.GorMTD = obj_
            obj_.original_tagname_ = 'GorMTD'
        elif nodeName_ == 'GasLiquidRatio':
            obj_ = VolumePerVolumeMeasure.factory()
            obj_.build(child_)
            self.GasLiquidRatio = obj_
            obj_.original_tagname_ = 'GasLiquidRatio'
        elif nodeName_ == 'WaterConcMass':
            obj_ = MassPerMassMeasure.factory()
            obj_.build(child_)
            self.WaterConcMass = obj_
            obj_.original_tagname_ = 'WaterConcMass'
        elif nodeName_ == 'WaterConcVol':
            obj_ = VolumePerVolumeMeasure.factory()
            obj_.build(child_)
            self.WaterConcVol = obj_
            obj_.original_tagname_ = 'WaterConcVol'
        elif nodeName_ == 'Atmosphere':
            obj_ = PressureMeasure.factory()
            obj_.build(child_)
            self.Atmosphere = obj_
            obj_.original_tagname_ = 'Atmosphere'
        elif nodeName_ == 'Temp':
            obj_ = ThermodynamicTemperatureMeasure.factory()
            obj_.build(child_)
            self.Temp = obj_
            obj_.original_tagname_ = 'Temp'
        elif nodeName_ == 'Pres':
            obj_ = PressureMeasure.factory()
            obj_.build(child_)
            self.Pres = obj_
            obj_.original_tagname_ = 'Pres'
        elif nodeName_ == 'AbsoluteMinPres':
            obj_ = PressureMeasure.factory()
            obj_.build(child_)
            self.AbsoluteMinPres = obj_
            obj_.original_tagname_ = 'AbsoluteMinPres'
        elif nodeName_ == 'Mass':
            obj_ = MassMeasure.factory()
            obj_.build(child_)
            self.Mass = obj_
            obj_.original_tagname_ = 'Mass'
        elif nodeName_ == 'Work':
            obj_ = EnergyMeasure.factory()
            obj_.build(child_)
            self.Work = obj_
            obj_.original_tagname_ = 'Work'
        elif nodeName_ == 'Efficiency':
            obj_ = VolumePerVolumeMeasure.factory()
            obj_.build(child_)
            self.Efficiency = obj_
            obj_.original_tagname_ = 'Efficiency'
        elif nodeName_ == 'Rvp':
            obj_ = PressureMeasure.factory()
            obj_.build(child_)
            self.Rvp = obj_
            obj_.original_tagname_ = 'Rvp'
        elif nodeName_ == 'Tvp':
            obj_ = PressureMeasure.factory()
            obj_.build(child_)
            self.Tvp = obj_
            obj_.original_tagname_ = 'Tvp'
        elif nodeName_ == 'Bsw':
            obj_ = VolumePerVolumeMeasure.factory()
            obj_.build(child_)
            self.Bsw = obj_
            obj_.original_tagname_ = 'Bsw'
        elif nodeName_ == 'BswPrevious':
            obj_ = VolumePerVolumeMeasure.factory()
            obj_.build(child_)
            self.BswPrevious = obj_
            obj_.original_tagname_ = 'BswPrevious'
        elif nodeName_ == 'DensityFlowRate':
            obj_ = MassPerTimeMeasure.factory()
            obj_.build(child_)
            self.DensityFlowRate = obj_
            obj_.original_tagname_ = 'DensityFlowRate'
        elif nodeName_ == 'Concentration':
            obj_ = VolumePerVolumeMeasure.factory()
            obj_.build(child_)
            self.Concentration = obj_
            obj_.original_tagname_ = 'Concentration'
        elif nodeName_ == 'MolecularWeight':
            obj_ = MolecularWeightMeasure.factory()
            obj_.build(child_)
            self.MolecularWeight = obj_
            obj_.original_tagname_ = 'MolecularWeight'
        elif nodeName_ == 'WeightPercent':
            obj_ = MassPerMassMeasure.factory()
            obj_.build(child_)
            self.WeightPercent = obj_
            obj_.original_tagname_ = 'WeightPercent'
        elif nodeName_ == 'MolePercent':
            obj_ = AmountOfSubstancePerAmountOfSubstanceMeasure.factory()
            obj_.build(child_)
            self.MolePercent = obj_
            obj_.original_tagname_ = 'MolePercent'
        elif nodeName_ == 'MoleAmt':
            obj_ = AmountOfSubstanceMeasure.factory()
            obj_.build(child_)
            self.MoleAmt = obj_
            obj_.original_tagname_ = 'MoleAmt'
        elif nodeName_ == 'Sg':
            obj_ = DimensionlessMeasure.factory()
            obj_.build(child_)
            self.Sg = obj_
            obj_.original_tagname_ = 'Sg'
        elif nodeName_ == 'HcDewpoint':
            obj_ = ThermodynamicTemperatureMeasure.factory()
            obj_.build(child_)
            self.HcDewpoint = obj_
            obj_.original_tagname_ = 'HcDewpoint'
        elif nodeName_ == 'WaterDewpoint':
            obj_ = ThermodynamicTemperatureMeasure.factory()
            obj_.build(child_)
            self.WaterDewpoint = obj_
            obj_.original_tagname_ = 'WaterDewpoint'
        elif nodeName_ == 'WobbeIndex':
            obj_ = IsothermalCompressibilityMeasure.factory()
            obj_.build(child_)
            self.WobbeIndex = obj_
            obj_.original_tagname_ = 'WobbeIndex'
        elif nodeName_ == 'GrossCalorificValueStd':
            obj_ = EnergyPerVolumeMeasure.factory()
            obj_.build(child_)
            self.GrossCalorificValueStd = obj_
            obj_.original_tagname_ = 'GrossCalorificValueStd'
        elif nodeName_ == 'RvpStabilizedCrude':
            obj_ = PressureMeasure.factory()
            obj_.build(child_)
            self.RvpStabilizedCrude = obj_
            obj_.original_tagname_ = 'RvpStabilizedCrude'
        elif nodeName_ == 'BswStabilizedCrude':
            obj_ = VolumePerVolumeMeasure.factory()
            obj_.build(child_)
            self.BswStabilizedCrude = obj_
            obj_.original_tagname_ = 'BswStabilizedCrude'
        elif nodeName_ == 'DensityStabilizedCrude':
            obj_ = MassPerVolumeMeasure.factory()
            obj_.build(child_)
            self.DensityStabilizedCrude = obj_
            obj_.original_tagname_ = 'DensityStabilizedCrude'
        elif nodeName_ == 'DensityValue':
            obj_ = DensityValue.factory()
            obj_.build(child_)
            self.DensityValue.append(obj_)
            obj_.original_tagname_ = 'DensityValue'
        elif nodeName_ == 'PortDiff':
            obj_ = ProductVolumePortDifference.factory()
            obj_.build(child_)
            self.PortDiff.append(obj_)
            obj_.original_tagname_ = 'PortDiff'
        elif nodeName_ == 'VolumeValue':
            obj_ = VolumeValue.factory()
            obj_.build(child_)
            self.VolumeValue.append(obj_)
            obj_.original_tagname_ = 'VolumeValue'
        elif nodeName_ == 'FlowRateValue':
            obj_ = FlowRateValue.factory()
            obj_.build(child_)
            self.FlowRateValue.append(obj_)
            obj_.original_tagname_ = 'FlowRateValue'
# end class CommonPropertiesProductVolume


class AbstractMeasureDataType(GeneratedsSuper):
    """The abstract base type of measure data."""
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractMeasureDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractMeasureDataType.subclass:
            return AbstractMeasureDataType.subclass(*args_, **kwargs_)
        else:
            return AbstractMeasureDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractMeasureDataType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractMeasureDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractMeasureDataType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractMeasureDataType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractMeasureDataType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractMeasureDataType


class AbstractRefProductFlow(GeneratedsSuper):
    """A reference to a flow within the current product volume report. This
    represents a foreign key from one element to another."""
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractRefProductFlow)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractRefProductFlow.subclass:
            return AbstractRefProductFlow.subclass(*args_, **kwargs_)
        else:
            return AbstractRefProductFlow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractRefProductFlow', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractRefProductFlow')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractRefProductFlow', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractRefProductFlow'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractRefProductFlow', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractRefProductFlow


class AbstractRelatedFacilityObject(GeneratedsSuper):
    """The abstract base type of related facility."""
    subclass = None
    superclass = None
    def __init__(self, FacilityParent=None, extensiontype_=None):
        self.original_tagname_ = None
        self.FacilityParent = FacilityParent
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractRelatedFacilityObject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractRelatedFacilityObject.subclass:
            return AbstractRelatedFacilityObject.subclass(*args_, **kwargs_)
        else:
            return AbstractRelatedFacilityObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FacilityParent(self): return self.FacilityParent
    def set_FacilityParent(self, FacilityParent): self.FacilityParent = FacilityParent
    FacilityParentProp = property(get_FacilityParent, set_FacilityParent)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.FacilityParent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractRelatedFacilityObject', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractRelatedFacilityObject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractRelatedFacilityObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractRelatedFacilityObject'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractRelatedFacilityObject', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FacilityParent is not None:
            self.FacilityParent.export(outfile, level, namespace_, name_='FacilityParent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FacilityParent':
            obj_ = FacilityParent.factory()
            obj_.build(child_)
            self.FacilityParent = obj_
            obj_.original_tagname_ = 'FacilityParent'
# end class AbstractRelatedFacilityObject


class CurveData(AbstractMeasureDataType):
    """The data of a curve. A unique identifier for this data element. It
    is not globally unique (not a uuid) and only need be unique
    within the context of the parent top-level object."""
    subclass = None
    superclass = AbstractMeasureDataType
    def __init__(self, uid=None, Index=None, Value=None):
        self.original_tagname_ = None
        super(CurveData, self).__init__()
        self.uid = _cast(None, uid)
        if Index is None:
            self.Index = []
        else:
            self.Index = Index
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CurveData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CurveData.subclass:
            return CurveData.subclass(*args_, **kwargs_)
        else:
            return CurveData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    def add_Index(self, value): self.Index.append(value)
    def insert_Index_at(self, index, value): self.Index.insert(index, value)
    def replace_Index_at(self, index, value): self.Index[index] = value
    IndexProp = property(get_Index, set_Index)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value_at(self, index, value): self.Value.insert(index, value)
    def replace_Value_at(self, index, value): self.Value[index] = value
    ValueProp = property(get_Value, set_Value)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_PositiveLong(self, value):
        # Validate type PositiveLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveLong' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Index or
            self.Value or
            super(CurveData, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CurveData', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurveData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CurveData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CurveData'):
        super(CurveData, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CurveData')
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CurveData', fromsubclass_=False, pretty_print=True):
        super(CurveData, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Index_ in self.Index:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndex>%s</%sIndex>%s' % (namespace_, self.gds_format_integer(Index_, input_name='Index'), namespace_, eol_))
        for Value_ in self.Value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_double(Value_, input_name='Value'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
        super(CurveData, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Index':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Index')
            self.Index.append(ival_)
            # validate type PositiveLong
            self.validate_PositiveLong(self.Index[-1])
        elif nodeName_ == 'Value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Value')
            self.Value.append(fval_)
        super(CurveData, self).buildChildren(child_, node, nodeName_, True)
# end class CurveData


class CurveDefinition(GeneratedsSuper):
    """The definition of a curve.A unique identifier for this data element.
    It is not globally unique (not a uuid) and only need be unique
    within the context of the parent top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Order=None, Parameter=None, IsIndex=None, MeasureClass=None, Unit=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Order = Order
        self.validate_NonNegativeLong(self.Order)
        self.Parameter = Parameter
        self.validate_String64(self.Parameter)
        self.IsIndex = IsIndex
        self.MeasureClass = MeasureClass
        self.validate_MeasureClass(self.MeasureClass)
        self.Unit = Unit
        self.validate_UomEnum(self.Unit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CurveDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CurveDefinition.subclass:
            return CurveDefinition.subclass(*args_, **kwargs_)
        else:
            return CurveDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Order(self): return self.Order
    def set_Order(self, Order): self.Order = Order
    OrderProp = property(get_Order, set_Order)
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    ParameterProp = property(get_Parameter, set_Parameter)
    def get_IsIndex(self): return self.IsIndex
    def set_IsIndex(self, IsIndex): self.IsIndex = IsIndex
    IsIndexProp = property(get_IsIndex, set_IsIndex)
    def get_MeasureClass(self): return self.MeasureClass
    def set_MeasureClass(self, MeasureClass): self.MeasureClass = MeasureClass
    MeasureClassProp = property(get_MeasureClass, set_MeasureClass)
    def get_Unit(self): return self.Unit
    def set_Unit(self, Unit): self.Unit = Unit
    UnitProp = property(get_Unit, set_Unit)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_NonNegativeLong(self, value):
        # Validate type NonNegativeLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeLong' % {"value" : value} )
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_MeasureClass(self, value):
        # Validate type MeasureClass, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['absorbed dose', 'activity of radioactivity', 'amount of substance', 'amount of substance per amount of substance', 'amount of substance per area', 'amount of substance per time', 'amount of substance per time per area', 'amount of substance per volume', 'angle per length', 'angle per volume', 'angular acceleration', 'angular velocity', 'api gamma ray', 'api gravity', 'api neutron', 'area', 'area per amount of substance', 'area per area', 'area per count', 'area per mass', 'area per time', 'area per volume', 'attenuation per frequency interval', 'capacitance', 'cation exchange capacity', 'data transfer speed', 'diffusion coefficient', 'diffusive time of flight', 'digital storage', 'dimensionless', 'dipole moment', 'dose equivalent', 'dynamic viscosity', 'electric charge', 'electric charge per area', 'electric charge per mass', 'electric charge per volume', 'electric conductance', 'electric conductivity', 'electric current', 'electric current density', 'electric field strength', 'electric potential difference', 'electric resistance', 'electric resistance per length', 'electrical resistivity', 'electromagnetic moment', 'energy', 'energy length per area', 'energy length per time area temperature', 'energy per area', 'energy per length', 'energy per mass', 'energy per mass per time', 'energy per volume', 'force', 'force area', 'force length per length', 'force per force', 'force per length', 'force per volume', 'frequency', 'frequency interval', 'heat capacity', 'heat flow rate', 'heat transfer coefficient', 'illuminance', 'inductance', 'isothermal compressibility', 'kinematic viscosity', 'length', 'length per length', 'length per mass', 'length per pressure', 'length per temperature', 'length per time', 'length per volume', 'light exposure', 'linear acceleration', 'linear thermal expansion', 'logarithmic power ratio', 'logarithmic power ratio per length', 'luminance', 'luminous efficacy', 'luminous flux', 'luminous intensity', 'magnetic dipole moment', 'magnetic field strength', 'magnetic flux', 'magnetic flux density', 'magnetic flux density per length', 'magnetic permeability', 'magnetic vector potential', 'mass', 'mass length', 'mass per area', 'mass per energy', 'mass per length', 'mass per mass', 'mass per time', 'mass per time per area', 'mass per time per length', 'mass per volume', 'mass per volume per length', 'mass per volume per pressure', 'mass per volume per temperature', 'mobility', 'molar energy', 'molar heat capacity', 'molar volume', 'molecular weight', 'moment of force', 'moment of inertia', 'momentum', 'normalized power', 'permeability length', 'permeability rock', 'permittivity', 'plane angle', 'potential difference per power drop', 'power', 'power per area', 'power per power', 'power per volume', 'pressure', 'pressure per pressure', 'pressure per time', 'pressure per volume', 'pressure squared', 'pressure squared per force time per area', 'pressure time per volume', 'quantity of light', 'radiance', 'radiant intensity', 'reciprocal area', 'reciprocal electric potential difference', 'reciprocal force', 'reciprocal length', 'reciprocal mass', 'reciprocal mass time', 'reciprocal pressure', 'reciprocal time', 'reciprocal volume', 'reluctance', 'second moment of area', 'signaling event per time', 'solid angle', 'specific heat capacity', 'temperature interval', 'temperature interval per length', 'temperature interval per pressure', 'temperature interval per time', 'thermal conductance', 'thermal conductivity', 'thermal diffusivity', 'thermal insulance', 'thermal resistance', 'thermodynamic temperature', 'thermodynamic temperature per thermodynamic temperature', 'time', 'time per length', 'time per mass', 'time per time', 'time per volume', 'vertical coordinate', 'volume', 'volume flow rate per volume flow rate', 'volume per area', 'volume per length', 'volume per mass', 'volume per pressure', 'volume per rotation', 'volume per time', 'volume per time length', 'volume per time per area', 'volume per time per length', 'volume per time per pressure', 'volume per time per pressure length', 'volume per time per time', 'volume per time per volume', 'volume per volume', 'volumetric heat transfer coefficient', 'volumetric thermal expansion', 'unitless']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureClass' % {"value" : value.encode("utf-8")} )
    def validate_UomEnum(self, value):
        # Validate type UomEnum, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 32:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on UomEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Order is not None or
            self.Parameter is not None or
            self.IsIndex is not None or
            self.MeasureClass is not None or
            self.Unit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CurveDefinition', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurveDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CurveDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CurveDefinition'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CurveDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Order is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrder>%s</%sOrder>%s' % (namespace_, self.gds_format_integer(self.Order, input_name='Order'), namespace_, eol_))
        if self.Parameter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sParameter>%s</%sParameter>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Parameter), input_name='Parameter')), namespace_, eol_))
        if self.IsIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsIndex>%s</%sIsIndex>%s' % (namespace_, self.gds_format_boolean(self.IsIndex, input_name='IsIndex'), namespace_, eol_))
        if self.MeasureClass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureClass>%s</%sMeasureClass>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MeasureClass), input_name='MeasureClass')), namespace_, eol_))
        if self.Unit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnit>%s</%sUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unit), input_name='Unit')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Order':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Order')
            self.Order = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.Order)
        elif nodeName_ == 'Parameter':
            Parameter_ = child_.text
            Parameter_ = self.gds_validate_string(Parameter_, node, 'Parameter')
            self.Parameter = Parameter_
            # validate type String64
            self.validate_String64(self.Parameter)
        elif nodeName_ == 'IsIndex':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsIndex')
            self.IsIndex = ival_
        elif nodeName_ == 'MeasureClass':
            MeasureClass_ = child_.text
            MeasureClass_ = self.gds_validate_string(MeasureClass_, node, 'MeasureClass')
            self.MeasureClass = MeasureClass_
            # validate type MeasureClass
            self.validate_MeasureClass(self.MeasureClass)
        elif nodeName_ == 'Unit':
            Unit_ = child_.text
            Unit_ = self.gds_validate_string(Unit_, node, 'Unit')
            self.Unit = Unit_
            # validate type UomEnum
            self.validate_UomEnum(self.Unit)
# end class CurveDefinition


class FacilityParent(AbstractRelatedFacilityObject):
    """Facility parent."""
    subclass = None
    superclass = AbstractRelatedFacilityObject
    def __init__(self, FacilityParent=None, Name=None, FacilityParent1=None, FacilityParent2=None):
        self.original_tagname_ = None
        super(FacilityParent, self).__init__(FacilityParent, )
        self.Name = Name
        self.FacilityParent1 = FacilityParent1
        self.FacilityParent2 = FacilityParent2
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FacilityParent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FacilityParent.subclass:
            return FacilityParent.subclass(*args_, **kwargs_)
        else:
            return FacilityParent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_FacilityParent1(self): return self.FacilityParent1
    def set_FacilityParent1(self, FacilityParent1): self.FacilityParent1 = FacilityParent1
    FacilityParent1Prop = property(get_FacilityParent1, set_FacilityParent1)
    def get_FacilityParent2(self): return self.FacilityParent2
    def set_FacilityParent2(self, FacilityParent2): self.FacilityParent2 = FacilityParent2
    FacilityParent2Prop = property(get_FacilityParent2, set_FacilityParent2)
    def hasContent_(self):
        if (
            self.Name is not None or
            self.FacilityParent1 is not None or
            self.FacilityParent2 is not None or
            super(FacilityParent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FacilityParent', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FacilityParent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FacilityParent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FacilityParent'):
        super(FacilityParent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FacilityParent')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FacilityParent', fromsubclass_=False, pretty_print=True):
        super(FacilityParent, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            self.Name.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        if self.FacilityParent1 is not None:
            self.FacilityParent1.export(outfile, level, namespace_, name_='FacilityParent1', pretty_print=pretty_print)
        if self.FacilityParent2 is not None:
            self.FacilityParent2.export(outfile, level, namespace_, name_='FacilityParent2', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FacilityParent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'FacilityParent1':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.FacilityParent1 = obj_
            obj_.original_tagname_ = 'FacilityParent1'
        elif nodeName_ == 'FacilityParent2':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.FacilityParent2 = obj_
            obj_.original_tagname_ = 'FacilityParent2'
        super(FacilityParent, self).buildChildren(child_, node, nodeName_, True)
# end class FacilityParent


class FacilityUnitPort(AbstractRelatedFacilityObject):
    """Facility unit port."""
    subclass = None
    superclass = AbstractRelatedFacilityObject
    def __init__(self, FacilityParent=None, PortReference=None, UnitReference=None, NetworkReference=None):
        self.original_tagname_ = None
        super(FacilityUnitPort, self).__init__(FacilityParent, )
        self.PortReference = PortReference
        self.validate_String64(self.PortReference)
        self.UnitReference = UnitReference
        self.validate_String64(self.UnitReference)
        self.NetworkReference = NetworkReference
        self.validate_String64(self.NetworkReference)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FacilityUnitPort)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FacilityUnitPort.subclass:
            return FacilityUnitPort.subclass(*args_, **kwargs_)
        else:
            return FacilityUnitPort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PortReference(self): return self.PortReference
    def set_PortReference(self, PortReference): self.PortReference = PortReference
    PortReferenceProp = property(get_PortReference, set_PortReference)
    def get_UnitReference(self): return self.UnitReference
    def set_UnitReference(self, UnitReference): self.UnitReference = UnitReference
    UnitReferenceProp = property(get_UnitReference, set_UnitReference)
    def get_NetworkReference(self): return self.NetworkReference
    def set_NetworkReference(self, NetworkReference): self.NetworkReference = NetworkReference
    NetworkReferenceProp = property(get_NetworkReference, set_NetworkReference)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.PortReference is not None or
            self.UnitReference is not None or
            self.NetworkReference is not None or
            super(FacilityUnitPort, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FacilityUnitPort', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FacilityUnitPort')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FacilityUnitPort', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FacilityUnitPort'):
        super(FacilityUnitPort, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FacilityUnitPort')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FacilityUnitPort', fromsubclass_=False, pretty_print=True):
        super(FacilityUnitPort, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PortReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPortReference>%s</%sPortReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PortReference), input_name='PortReference')), namespace_, eol_))
        if self.UnitReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitReference>%s</%sUnitReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UnitReference), input_name='UnitReference')), namespace_, eol_))
        if self.NetworkReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetworkReference>%s</%sNetworkReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.NetworkReference), input_name='NetworkReference')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FacilityUnitPort, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PortReference':
            PortReference_ = child_.text
            PortReference_ = self.gds_validate_string(PortReference_, node, 'PortReference')
            self.PortReference = PortReference_
            # validate type String64
            self.validate_String64(self.PortReference)
        elif nodeName_ == 'UnitReference':
            UnitReference_ = child_.text
            UnitReference_ = self.gds_validate_string(UnitReference_, node, 'UnitReference')
            self.UnitReference = UnitReference_
            # validate type String64
            self.validate_String64(self.UnitReference)
        elif nodeName_ == 'NetworkReference':
            NetworkReference_ = child_.text
            NetworkReference_ = self.gds_validate_string(NetworkReference_, node, 'NetworkReference')
            self.NetworkReference = NetworkReference_
            # validate type String64
            self.validate_String64(self.NetworkReference)
        super(FacilityUnitPort, self).buildChildren(child_, node, nodeName_, True)
# end class FacilityUnitPort


class IntegerData(AbstractMeasureDataType):
    """Integer data."""
    subclass = None
    superclass = AbstractMeasureDataType
    def __init__(self, IntegerValue=None):
        self.original_tagname_ = None
        super(IntegerData, self).__init__()
        self.IntegerValue = IntegerValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntegerData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntegerData.subclass:
            return IntegerData.subclass(*args_, **kwargs_)
        else:
            return IntegerData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IntegerValue(self): return self.IntegerValue
    def set_IntegerValue(self, IntegerValue): self.IntegerValue = IntegerValue
    IntegerValueProp = property(get_IntegerValue, set_IntegerValue)
    def hasContent_(self):
        if (
            self.IntegerValue is not None or
            super(IntegerData, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='IntegerData', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='IntegerData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='IntegerData'):
        super(IntegerData, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerData')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='IntegerData', fromsubclass_=False, pretty_print=True):
        super(IntegerData, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IntegerValue is not None:
            self.IntegerValue.export(outfile, level, namespace_, name_='IntegerValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IntegerData, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IntegerValue':
            obj_ = IntegerQualifiedCount.factory()
            obj_.build(child_)
            self.IntegerValue = obj_
            obj_.original_tagname_ = 'IntegerValue'
        super(IntegerData, self).buildChildren(child_, node, nodeName_, True)
# end class IntegerData


class OwnershipBusinessAcct(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OwnershipBusinessAcct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OwnershipBusinessAcct.subclass:
            return OwnershipBusinessAcct.subclass(*args_, **kwargs_)
        else:
            return OwnershipBusinessAcct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='OwnershipBusinessAcct', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OwnershipBusinessAcct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='OwnershipBusinessAcct', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='OwnershipBusinessAcct'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='OwnershipBusinessAcct', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OwnershipBusinessAcct


class Parentfacility(AbstractRefProductFlow):
    """Parent facility."""
    subclass = None
    superclass = AbstractRefProductFlow
    def __init__(self, ParentfacilityReference=None):
        self.original_tagname_ = None
        super(Parentfacility, self).__init__()
        self.ParentfacilityReference = ParentfacilityReference
        self.validate_String64(self.ParentfacilityReference)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Parentfacility)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Parentfacility.subclass:
            return Parentfacility.subclass(*args_, **kwargs_)
        else:
            return Parentfacility(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ParentfacilityReference(self): return self.ParentfacilityReference
    def set_ParentfacilityReference(self, ParentfacilityReference): self.ParentfacilityReference = ParentfacilityReference
    ParentfacilityReferenceProp = property(get_ParentfacilityReference, set_ParentfacilityReference)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.ParentfacilityReference is not None or
            super(Parentfacility, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='Parentfacility', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Parentfacility')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='Parentfacility', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='Parentfacility'):
        super(Parentfacility, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Parentfacility')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='Parentfacility', fromsubclass_=False, pretty_print=True):
        super(Parentfacility, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ParentfacilityReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sParentfacilityReference>%s</%sParentfacilityReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ParentfacilityReference), input_name='ParentfacilityReference')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Parentfacility, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ParentfacilityReference':
            ParentfacilityReference_ = child_.text
            ParentfacilityReference_ = self.gds_validate_string(ParentfacilityReference_, node, 'ParentfacilityReference')
            self.ParentfacilityReference = ParentfacilityReference_
            # validate type String64
            self.validate_String64(self.ParentfacilityReference)
        super(Parentfacility, self).buildChildren(child_, node, nodeName_, True)
# end class Parentfacility


class ProductVolumeAlert(GeneratedsSuper):
    """Alert Schema."""
    subclass = None
    superclass = None
    def __init__(self, Target=None, Level=None, Type=None, Description=None):
        self.original_tagname_ = None
        self.Target = Target
        self.validate_String2000(self.Target)
        self.Level = Level
        self.validate_String64(self.Level)
        self.Type = Type
        self.validate_String64(self.Type)
        self.Description = Description
        self.validate_String2000(self.Description)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumeAlert)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumeAlert.subclass:
            return ProductVolumeAlert.subclass(*args_, **kwargs_)
        else:
            return ProductVolumeAlert(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Target(self): return self.Target
    def set_Target(self, Target): self.Target = Target
    TargetProp = property(get_Target, set_Target)
    def get_Level(self): return self.Level
    def set_Level(self, Level): self.Level = Level
    LevelProp = property(get_Level, set_Level)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    TypeProp = property(get_Type, set_Type)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    DescriptionProp = property(get_Description, set_Description)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Target is not None or
            self.Level is not None or
            self.Type is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumeAlert', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumeAlert')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumeAlert', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumeAlert'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumeAlert', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Target is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTarget>%s</%sTarget>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Target), input_name='Target')), namespace_, eol_))
        if self.Level is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLevel>%s</%sLevel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Level), input_name='Level')), namespace_, eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sType>%s</%sType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Target':
            Target_ = child_.text
            Target_ = self.gds_validate_string(Target_, node, 'Target')
            self.Target = Target_
            # validate type String2000
            self.validate_String2000(self.Target)
        elif nodeName_ == 'Level':
            Level_ = child_.text
            Level_ = self.gds_validate_string(Level_, node, 'Level')
            self.Level = Level_
            # validate type String64
            self.validate_String64(self.Level)
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type String64
            self.validate_String64(self.Type)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            # validate type String2000
            self.validate_String2000(self.Description)
# end class ProductVolumeAlert


class ProductVolumeBalanceDetail(GeneratedsSuper):
    """Product Volume Balance Detail Schema.A unique identifier for this
    data element. It is not globally unique (not a uuid) and only
    need be unique within the context of the parent top-level
    object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Owner=None, SourceUnit=None, Share=None, AccountNumber=None, SampleAnalysisResult=None, ComponentContent=None, Event=None, VolumeValue=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Owner = Owner
        self.validate_String64(self.Owner)
        self.SourceUnit = SourceUnit
        self.validate_String64(self.SourceUnit)
        self.Share = Share
        self.AccountNumber = AccountNumber
        self.validate_String64(self.AccountNumber)
        if SampleAnalysisResult is None:
            self.SampleAnalysisResult = []
        else:
            self.SampleAnalysisResult = SampleAnalysisResult
        if ComponentContent is None:
            self.ComponentContent = []
        else:
            self.ComponentContent = ComponentContent
        if Event is None:
            self.Event = []
        else:
            self.Event = Event
        if VolumeValue is None:
            self.VolumeValue = []
        else:
            self.VolumeValue = VolumeValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumeBalanceDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumeBalanceDetail.subclass:
            return ProductVolumeBalanceDetail.subclass(*args_, **kwargs_)
        else:
            return ProductVolumeBalanceDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Owner(self): return self.Owner
    def set_Owner(self, Owner): self.Owner = Owner
    OwnerProp = property(get_Owner, set_Owner)
    def get_SourceUnit(self): return self.SourceUnit
    def set_SourceUnit(self, SourceUnit): self.SourceUnit = SourceUnit
    SourceUnitProp = property(get_SourceUnit, set_SourceUnit)
    def get_Share(self): return self.Share
    def set_Share(self, Share): self.Share = Share
    ShareProp = property(get_Share, set_Share)
    def get_AccountNumber(self): return self.AccountNumber
    def set_AccountNumber(self, AccountNumber): self.AccountNumber = AccountNumber
    AccountNumberProp = property(get_AccountNumber, set_AccountNumber)
    def get_SampleAnalysisResult(self): return self.SampleAnalysisResult
    def set_SampleAnalysisResult(self, SampleAnalysisResult): self.SampleAnalysisResult = SampleAnalysisResult
    def add_SampleAnalysisResult(self, value): self.SampleAnalysisResult.append(value)
    def insert_SampleAnalysisResult_at(self, index, value): self.SampleAnalysisResult.insert(index, value)
    def replace_SampleAnalysisResult_at(self, index, value): self.SampleAnalysisResult[index] = value
    SampleAnalysisResultProp = property(get_SampleAnalysisResult, set_SampleAnalysisResult)
    def get_ComponentContent(self): return self.ComponentContent
    def set_ComponentContent(self, ComponentContent): self.ComponentContent = ComponentContent
    def add_ComponentContent(self, value): self.ComponentContent.append(value)
    def insert_ComponentContent_at(self, index, value): self.ComponentContent.insert(index, value)
    def replace_ComponentContent_at(self, index, value): self.ComponentContent[index] = value
    ComponentContentProp = property(get_ComponentContent, set_ComponentContent)
    def get_Event(self): return self.Event
    def set_Event(self, Event): self.Event = Event
    def add_Event(self, value): self.Event.append(value)
    def insert_Event_at(self, index, value): self.Event.insert(index, value)
    def replace_Event_at(self, index, value): self.Event[index] = value
    EventProp = property(get_Event, set_Event)
    def get_VolumeValue(self): return self.VolumeValue
    def set_VolumeValue(self, VolumeValue): self.VolumeValue = VolumeValue
    def add_VolumeValue(self, value): self.VolumeValue.append(value)
    def insert_VolumeValue_at(self, index, value): self.VolumeValue.insert(index, value)
    def replace_VolumeValue_at(self, index, value): self.VolumeValue[index] = value
    VolumeValueProp = property(get_VolumeValue, set_VolumeValue)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Owner is not None or
            self.SourceUnit is not None or
            self.Share is not None or
            self.AccountNumber is not None or
            self.SampleAnalysisResult or
            self.ComponentContent or
            self.Event or
            self.VolumeValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumeBalanceDetail', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumeBalanceDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumeBalanceDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumeBalanceDetail'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumeBalanceDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Owner is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOwner>%s</%sOwner>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Owner), input_name='Owner')), namespace_, eol_))
        if self.SourceUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourceUnit>%s</%sSourceUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SourceUnit), input_name='SourceUnit')), namespace_, eol_))
        if self.Share is not None:
            self.Share.export(outfile, level, namespace_, name_='Share', pretty_print=pretty_print)
        if self.AccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccountNumber>%s</%sAccountNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AccountNumber), input_name='AccountNumber')), namespace_, eol_))
        for SampleAnalysisResult_ in self.SampleAnalysisResult:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSampleAnalysisResult>%s</%sSampleAnalysisResult>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(SampleAnalysisResult_), input_name='SampleAnalysisResult')), namespace_, eol_))
        for ComponentContent_ in self.ComponentContent:
            ComponentContent_.export(outfile, level, namespace_, name_='ComponentContent', pretty_print=pretty_print)
        for Event_ in self.Event:
            Event_.export(outfile, level, namespace_, name_='Event', pretty_print=pretty_print)
        for VolumeValue_ in self.VolumeValue:
            VolumeValue_.export(outfile, level, namespace_, name_='VolumeValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Owner':
            Owner_ = child_.text
            Owner_ = self.gds_validate_string(Owner_, node, 'Owner')
            self.Owner = Owner_
            # validate type String64
            self.validate_String64(self.Owner)
        elif nodeName_ == 'SourceUnit':
            SourceUnit_ = child_.text
            SourceUnit_ = self.gds_validate_string(SourceUnit_, node, 'SourceUnit')
            self.SourceUnit = SourceUnit_
            # validate type String64
            self.validate_String64(self.SourceUnit)
        elif nodeName_ == 'Share':
            obj_ = VolumePerVolumeMeasure.factory()
            obj_.build(child_)
            self.Share = obj_
            obj_.original_tagname_ = 'Share'
        elif nodeName_ == 'AccountNumber':
            AccountNumber_ = child_.text
            AccountNumber_ = self.gds_validate_string(AccountNumber_, node, 'AccountNumber')
            self.AccountNumber = AccountNumber_
            # validate type String64
            self.validate_String64(self.AccountNumber)
        elif nodeName_ == 'SampleAnalysisResult':
            SampleAnalysisResult_ = child_.text
            SampleAnalysisResult_ = self.gds_validate_string(SampleAnalysisResult_, node, 'SampleAnalysisResult')
            self.SampleAnalysisResult.append(SampleAnalysisResult_)
            # validate type String64
            self.validate_String64(self.SampleAnalysisResult[-1])
        elif nodeName_ == 'ComponentContent':
            obj_ = ProductVolumeComponentContent.factory()
            obj_.build(child_)
            self.ComponentContent.append(obj_)
            obj_.original_tagname_ = 'ComponentContent'
        elif nodeName_ == 'Event':
            obj_ = ProductVolumeBalanceEvent.factory()
            obj_.build(child_)
            self.Event.append(obj_)
            obj_.original_tagname_ = 'Event'
        elif nodeName_ == 'VolumeValue':
            obj_ = VolumeValue.factory()
            obj_.build(child_)
            self.VolumeValue.append(obj_)
            obj_.original_tagname_ = 'VolumeValue'
# end class ProductVolumeBalanceDetail


class ProductVolumeBalanceEvent(GeneratedsSuper):
    """Captures information about an event related to a product balance.A
    unique identifier for this data element. It is not globally
    unique (not a uuid) and only need be unique within the context
    of the parent top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Date=None, Kind=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        if isinstance(Date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Date
        self.Date = initvalue_
        self.Kind = Kind
        self.validate_BalanceEventKind(self.Kind)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumeBalanceEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumeBalanceEvent.subclass:
            return ProductVolumeBalanceEvent.subclass(*args_, **kwargs_)
        else:
            return ProductVolumeBalanceEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    DateProp = property(get_Date, set_Date)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    KindProp = property(get_Kind, set_Kind)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_BalanceEventKind(self, value):
        # Validate type BalanceEventKind, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['bill of lading', 'transaction date', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BalanceEventKind' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Date is not None or
            self.Kind is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumeBalanceEvent', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumeBalanceEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumeBalanceEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumeBalanceEvent'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumeBalanceEvent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDate>%s</%sDate>%s' % (namespace_, self.gds_format_date(self.Date, input_name='Date'), namespace_, eol_))
        if self.Kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKind>%s</%sKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Kind), input_name='Kind')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Date = dval_
        elif nodeName_ == 'Kind':
            Kind_ = child_.text
            Kind_ = self.gds_validate_string(Kind_, node, 'Kind')
            self.Kind = Kind_
            # validate type BalanceEventKind
            self.validate_BalanceEventKind(self.Kind)
# end class ProductVolumeBalanceEvent


class ProductVolumeBalanceSet(GeneratedsSuper):
    """Product Flow Balance Set Schema.A unique identifier for this data
    element. It is not globally unique (not a uuid) and only need be
    unique within the context of the parent top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Kind=None, CargoNumber=None, CargoBatchNumber=None, Shipper=None, BalanceDetail=None, Destination=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Kind = Kind
        self.validate_BalanceFlowPart(self.Kind)
        self.CargoNumber = CargoNumber
        self.validate_String64(self.CargoNumber)
        self.CargoBatchNumber = CargoBatchNumber
        self.Shipper = Shipper
        self.validate_String64(self.Shipper)
        if BalanceDetail is None:
            self.BalanceDetail = []
        else:
            self.BalanceDetail = BalanceDetail
        self.Destination = Destination
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumeBalanceSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumeBalanceSet.subclass:
            return ProductVolumeBalanceSet.subclass(*args_, **kwargs_)
        else:
            return ProductVolumeBalanceSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    KindProp = property(get_Kind, set_Kind)
    def get_CargoNumber(self): return self.CargoNumber
    def set_CargoNumber(self, CargoNumber): self.CargoNumber = CargoNumber
    CargoNumberProp = property(get_CargoNumber, set_CargoNumber)
    def get_CargoBatchNumber(self): return self.CargoBatchNumber
    def set_CargoBatchNumber(self, CargoBatchNumber): self.CargoBatchNumber = CargoBatchNumber
    CargoBatchNumberProp = property(get_CargoBatchNumber, set_CargoBatchNumber)
    def get_Shipper(self): return self.Shipper
    def set_Shipper(self, Shipper): self.Shipper = Shipper
    ShipperProp = property(get_Shipper, set_Shipper)
    def get_BalanceDetail(self): return self.BalanceDetail
    def set_BalanceDetail(self, BalanceDetail): self.BalanceDetail = BalanceDetail
    def add_BalanceDetail(self, value): self.BalanceDetail.append(value)
    def insert_BalanceDetail_at(self, index, value): self.BalanceDetail.insert(index, value)
    def replace_BalanceDetail_at(self, index, value): self.BalanceDetail[index] = value
    BalanceDetailProp = property(get_BalanceDetail, set_BalanceDetail)
    def get_Destination(self): return self.Destination
    def set_Destination(self, Destination): self.Destination = Destination
    DestinationProp = property(get_Destination, set_Destination)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_BalanceFlowPart(self, value):
        # Validate type BalanceFlowPart, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['adjusted closing', 'closing balance', 'closing storage inventory', 'completed lifting', 'gain/loss', 'input to storage', 'lifted', 'lifting entitlement', 'lifting entitlement remaining', 'linepack', 'opening balance', 'opflex', 'partial lifting', 'pipeline lifting', 'production - mass adjustment', 'production -- value adjustment', 'production imbalance', 'swap', 'tanker lifting', 'transaction', 'transfer', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BalanceFlowPart' % {"value" : value.encode("utf-8")} )
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Kind is not None or
            self.CargoNumber is not None or
            self.CargoBatchNumber is not None or
            self.Shipper is not None or
            self.BalanceDetail or
            self.Destination is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumeBalanceSet', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumeBalanceSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumeBalanceSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumeBalanceSet'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumeBalanceSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKind>%s</%sKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Kind), input_name='Kind')), namespace_, eol_))
        if self.CargoNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCargoNumber>%s</%sCargoNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CargoNumber), input_name='CargoNumber')), namespace_, eol_))
        if self.CargoBatchNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCargoBatchNumber>%s</%sCargoBatchNumber>%s' % (namespace_, self.gds_format_integer(self.CargoBatchNumber, input_name='CargoBatchNumber'), namespace_, eol_))
        if self.Shipper is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sShipper>%s</%sShipper>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Shipper), input_name='Shipper')), namespace_, eol_))
        for BalanceDetail_ in self.BalanceDetail:
            BalanceDetail_.export(outfile, level, namespace_, name_='BalanceDetail', pretty_print=pretty_print)
        if self.Destination is not None:
            self.Destination.export(outfile, level, namespace_, name_='Destination', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Kind':
            Kind_ = child_.text
            Kind_ = self.gds_validate_string(Kind_, node, 'Kind')
            self.Kind = Kind_
            # validate type BalanceFlowPart
            self.validate_BalanceFlowPart(self.Kind)
        elif nodeName_ == 'CargoNumber':
            CargoNumber_ = child_.text
            CargoNumber_ = self.gds_validate_string(CargoNumber_, node, 'CargoNumber')
            self.CargoNumber = CargoNumber_
            # validate type String64
            self.validate_String64(self.CargoNumber)
        elif nodeName_ == 'CargoBatchNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'CargoBatchNumber')
            self.CargoBatchNumber = ival_
        elif nodeName_ == 'Shipper':
            Shipper_ = child_.text
            Shipper_ = self.gds_validate_string(Shipper_, node, 'Shipper')
            self.Shipper = Shipper_
            # validate type String64
            self.validate_String64(self.Shipper)
        elif nodeName_ == 'BalanceDetail':
            obj_ = ProductVolumeBalanceDetail.factory()
            obj_.build(child_)
            self.BalanceDetail.append(obj_)
            obj_.original_tagname_ = 'BalanceDetail'
        elif nodeName_ == 'Destination':
            obj_ = ProductVolumeDestination.factory()
            obj_.build(child_)
            self.Destination = obj_
            obj_.original_tagname_ = 'Destination'
# end class ProductVolumeBalanceSet


class ProductVolumeBusinessSubUnit(GeneratedsSuper):
    """Product volume schema for defining ownership shares of business
    units.A unique identifier for this data element. It is not
    globally unique (not a uuid) and only need be unique within the
    context of the parent top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Kind=None, OwnershipBusinessAcct=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Kind = Kind
        self.validate_String64(self.Kind)
        self.OwnershipBusinessAcct = OwnershipBusinessAcct
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumeBusinessSubUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumeBusinessSubUnit.subclass:
            return ProductVolumeBusinessSubUnit.subclass(*args_, **kwargs_)
        else:
            return ProductVolumeBusinessSubUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    KindProp = property(get_Kind, set_Kind)
    def get_OwnershipBusinessAcct(self): return self.OwnershipBusinessAcct
    def set_OwnershipBusinessAcct(self, OwnershipBusinessAcct): self.OwnershipBusinessAcct = OwnershipBusinessAcct
    OwnershipBusinessAcctProp = property(get_OwnershipBusinessAcct, set_OwnershipBusinessAcct)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Kind is not None or
            self.OwnershipBusinessAcct is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumeBusinessSubUnit', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumeBusinessSubUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumeBusinessSubUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumeBusinessSubUnit'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumeBusinessSubUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKind>%s</%sKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Kind), input_name='Kind')), namespace_, eol_))
        if self.OwnershipBusinessAcct is not None:
            self.OwnershipBusinessAcct.export(outfile, level, namespace_, name_='OwnershipBusinessAcct', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Kind':
            Kind_ = child_.text
            Kind_ = self.gds_validate_string(Kind_, node, 'Kind')
            self.Kind = Kind_
            # validate type String64
            self.validate_String64(self.Kind)
        elif nodeName_ == 'OwnershipBusinessAcct':
            obj_ = OwnershipBusinessAcct.factory()
            obj_.build(child_)
            self.OwnershipBusinessAcct = obj_
            obj_.original_tagname_ = 'OwnershipBusinessAcct'
# end class ProductVolumeBusinessSubUnit


class ProductVolumeBusinessUnit(GeneratedsSuper):
    """Product volume schema for defining business units.A unique
    identifier for this data element. It is not globally unique (not
    a uuid) and only need be unique within the context of the parent
    top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Kind=None, Name=None, Description=None, SubUnit=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Kind = Kind
        self.validate_BusinessUnitKind(self.Kind)
        self.Name = Name
        self.validate_String64(self.Name)
        self.Description = Description
        self.validate_String2000(self.Description)
        if SubUnit is None:
            self.SubUnit = []
        else:
            self.SubUnit = SubUnit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumeBusinessUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumeBusinessUnit.subclass:
            return ProductVolumeBusinessUnit.subclass(*args_, **kwargs_)
        else:
            return ProductVolumeBusinessUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    KindProp = property(get_Kind, set_Kind)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    DescriptionProp = property(get_Description, set_Description)
    def get_SubUnit(self): return self.SubUnit
    def set_SubUnit(self, SubUnit): self.SubUnit = SubUnit
    def add_SubUnit(self, value): self.SubUnit.append(value)
    def insert_SubUnit_at(self, index, value): self.SubUnit.insert(index, value)
    def replace_SubUnit_at(self, index, value): self.SubUnit[index] = value
    SubUnitProp = property(get_SubUnit, set_SubUnit)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_BusinessUnitKind(self, value):
        # Validate type BusinessUnitKind, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['businessarea', 'company', 'field', 'license', 'platform', 'terminal', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessUnitKind' % {"value" : value.encode("utf-8")} )
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Kind is not None or
            self.Name is not None or
            self.Description is not None or
            self.SubUnit
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumeBusinessUnit', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumeBusinessUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumeBusinessUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumeBusinessUnit'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumeBusinessUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKind>%s</%sKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Kind), input_name='Kind')), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), namespace_, eol_))
        for SubUnit_ in self.SubUnit:
            SubUnit_.export(outfile, level, namespace_, name_='SubUnit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Kind':
            Kind_ = child_.text
            Kind_ = self.gds_validate_string(Kind_, node, 'Kind')
            self.Kind = Kind_
            # validate type BusinessUnitKind
            self.validate_BusinessUnitKind(self.Kind)
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            # validate type String2000
            self.validate_String2000(self.Description)
        elif nodeName_ == 'SubUnit':
            obj_ = ProductVolumeBusinessSubUnit.factory()
            obj_.build(child_)
            self.SubUnit.append(obj_)
            obj_.original_tagname_ = 'SubUnit'
# end class ProductVolumeBusinessUnit


class ProductVolumeComponentContent(GeneratedsSuper):
    """Product Volume Component Content Schema.A unique identifier for this
    data element. It is not globally unique (not a uuid) and only
    need be unique within the context of the parent top-level
    object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Kind=None, ReferenceKind=None, Properties=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Kind = Kind
        self.validate_ReportingProduct(self.Kind)
        self.ReferenceKind = ReferenceKind
        self.validate_ReportingProduct(self.ReferenceKind)
        self.Properties = Properties
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumeComponentContent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumeComponentContent.subclass:
            return ProductVolumeComponentContent.subclass(*args_, **kwargs_)
        else:
            return ProductVolumeComponentContent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    KindProp = property(get_Kind, set_Kind)
    def get_ReferenceKind(self): return self.ReferenceKind
    def set_ReferenceKind(self, ReferenceKind): self.ReferenceKind = ReferenceKind
    ReferenceKindProp = property(get_ReferenceKind, set_ReferenceKind)
    def get_Properties(self): return self.Properties
    def set_Properties(self, Properties): self.Properties = Properties
    PropertiesProp = property(get_Properties, set_Properties)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_ReportingProduct(self, value):
        # Validate type ReportingProduct, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['aqueous', 'c10', 'c10-', 'c10+', 'c2-', 'c2+', 'c3-', 'c3+', 'c4-', 'c4+', 'c5-', 'c5+', 'c6-', 'c6+', 'c7', 'c7-', 'c7+', 'c8', 'c8-', 'c8+', 'c9', 'c9-', 'c9+', 'carbon dioxide gas', 'carbon monoxide gas', 'chemical', 'condensate', 'condensate - gross', 'condensate - net', 'crude - stabilized', 'cuttings', 'diesel', 'diethylene glycol', 'dioxygen', 'electric power', 'ethane', 'ethane - component', 'gas', 'gas - component in oil', 'gas - dry', 'gas - rich', 'gas - wet', 'helium gas', 'heptane', 'hydraulic control fluid', 'hydrogen gas', 'hydrogen sulfide', 'i-butane - component', 'isobutane', 'isopentane', 'liquefied natural gas', 'liquefied petroleum gas', 'liquid', 'methane', 'methane - component', 'methanol', 'mixed butane', 'monoethylene glycol', 'naphtha', 'natural gas liquid', 'n-butane - component', 'neopentane', 'NGL - component in gas', 'nitrogen gas', 'nitrogen oxide gas', 'normal butane', 'normal pentane', 'oil', 'oil - component in water', 'oil - gross', 'oil - net', 'oil and gas', 'oleic', 'pentane - component', 'petroleum gas liquid', 'propane', 'propane - component', 'salt', 'sand - component', 'triethylene glycol', 'unknown', 'vapor', 'water', 'water - discharge', 'water - processed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReportingProduct' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Kind is not None or
            self.ReferenceKind is not None or
            self.Properties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumeComponentContent', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumeComponentContent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumeComponentContent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumeComponentContent'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumeComponentContent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKind>%s</%sKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Kind), input_name='Kind')), namespace_, eol_))
        if self.ReferenceKind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReferenceKind>%s</%sReferenceKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ReferenceKind), input_name='ReferenceKind')), namespace_, eol_))
        if self.Properties is not None:
            self.Properties.export(outfile, level, namespace_, name_='Properties', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Kind':
            Kind_ = child_.text
            Kind_ = self.gds_validate_string(Kind_, node, 'Kind')
            self.Kind = Kind_
            # validate type ReportingProduct
            self.validate_ReportingProduct(self.Kind)
        elif nodeName_ == 'ReferenceKind':
            ReferenceKind_ = child_.text
            ReferenceKind_ = self.gds_validate_string(ReferenceKind_, node, 'ReferenceKind')
            self.ReferenceKind = ReferenceKind_
            # validate type ReportingProduct
            self.validate_ReportingProduct(self.ReferenceKind)
        elif nodeName_ == 'Properties':
            obj_ = CommonPropertiesProductVolume.factory()
            obj_.build(child_)
            self.Properties = obj_
            obj_.original_tagname_ = 'Properties'
# end class ProductVolumeComponentContent


class ProductVolumeDestination(GeneratedsSuper):
    """Product Flow Sales Destination Schema."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, Type=None, Country=None):
        self.original_tagname_ = None
        self.Name = Name
        self.validate_String64(self.Name)
        self.Type = Type
        self.validate_BalanceDestinationType(self.Type)
        self.Country = Country
        self.validate_String64(self.Country)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumeDestination)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumeDestination.subclass:
            return ProductVolumeDestination.subclass(*args_, **kwargs_)
        else:
            return ProductVolumeDestination(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    TypeProp = property(get_Type, set_Type)
    def get_Country(self): return self.Country
    def set_Country(self, Country): self.Country = Country
    CountryProp = property(get_Country, set_Country)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_BalanceDestinationType(self, value):
        # Validate type BalanceDestinationType, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['harbor', 'terminal', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BalanceDestinationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Type is not None or
            self.Country is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumeDestination', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumeDestination')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumeDestination', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumeDestination'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumeDestination', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sType>%s</%sType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), namespace_, eol_))
        if self.Country is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCountry>%s</%sCountry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Country), input_name='Country')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type BalanceDestinationType
            self.validate_BalanceDestinationType(self.Type)
        elif nodeName_ == 'Country':
            Country_ = child_.text
            Country_ = self.gds_validate_string(Country_, node, 'Country')
            self.Country = Country_
            # validate type String64
            self.validate_String64(self.Country)
# end class ProductVolumeDestination


class ProductVolumeFacility(GeneratedsSuper):
    """Report Facility Schema.A unique identifier for this data element. It
    is not globally unique (not a uuid) and only need be unique
    within the context of the parent top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, FacilityParent=None, FacilityParent2=None, FacilityAlias=None, Unit=None, NetWork=None, Name=None, StatusWell=None, FluidWell=None, OperatingMethod=None, WellProducing=None, WellInjecting=None, Capacity=None, OperationTime=None, Flow=None, ParameterSet=None, DowntimeReason=None, Comment=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.FacilityParent = FacilityParent
        self.FacilityParent2 = FacilityParent2
        if FacilityAlias is None:
            self.FacilityAlias = []
        else:
            self.FacilityAlias = FacilityAlias
        self.Unit = Unit
        self.validate_String64(self.Unit)
        self.NetWork = NetWork
        self.validate_String64(self.NetWork)
        self.Name = Name
        self.StatusWell = StatusWell
        self.validate_WellStatus(self.StatusWell)
        self.FluidWell = FluidWell
        self.validate_WellFluid(self.FluidWell)
        self.OperatingMethod = OperatingMethod
        self.validate_WellOperationMethod(self.OperatingMethod)
        self.WellProducing = WellProducing
        self.WellInjecting = WellInjecting
        self.Capacity = Capacity
        self.OperationTime = OperationTime
        if Flow is None:
            self.Flow = []
        else:
            self.Flow = Flow
        if ParameterSet is None:
            self.ParameterSet = []
        else:
            self.ParameterSet = ParameterSet
        if DowntimeReason is None:
            self.DowntimeReason = []
        else:
            self.DowntimeReason = DowntimeReason
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumeFacility)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumeFacility.subclass:
            return ProductVolumeFacility.subclass(*args_, **kwargs_)
        else:
            return ProductVolumeFacility(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FacilityParent(self): return self.FacilityParent
    def set_FacilityParent(self, FacilityParent): self.FacilityParent = FacilityParent
    FacilityParentProp = property(get_FacilityParent, set_FacilityParent)
    def get_FacilityParent2(self): return self.FacilityParent2
    def set_FacilityParent2(self, FacilityParent2): self.FacilityParent2 = FacilityParent2
    FacilityParent2Prop = property(get_FacilityParent2, set_FacilityParent2)
    def get_FacilityAlias(self): return self.FacilityAlias
    def set_FacilityAlias(self, FacilityAlias): self.FacilityAlias = FacilityAlias
    def add_FacilityAlias(self, value): self.FacilityAlias.append(value)
    def insert_FacilityAlias_at(self, index, value): self.FacilityAlias.insert(index, value)
    def replace_FacilityAlias_at(self, index, value): self.FacilityAlias[index] = value
    FacilityAliasProp = property(get_FacilityAlias, set_FacilityAlias)
    def get_Unit(self): return self.Unit
    def set_Unit(self, Unit): self.Unit = Unit
    UnitProp = property(get_Unit, set_Unit)
    def get_NetWork(self): return self.NetWork
    def set_NetWork(self, NetWork): self.NetWork = NetWork
    NetWorkProp = property(get_NetWork, set_NetWork)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_StatusWell(self): return self.StatusWell
    def set_StatusWell(self, StatusWell): self.StatusWell = StatusWell
    StatusWellProp = property(get_StatusWell, set_StatusWell)
    def get_FluidWell(self): return self.FluidWell
    def set_FluidWell(self, FluidWell): self.FluidWell = FluidWell
    FluidWellProp = property(get_FluidWell, set_FluidWell)
    def get_OperatingMethod(self): return self.OperatingMethod
    def set_OperatingMethod(self, OperatingMethod): self.OperatingMethod = OperatingMethod
    OperatingMethodProp = property(get_OperatingMethod, set_OperatingMethod)
    def get_WellProducing(self): return self.WellProducing
    def set_WellProducing(self, WellProducing): self.WellProducing = WellProducing
    WellProducingProp = property(get_WellProducing, set_WellProducing)
    def get_WellInjecting(self): return self.WellInjecting
    def set_WellInjecting(self, WellInjecting): self.WellInjecting = WellInjecting
    WellInjectingProp = property(get_WellInjecting, set_WellInjecting)
    def get_Capacity(self): return self.Capacity
    def set_Capacity(self, Capacity): self.Capacity = Capacity
    CapacityProp = property(get_Capacity, set_Capacity)
    def get_OperationTime(self): return self.OperationTime
    def set_OperationTime(self, OperationTime): self.OperationTime = OperationTime
    OperationTimeProp = property(get_OperationTime, set_OperationTime)
    def get_Flow(self): return self.Flow
    def set_Flow(self, Flow): self.Flow = Flow
    def add_Flow(self, value): self.Flow.append(value)
    def insert_Flow_at(self, index, value): self.Flow.insert(index, value)
    def replace_Flow_at(self, index, value): self.Flow[index] = value
    FlowProp = property(get_Flow, set_Flow)
    def get_ParameterSet(self): return self.ParameterSet
    def set_ParameterSet(self, ParameterSet): self.ParameterSet = ParameterSet
    def add_ParameterSet(self, value): self.ParameterSet.append(value)
    def insert_ParameterSet_at(self, index, value): self.ParameterSet.insert(index, value)
    def replace_ParameterSet_at(self, index, value): self.ParameterSet[index] = value
    ParameterSetProp = property(get_ParameterSet, set_ParameterSet)
    def get_DowntimeReason(self): return self.DowntimeReason
    def set_DowntimeReason(self, DowntimeReason): self.DowntimeReason = DowntimeReason
    def add_DowntimeReason(self, value): self.DowntimeReason.append(value)
    def insert_DowntimeReason_at(self, index, value): self.DowntimeReason.insert(index, value)
    def replace_DowntimeReason_at(self, index, value): self.DowntimeReason[index] = value
    DowntimeReasonProp = property(get_DowntimeReason, set_DowntimeReason)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    CommentProp = property(get_Comment, set_Comment)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_WellStatus(self, value):
        # Validate type WellStatus, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['abandoned', 'active', 'active -- injecting', 'active -- producing', 'completed', 'drilling', 'partially plugged', 'permitted', 'plugged and abandoned', 'proposed', 'sold', 'suspended', 'temporarily abandoned', 'testing', 'tight', 'working over', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WellStatus' % {"value" : value.encode("utf-8")} )
    def validate_WellFluid(self, value):
        # Validate type WellFluid, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['air', 'condensate', 'dry', 'gas', 'gas-water', 'non HC gas', 'non HC gas -- CO2', 'oil', 'oil-gas', 'oil-water', 'steam', 'water', 'water -- brine', 'water -- fresh water']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WellFluid' % {"value" : value.encode("utf-8")} )
    def validate_WellOperationMethod(self, value):
        # Validate type WellOperationMethod, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['continuous gas lift', 'electric submersible pump lift', 'foam lift', 'hydraulic pump lift', 'intermittent gas lift', 'jet pump lift', 'natural flow', 'plunger gas lift', 'progressive cavity pump lift', 'sucker rod pump lift', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WellOperationMethod' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FacilityParent is not None or
            self.FacilityParent2 is not None or
            self.FacilityAlias or
            self.Unit is not None or
            self.NetWork is not None or
            self.Name is not None or
            self.StatusWell is not None or
            self.FluidWell is not None or
            self.OperatingMethod is not None or
            self.WellProducing is not None or
            self.WellInjecting is not None or
            self.Capacity is not None or
            self.OperationTime is not None or
            self.Flow or
            self.ParameterSet or
            self.DowntimeReason or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumeFacility', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumeFacility')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumeFacility', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumeFacility'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumeFacility', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FacilityParent is not None:
            self.FacilityParent.export(outfile, level, namespace_, name_='FacilityParent', pretty_print=pretty_print)
        if self.FacilityParent2 is not None:
            self.FacilityParent2.export(outfile, level, namespace_, name_='FacilityParent2', pretty_print=pretty_print)
        for FacilityAlias_ in self.FacilityAlias:
            FacilityAlias_.export(outfile, level, namespace_, name_='FacilityAlias', pretty_print=pretty_print)
        if self.Unit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnit>%s</%sUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unit), input_name='Unit')), namespace_, eol_))
        if self.NetWork is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetWork>%s</%sNetWork>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.NetWork), input_name='NetWork')), namespace_, eol_))
        if self.Name is not None:
            self.Name.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        if self.StatusWell is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStatusWell>%s</%sStatusWell>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StatusWell), input_name='StatusWell')), namespace_, eol_))
        if self.FluidWell is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFluidWell>%s</%sFluidWell>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FluidWell), input_name='FluidWell')), namespace_, eol_))
        if self.OperatingMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOperatingMethod>%s</%sOperatingMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OperatingMethod), input_name='OperatingMethod')), namespace_, eol_))
        if self.WellProducing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWellProducing>%s</%sWellProducing>%s' % (namespace_, self.gds_format_boolean(self.WellProducing, input_name='WellProducing'), namespace_, eol_))
        if self.WellInjecting is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWellInjecting>%s</%sWellInjecting>%s' % (namespace_, self.gds_format_boolean(self.WellInjecting, input_name='WellInjecting'), namespace_, eol_))
        if self.Capacity is not None:
            self.Capacity.export(outfile, level, namespace_, name_='Capacity', pretty_print=pretty_print)
        if self.OperationTime is not None:
            self.OperationTime.export(outfile, level, namespace_, name_='OperationTime', pretty_print=pretty_print)
        for Flow_ in self.Flow:
            Flow_.export(outfile, level, namespace_, name_='Flow', pretty_print=pretty_print)
        for ParameterSet_ in self.ParameterSet:
            ParameterSet_.export(outfile, level, namespace_, name_='ParameterSet', pretty_print=pretty_print)
        for DowntimeReason_ in self.DowntimeReason:
            DowntimeReason_.export(outfile, level, namespace_, name_='DowntimeReason', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FacilityParent':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.FacilityParent = obj_
            obj_.original_tagname_ = 'FacilityParent'
        elif nodeName_ == 'FacilityParent2':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.FacilityParent2 = obj_
            obj_.original_tagname_ = 'FacilityParent2'
        elif nodeName_ == 'FacilityAlias':
            obj_ = NameStruct.factory()
            obj_.build(child_)
            self.FacilityAlias.append(obj_)
            obj_.original_tagname_ = 'FacilityAlias'
        elif nodeName_ == 'Unit':
            Unit_ = child_.text
            Unit_ = self.gds_validate_string(Unit_, node, 'Unit')
            self.Unit = Unit_
            # validate type String64
            self.validate_String64(self.Unit)
        elif nodeName_ == 'NetWork':
            NetWork_ = child_.text
            NetWork_ = self.gds_validate_string(NetWork_, node, 'NetWork')
            self.NetWork = NetWork_
            # validate type String64
            self.validate_String64(self.NetWork)
        elif nodeName_ == 'Name':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'StatusWell':
            StatusWell_ = child_.text
            StatusWell_ = self.gds_validate_string(StatusWell_, node, 'StatusWell')
            self.StatusWell = StatusWell_
            # validate type WellStatus
            self.validate_WellStatus(self.StatusWell)
        elif nodeName_ == 'FluidWell':
            FluidWell_ = child_.text
            FluidWell_ = self.gds_validate_string(FluidWell_, node, 'FluidWell')
            self.FluidWell = FluidWell_
            # validate type WellFluid
            self.validate_WellFluid(self.FluidWell)
        elif nodeName_ == 'OperatingMethod':
            OperatingMethod_ = child_.text
            OperatingMethod_ = self.gds_validate_string(OperatingMethod_, node, 'OperatingMethod')
            self.OperatingMethod = OperatingMethod_
            # validate type WellOperationMethod
            self.validate_WellOperationMethod(self.OperatingMethod)
        elif nodeName_ == 'WellProducing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'WellProducing')
            self.WellProducing = ival_
        elif nodeName_ == 'WellInjecting':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'WellInjecting')
            self.WellInjecting = ival_
        elif nodeName_ == 'Capacity':
            obj_ = VolumeMeasure.factory()
            obj_.build(child_)
            self.Capacity = obj_
            obj_.original_tagname_ = 'Capacity'
        elif nodeName_ == 'OperationTime':
            obj_ = TimeMeasure.factory()
            obj_.build(child_)
            self.OperationTime = obj_
            obj_.original_tagname_ = 'OperationTime'
        elif nodeName_ == 'Flow':
            obj_ = ProductVolumeFlow.factory()
            obj_.build(child_)
            self.Flow.append(obj_)
            obj_.original_tagname_ = 'Flow'
        elif nodeName_ == 'ParameterSet':
            obj_ = ProductVolumeParameterSet.factory()
            obj_.build(child_)
            self.ParameterSet.append(obj_)
            obj_.original_tagname_ = 'ParameterSet'
        elif nodeName_ == 'DowntimeReason':
            obj_ = DatedComment.factory()
            obj_.build(child_)
            self.DowntimeReason.append(obj_)
            obj_.original_tagname_ = 'DowntimeReason'
        elif nodeName_ == 'Comment':
            obj_ = DatedComment.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class ProductVolumeFacility


class ProductVolumeFlow(GeneratedsSuper):
    """Product Volume Flow Component Schema.A unique identifier for this
    data element. It is not globally unique (not a uuid) and only
    need be unique within the context of the parent top-level
    object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Name=None, Kind=None, Port=None, Direction=None, Facility=None, FacilityAlias=None, Qualifier=None, SubQualifier=None, Version=None, VersionSource=None, SourceFlow=None, RelatedFacility=None, Product=None, Properties=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Name = Name
        self.validate_String64(self.Name)
        self.Kind = Kind
        self.validate_ReportingFlow(self.Kind)
        self.Port = Port
        self.validate_String64(self.Port)
        self.Direction = Direction
        self.validate_ProductFlowPortType(self.Direction)
        self.Facility = Facility
        if FacilityAlias is None:
            self.FacilityAlias = []
        else:
            self.FacilityAlias = FacilityAlias
        self.Qualifier = Qualifier
        self.validate_FlowQualifier(self.Qualifier)
        self.SubQualifier = SubQualifier
        self.validate_FlowSubQualifier(self.SubQualifier)
        self.Version = Version
        self.validate_TimeStamp(self.Version)
        self.VersionSource = VersionSource
        self.validate_String64(self.VersionSource)
        self.SourceFlow = SourceFlow
        self.validate_String64(self.SourceFlow)
        self.RelatedFacility = RelatedFacility
        if Product is None:
            self.Product = []
        else:
            self.Product = Product
        self.Properties = Properties
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumeFlow)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumeFlow.subclass:
            return ProductVolumeFlow.subclass(*args_, **kwargs_)
        else:
            return ProductVolumeFlow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    KindProp = property(get_Kind, set_Kind)
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    PortProp = property(get_Port, set_Port)
    def get_Direction(self): return self.Direction
    def set_Direction(self, Direction): self.Direction = Direction
    DirectionProp = property(get_Direction, set_Direction)
    def get_Facility(self): return self.Facility
    def set_Facility(self, Facility): self.Facility = Facility
    FacilityProp = property(get_Facility, set_Facility)
    def get_FacilityAlias(self): return self.FacilityAlias
    def set_FacilityAlias(self, FacilityAlias): self.FacilityAlias = FacilityAlias
    def add_FacilityAlias(self, value): self.FacilityAlias.append(value)
    def insert_FacilityAlias_at(self, index, value): self.FacilityAlias.insert(index, value)
    def replace_FacilityAlias_at(self, index, value): self.FacilityAlias[index] = value
    FacilityAliasProp = property(get_FacilityAlias, set_FacilityAlias)
    def get_Qualifier(self): return self.Qualifier
    def set_Qualifier(self, Qualifier): self.Qualifier = Qualifier
    QualifierProp = property(get_Qualifier, set_Qualifier)
    def get_SubQualifier(self): return self.SubQualifier
    def set_SubQualifier(self, SubQualifier): self.SubQualifier = SubQualifier
    SubQualifierProp = property(get_SubQualifier, set_SubQualifier)
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    VersionProp = property(get_Version, set_Version)
    def get_VersionSource(self): return self.VersionSource
    def set_VersionSource(self, VersionSource): self.VersionSource = VersionSource
    VersionSourceProp = property(get_VersionSource, set_VersionSource)
    def get_SourceFlow(self): return self.SourceFlow
    def set_SourceFlow(self, SourceFlow): self.SourceFlow = SourceFlow
    SourceFlowProp = property(get_SourceFlow, set_SourceFlow)
    def get_RelatedFacility(self): return self.RelatedFacility
    def set_RelatedFacility(self, RelatedFacility): self.RelatedFacility = RelatedFacility
    RelatedFacilityProp = property(get_RelatedFacility, set_RelatedFacility)
    def get_Product(self): return self.Product
    def set_Product(self, Product): self.Product = Product
    def add_Product(self, value): self.Product.append(value)
    def insert_Product_at(self, index, value): self.Product.insert(index, value)
    def replace_Product_at(self, index, value): self.Product[index] = value
    ProductProp = property(get_Product, set_Product)
    def get_Properties(self): return self.Properties
    def set_Properties(self, Properties): self.Properties = Properties
    PropertiesProp = property(get_Properties, set_Properties)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_ReportingFlow(self, value):
        # Validate type ReportingFlow, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['consume', 'consume - black start', 'consume - compressor', 'consume - emitted', 'consume - flare', 'consume - fuel', 'consume - HP flare', 'consume - LP flare', 'consume - non compressor', 'consume - venting', 'disposal', 'export', 'export - nominated', 'export - requested', 'export - shortfall', 'gas lift', 'hydrocarbon accounting', 'import', 'injection', 'inventory', 'overboard', 'production', 'sale', 'storage', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReportingFlow' % {"value" : value.encode("utf-8")} )
    def validate_ProductFlowPortType(self, value):
        # Validate type ProductFlowPortType, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inlet', 'outlet', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ProductFlowPortType' % {"value" : value.encode("utf-8")} )
    def validate_FlowQualifier(self, value):
        # Validate type FlowQualifier, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['allocated', 'budget', 'constraint', 'derived', 'difference', 'estimate', 'forecast', 'mass adjusted', 'measured', 'metered', 'metered - fiscal', 'nominated', 'potential', 'processed', 'quota', 'recommended', 'simulated', 'target', 'tariff basis', 'value adjusted']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FlowQualifier' % {"value" : value.encode("utf-8")} )
    def validate_FlowSubQualifier(self, value):
        # Validate type FlowSubQualifier, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['decline curve', 'difference', 'fiscal', 'fixed', 'maximum', 'minimum', 'raw', 'recalibrated', 'standard']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FlowSubQualifier' % {"value" : value.encode("utf-8")} )
    def validate_TimeStamp(self, value):
        # Validate type TimeStamp, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TimeStamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TimeStamp_patterns_, ))
    validate_TimeStamp_patterns_ = [['^.+T.+[Z+\\-].*$']]
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Kind is not None or
            self.Port is not None or
            self.Direction is not None or
            self.Facility is not None or
            self.FacilityAlias or
            self.Qualifier is not None or
            self.SubQualifier is not None or
            self.Version is not None or
            self.VersionSource is not None or
            self.SourceFlow is not None or
            self.RelatedFacility is not None or
            self.Product or
            self.Properties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumeFlow', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumeFlow')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumeFlow', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumeFlow'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumeFlow', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.Kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKind>%s</%sKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Kind), input_name='Kind')), namespace_, eol_))
        if self.Port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPort>%s</%sPort>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Port), input_name='Port')), namespace_, eol_))
        if self.Direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDirection>%s</%sDirection>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Direction), input_name='Direction')), namespace_, eol_))
        if self.Facility is not None:
            self.Facility.export(outfile, level, namespace_, name_='Facility', pretty_print=pretty_print)
        for FacilityAlias_ in self.FacilityAlias:
            FacilityAlias_.export(outfile, level, namespace_, name_='FacilityAlias', pretty_print=pretty_print)
        if self.Qualifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQualifier>%s</%sQualifier>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Qualifier), input_name='Qualifier')), namespace_, eol_))
        if self.SubQualifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubQualifier>%s</%sSubQualifier>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SubQualifier), input_name='SubQualifier')), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Version), input_name='Version')), namespace_, eol_))
        if self.VersionSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersionSource>%s</%sVersionSource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.VersionSource), input_name='VersionSource')), namespace_, eol_))
        if self.SourceFlow is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourceFlow>%s</%sSourceFlow>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SourceFlow), input_name='SourceFlow')), namespace_, eol_))
        if self.RelatedFacility is not None:
            self.RelatedFacility.export(outfile, level, namespace_, name_='RelatedFacility', pretty_print=pretty_print)
        for Product_ in self.Product:
            Product_.export(outfile, level, namespace_, name_='Product', pretty_print=pretty_print)
        if self.Properties is not None:
            self.Properties.export(outfile, level, namespace_, name_='Properties', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'Kind':
            Kind_ = child_.text
            Kind_ = self.gds_validate_string(Kind_, node, 'Kind')
            self.Kind = Kind_
            # validate type ReportingFlow
            self.validate_ReportingFlow(self.Kind)
        elif nodeName_ == 'Port':
            Port_ = child_.text
            Port_ = self.gds_validate_string(Port_, node, 'Port')
            self.Port = Port_
            # validate type String64
            self.validate_String64(self.Port)
        elif nodeName_ == 'Direction':
            Direction_ = child_.text
            Direction_ = self.gds_validate_string(Direction_, node, 'Direction')
            self.Direction = Direction_
            # validate type ProductFlowPortType
            self.validate_ProductFlowPortType(self.Direction)
        elif nodeName_ == 'Facility':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.Facility = obj_
            obj_.original_tagname_ = 'Facility'
        elif nodeName_ == 'FacilityAlias':
            obj_ = NameStruct.factory()
            obj_.build(child_)
            self.FacilityAlias.append(obj_)
            obj_.original_tagname_ = 'FacilityAlias'
        elif nodeName_ == 'Qualifier':
            Qualifier_ = child_.text
            Qualifier_ = self.gds_validate_string(Qualifier_, node, 'Qualifier')
            self.Qualifier = Qualifier_
            # validate type FlowQualifier
            self.validate_FlowQualifier(self.Qualifier)
        elif nodeName_ == 'SubQualifier':
            SubQualifier_ = child_.text
            SubQualifier_ = self.gds_validate_string(SubQualifier_, node, 'SubQualifier')
            self.SubQualifier = SubQualifier_
            # validate type FlowSubQualifier
            self.validate_FlowSubQualifier(self.SubQualifier)
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
            # validate type TimeStamp
            self.validate_TimeStamp(self.Version)
        elif nodeName_ == 'VersionSource':
            VersionSource_ = child_.text
            VersionSource_ = self.gds_validate_string(VersionSource_, node, 'VersionSource')
            self.VersionSource = VersionSource_
            # validate type String64
            self.validate_String64(self.VersionSource)
        elif nodeName_ == 'SourceFlow':
            SourceFlow_ = child_.text
            SourceFlow_ = self.gds_validate_string(SourceFlow_, node, 'SourceFlow')
            self.SourceFlow = SourceFlow_
            # validate type String64
            self.validate_String64(self.SourceFlow)
        elif nodeName_ == 'RelatedFacility':
            obj_ = ProductVolumeRelatedFacility.factory()
            obj_.build(child_)
            self.RelatedFacility = obj_
            obj_.original_tagname_ = 'RelatedFacility'
        elif nodeName_ == 'Product':
            obj_ = ProductVolumeProduct.factory()
            obj_.build(child_)
            self.Product.append(obj_)
            obj_.original_tagname_ = 'Product'
        elif nodeName_ == 'Properties':
            obj_ = CommonPropertiesProductVolume.factory()
            obj_.build(child_)
            self.Properties = obj_
            obj_.original_tagname_ = 'Properties'
# end class ProductVolumeFlow


class ProductVolumeParameterSet(GeneratedsSuper):
    """Product Volume Facility Parameter Set Schema.A unique identifier for
    this data element. It is not globally unique (not a uuid) and
    only need be unique within the context of the parent top-level
    object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Name=None, ChildFacilityIdentifier=None, Port=None, MeasureClass=None, CoordinateReferenceSystem=None, Qualifier=None, SubQualifier=None, Version=None, VersionSource=None, Product=None, PeriodKind=None, Comment=None, Parameter=None, CurveDefinition=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Name = Name
        self.validate_FacilityParameter(self.Name)
        self.ChildFacilityIdentifier = ChildFacilityIdentifier
        self.validate_ProdmlRelativeIdentifier(self.ChildFacilityIdentifier)
        self.Port = Port
        self.validate_String64(self.Port)
        self.MeasureClass = MeasureClass
        self.validate_MeasureClass(self.MeasureClass)
        self.CoordinateReferenceSystem = CoordinateReferenceSystem
        self.validate_String64(self.CoordinateReferenceSystem)
        self.Qualifier = Qualifier
        self.validate_FlowQualifier(self.Qualifier)
        self.SubQualifier = SubQualifier
        self.validate_FlowSubQualifier(self.SubQualifier)
        if isinstance(Version, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Version, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Version
        self.Version = initvalue_
        self.VersionSource = VersionSource
        self.validate_String64(self.VersionSource)
        self.Product = Product
        self.validate_ReportingProduct(self.Product)
        self.PeriodKind = PeriodKind
        self.validate_ReportingDurationKind(self.PeriodKind)
        self.Comment = Comment
        self.validate_String2000(self.Comment)
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
        if CurveDefinition is None:
            self.CurveDefinition = []
        else:
            self.CurveDefinition = CurveDefinition
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumeParameterSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumeParameterSet.subclass:
            return ProductVolumeParameterSet.subclass(*args_, **kwargs_)
        else:
            return ProductVolumeParameterSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_ChildFacilityIdentifier(self): return self.ChildFacilityIdentifier
    def set_ChildFacilityIdentifier(self, ChildFacilityIdentifier): self.ChildFacilityIdentifier = ChildFacilityIdentifier
    ChildFacilityIdentifierProp = property(get_ChildFacilityIdentifier, set_ChildFacilityIdentifier)
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    PortProp = property(get_Port, set_Port)
    def get_MeasureClass(self): return self.MeasureClass
    def set_MeasureClass(self, MeasureClass): self.MeasureClass = MeasureClass
    MeasureClassProp = property(get_MeasureClass, set_MeasureClass)
    def get_CoordinateReferenceSystem(self): return self.CoordinateReferenceSystem
    def set_CoordinateReferenceSystem(self, CoordinateReferenceSystem): self.CoordinateReferenceSystem = CoordinateReferenceSystem
    CoordinateReferenceSystemProp = property(get_CoordinateReferenceSystem, set_CoordinateReferenceSystem)
    def get_Qualifier(self): return self.Qualifier
    def set_Qualifier(self, Qualifier): self.Qualifier = Qualifier
    QualifierProp = property(get_Qualifier, set_Qualifier)
    def get_SubQualifier(self): return self.SubQualifier
    def set_SubQualifier(self, SubQualifier): self.SubQualifier = SubQualifier
    SubQualifierProp = property(get_SubQualifier, set_SubQualifier)
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    VersionProp = property(get_Version, set_Version)
    def get_VersionSource(self): return self.VersionSource
    def set_VersionSource(self, VersionSource): self.VersionSource = VersionSource
    VersionSourceProp = property(get_VersionSource, set_VersionSource)
    def get_Product(self): return self.Product
    def set_Product(self, Product): self.Product = Product
    ProductProp = property(get_Product, set_Product)
    def get_PeriodKind(self): return self.PeriodKind
    def set_PeriodKind(self, PeriodKind): self.PeriodKind = PeriodKind
    PeriodKindProp = property(get_PeriodKind, set_PeriodKind)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    def add_Parameter(self, value): self.Parameter.append(value)
    def insert_Parameter_at(self, index, value): self.Parameter.insert(index, value)
    def replace_Parameter_at(self, index, value): self.Parameter[index] = value
    ParameterProp = property(get_Parameter, set_Parameter)
    def get_CurveDefinition(self): return self.CurveDefinition
    def set_CurveDefinition(self, CurveDefinition): self.CurveDefinition = CurveDefinition
    def add_CurveDefinition(self, value): self.CurveDefinition.append(value)
    def insert_CurveDefinition_at(self, index, value): self.CurveDefinition.insert(index, value)
    def replace_CurveDefinition_at(self, index, value): self.CurveDefinition[index] = value
    CurveDefinitionProp = property(get_CurveDefinition, set_CurveDefinition)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_FacilityParameter(self, value):
        # Validate type FacilityParameter, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['absorbed dose class', 'acceleration linear class', 'activity (of radioactivity) class', 'alarm absolute pressure', 'amount of substance class', 'angle per length', 'angle per time', 'angle per volume', 'angular acceleration class', 'annulus inner diameter', 'annulus outer diameter', 'area class', 'area per area', 'area per volume', 'atmospheric pressure', 'attenuation class', 'attenuation per length', 'available', 'available room', 'block valve status', 'capacitance class', 'categorical', 'cathodic protection output current', 'cathodic protection output voltage', 'charge density class', 'chemical potential class', 'choke position', 'choke setting', 'code', 'compressibility class', 'concentration of B class', 'conductivity class', 'continuous', 'cross section absorption class', 'current density class', 'darcy flow coefficient class', 'data transmission speed class', 'delta temperature class', 'density', 'density class', 'density flow rate', 'density standard', 'dewpoint temperature', 'differential pressure', 'differential temperature', 'diffusion coefficient class', 'digital storage class', 'dimensionless class', 'discrete', 'dose equivalent class', 'dose equivalent rate class', 'dynamic viscosity class', 'electric charge class', 'electric conductance class', 'electric current class', 'electric dipole moment class', 'electric field strength class', 'electric polarization class', 'electric potential class', 'electrical resistivity class', 'electrochemical equivalent class', 'electromagnetic moment class', 'energy length per area', 'energy length per time area temperature', 'energy per area', 'energy per length', 'equivalent per mass', 'equivalent per volume', 'exposure (radioactivity) class', 'facility uptime', 'flow rate', 'flow rate standard', 'force area class', 'force class', 'force length per length', 'force per force', 'force per length', 'force per volume', 'frequency class', 'frequency interval class', 'gamma ray API unit class', 'gas liquid ratio', 'gas oil ratio', 'gross calorific value standard', 'heat capacity class', 'heat flow rate class', 'heat transfer coefficient class', 'illuminance class', 'internal control valve status', 'irradiance class', 'isothermal compressibility class', 'kinematic viscosity class', 'length class', 'length per length', 'length per temperature', 'length per volume', 'level of power intensity class', 'light exposure class', 'linear thermal expansion class', 'luminance class', 'luminous efficacy class', 'luminous flux class', 'luminous intensity class', 'magnetic dipole moment class', 'magnetic field strength class', 'magnetic flux class', 'magnetic induction class', 'magnetic permeability class', 'magnetic vector potential class', 'mass', 'mass attenuation coefficient class', 'mass class', 'mass concentration', 'mass concentration class', 'mass flow rate class', 'mass length class', 'mass per energy', 'mass per length', 'mass per time per area', 'mass per time per length', 'mass per volume per length', 'measured depth', 'mobility class', 'modulus of compression class', 'molar concentration', 'molar fraction', 'molar heat capacity class', 'molar volume class', 'mole per area', 'mole per time', 'mole per time per area', 'molecular weight', 'moment of force class', 'moment of inertia class', 'moment of section class', 'momentum class', 'motor current', 'motor current leakage', 'motor speed', 'motor temperature', 'motor vibration', 'motor voltage', 'neutron API unit class', 'nonDarcy flow coefficient class', 'opening size', 'operations per time', 'parachor class', 'per area', 'per electric potential', 'per force', 'per length', 'per mass', 'per volume', 'permeability length class', 'permeability rock class', 'permeance class', 'permittivity class', 'pH class', 'plane angle class', 'potential difference per power drop', 'power class', 'power per volume', 'pressure', 'pressure class', 'pressure per time', 'pressure squared class', 'pressure squared per force time per area', 'pressure time per volume', 'productivity index class', 'pump count online', 'pump status', 'quantity', 'quantity of light class', 'radiance class', 'radiant intensity class', 'reciprocating speed', 'rectifier structure potential', 'reid vapor pressure', 'relative opening size', 'relative power class', 'relative tank level', 'relative time class', 'relative valve opening', 'reluctance class', 'resistance class', 'resistivity per length', 'root property', 'scheduled downtime', 'second moment of area class', 'shutdown order', 'shutin pressure', 'shutin temperature', 'solid angle class', 'specific activity (of radioactivity)', 'specific energy class', 'specific gravity', 'specific heat capacity class', 'specific productivity index class', 'specific volume class', 'sub surface safety valve status', 'surface density class', 'surface safety valve status', 'tank fluid level', 'tank product standard volume', 'tank product volume', 'temperature', 'temperature per length', 'temperature per time', 'thermal conductance class', 'thermal conductivity class', 'thermal diffusivity class', 'thermal insulance class', 'thermal resistance class', 'thermodynamic temperature class', 'time class', 'time per length', 'time per volume', 'true vapor pressure', 'unit productivity index class', 'unitless', 'unknown', 'valve opening', 'valve status', 'velocity class', 'volume', 'volume class', 'volume concentration', 'volume flow rate class', 'volume length per time', 'volume per area', 'volume per length', 'volume per time per area', 'volume per time per length', 'volume per time per time', 'volume per time per volume', 'volume per volume', 'volume standard', 'volumetric efficiency', 'volumetric heat transfer coefficient', 'volumetric thermal expansion class', 'well operating status', 'well operation type', 'wobbe index', 'work', 'work class']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FacilityParameter' % {"value" : value.encode("utf-8")} )
    def validate_ProdmlRelativeIdentifier(self, value):
        # Validate type ProdmlRelativeIdentifier, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_MeasureClass(self, value):
        # Validate type MeasureClass, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['absorbed dose', 'activity of radioactivity', 'amount of substance', 'amount of substance per amount of substance', 'amount of substance per area', 'amount of substance per time', 'amount of substance per time per area', 'amount of substance per volume', 'angle per length', 'angle per volume', 'angular acceleration', 'angular velocity', 'api gamma ray', 'api gravity', 'api neutron', 'area', 'area per amount of substance', 'area per area', 'area per count', 'area per mass', 'area per time', 'area per volume', 'attenuation per frequency interval', 'capacitance', 'cation exchange capacity', 'data transfer speed', 'diffusion coefficient', 'diffusive time of flight', 'digital storage', 'dimensionless', 'dipole moment', 'dose equivalent', 'dynamic viscosity', 'electric charge', 'electric charge per area', 'electric charge per mass', 'electric charge per volume', 'electric conductance', 'electric conductivity', 'electric current', 'electric current density', 'electric field strength', 'electric potential difference', 'electric resistance', 'electric resistance per length', 'electrical resistivity', 'electromagnetic moment', 'energy', 'energy length per area', 'energy length per time area temperature', 'energy per area', 'energy per length', 'energy per mass', 'energy per mass per time', 'energy per volume', 'force', 'force area', 'force length per length', 'force per force', 'force per length', 'force per volume', 'frequency', 'frequency interval', 'heat capacity', 'heat flow rate', 'heat transfer coefficient', 'illuminance', 'inductance', 'isothermal compressibility', 'kinematic viscosity', 'length', 'length per length', 'length per mass', 'length per pressure', 'length per temperature', 'length per time', 'length per volume', 'light exposure', 'linear acceleration', 'linear thermal expansion', 'logarithmic power ratio', 'logarithmic power ratio per length', 'luminance', 'luminous efficacy', 'luminous flux', 'luminous intensity', 'magnetic dipole moment', 'magnetic field strength', 'magnetic flux', 'magnetic flux density', 'magnetic flux density per length', 'magnetic permeability', 'magnetic vector potential', 'mass', 'mass length', 'mass per area', 'mass per energy', 'mass per length', 'mass per mass', 'mass per time', 'mass per time per area', 'mass per time per length', 'mass per volume', 'mass per volume per length', 'mass per volume per pressure', 'mass per volume per temperature', 'mobility', 'molar energy', 'molar heat capacity', 'molar volume', 'molecular weight', 'moment of force', 'moment of inertia', 'momentum', 'normalized power', 'permeability length', 'permeability rock', 'permittivity', 'plane angle', 'potential difference per power drop', 'power', 'power per area', 'power per power', 'power per volume', 'pressure', 'pressure per pressure', 'pressure per time', 'pressure per volume', 'pressure squared', 'pressure squared per force time per area', 'pressure time per volume', 'quantity of light', 'radiance', 'radiant intensity', 'reciprocal area', 'reciprocal electric potential difference', 'reciprocal force', 'reciprocal length', 'reciprocal mass', 'reciprocal mass time', 'reciprocal pressure', 'reciprocal time', 'reciprocal volume', 'reluctance', 'second moment of area', 'signaling event per time', 'solid angle', 'specific heat capacity', 'temperature interval', 'temperature interval per length', 'temperature interval per pressure', 'temperature interval per time', 'thermal conductance', 'thermal conductivity', 'thermal diffusivity', 'thermal insulance', 'thermal resistance', 'thermodynamic temperature', 'thermodynamic temperature per thermodynamic temperature', 'time', 'time per length', 'time per mass', 'time per time', 'time per volume', 'vertical coordinate', 'volume', 'volume flow rate per volume flow rate', 'volume per area', 'volume per length', 'volume per mass', 'volume per pressure', 'volume per rotation', 'volume per time', 'volume per time length', 'volume per time per area', 'volume per time per length', 'volume per time per pressure', 'volume per time per pressure length', 'volume per time per time', 'volume per time per volume', 'volume per volume', 'volumetric heat transfer coefficient', 'volumetric thermal expansion', 'unitless']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureClass' % {"value" : value.encode("utf-8")} )
    def validate_FlowQualifier(self, value):
        # Validate type FlowQualifier, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['allocated', 'budget', 'constraint', 'derived', 'difference', 'estimate', 'forecast', 'mass adjusted', 'measured', 'metered', 'metered - fiscal', 'nominated', 'potential', 'processed', 'quota', 'recommended', 'simulated', 'target', 'tariff basis', 'value adjusted']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FlowQualifier' % {"value" : value.encode("utf-8")} )
    def validate_FlowSubQualifier(self, value):
        # Validate type FlowSubQualifier, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['decline curve', 'difference', 'fiscal', 'fixed', 'maximum', 'minimum', 'raw', 'recalibrated', 'standard']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FlowSubQualifier' % {"value" : value.encode("utf-8")} )
    def validate_ReportingProduct(self, value):
        # Validate type ReportingProduct, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['aqueous', 'c10', 'c10-', 'c10+', 'c2-', 'c2+', 'c3-', 'c3+', 'c4-', 'c4+', 'c5-', 'c5+', 'c6-', 'c6+', 'c7', 'c7-', 'c7+', 'c8', 'c8-', 'c8+', 'c9', 'c9-', 'c9+', 'carbon dioxide gas', 'carbon monoxide gas', 'chemical', 'condensate', 'condensate - gross', 'condensate - net', 'crude - stabilized', 'cuttings', 'diesel', 'diethylene glycol', 'dioxygen', 'electric power', 'ethane', 'ethane - component', 'gas', 'gas - component in oil', 'gas - dry', 'gas - rich', 'gas - wet', 'helium gas', 'heptane', 'hydraulic control fluid', 'hydrogen gas', 'hydrogen sulfide', 'i-butane - component', 'isobutane', 'isopentane', 'liquefied natural gas', 'liquefied petroleum gas', 'liquid', 'methane', 'methane - component', 'methanol', 'mixed butane', 'monoethylene glycol', 'naphtha', 'natural gas liquid', 'n-butane - component', 'neopentane', 'NGL - component in gas', 'nitrogen gas', 'nitrogen oxide gas', 'normal butane', 'normal pentane', 'oil', 'oil - component in water', 'oil - gross', 'oil - net', 'oil and gas', 'oleic', 'pentane - component', 'petroleum gas liquid', 'propane', 'propane - component', 'salt', 'sand - component', 'triethylene glycol', 'unknown', 'vapor', 'water', 'water - discharge', 'water - processed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReportingProduct' % {"value" : value.encode("utf-8")} )
    def validate_ReportingDurationKind(self, value):
        # Validate type ReportingDurationKind, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['day', 'life to date', 'month', 'month to date', 'total cumulative', 'week', 'year', 'year to date']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReportingDurationKind' % {"value" : value.encode("utf-8")} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.ChildFacilityIdentifier is not None or
            self.Port is not None or
            self.MeasureClass is not None or
            self.CoordinateReferenceSystem is not None or
            self.Qualifier is not None or
            self.SubQualifier is not None or
            self.Version is not None or
            self.VersionSource is not None or
            self.Product is not None or
            self.PeriodKind is not None or
            self.Comment is not None or
            self.Parameter or
            self.CurveDefinition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumeParameterSet', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumeParameterSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumeParameterSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumeParameterSet'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumeParameterSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.ChildFacilityIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChildFacilityIdentifier>%s</%sChildFacilityIdentifier>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ChildFacilityIdentifier), input_name='ChildFacilityIdentifier')), namespace_, eol_))
        if self.Port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPort>%s</%sPort>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Port), input_name='Port')), namespace_, eol_))
        if self.MeasureClass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureClass>%s</%sMeasureClass>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MeasureClass), input_name='MeasureClass')), namespace_, eol_))
        if self.CoordinateReferenceSystem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCoordinateReferenceSystem>%s</%sCoordinateReferenceSystem>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CoordinateReferenceSystem), input_name='CoordinateReferenceSystem')), namespace_, eol_))
        if self.Qualifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQualifier>%s</%sQualifier>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Qualifier), input_name='Qualifier')), namespace_, eol_))
        if self.SubQualifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubQualifier>%s</%sSubQualifier>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SubQualifier), input_name='SubQualifier')), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_datetime(self.Version, input_name='Version'), namespace_, eol_))
        if self.VersionSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersionSource>%s</%sVersionSource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.VersionSource), input_name='VersionSource')), namespace_, eol_))
        if self.Product is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProduct>%s</%sProduct>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Product), input_name='Product')), namespace_, eol_))
        if self.PeriodKind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeriodKind>%s</%sPeriodKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PeriodKind), input_name='PeriodKind')), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, namespace_, name_='Parameter', pretty_print=pretty_print)
        for CurveDefinition_ in self.CurveDefinition:
            CurveDefinition_.export(outfile, level, namespace_, name_='CurveDefinition', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type FacilityParameter
            self.validate_FacilityParameter(self.Name)
        elif nodeName_ == 'ChildFacilityIdentifier':
            ChildFacilityIdentifier_ = child_.text
            ChildFacilityIdentifier_ = self.gds_validate_string(ChildFacilityIdentifier_, node, 'ChildFacilityIdentifier')
            self.ChildFacilityIdentifier = ChildFacilityIdentifier_
            # validate type ProdmlRelativeIdentifier
            self.validate_ProdmlRelativeIdentifier(self.ChildFacilityIdentifier)
        elif nodeName_ == 'Port':
            Port_ = child_.text
            Port_ = self.gds_validate_string(Port_, node, 'Port')
            self.Port = Port_
            # validate type String64
            self.validate_String64(self.Port)
        elif nodeName_ == 'MeasureClass':
            MeasureClass_ = child_.text
            MeasureClass_ = self.gds_validate_string(MeasureClass_, node, 'MeasureClass')
            self.MeasureClass = MeasureClass_
            # validate type MeasureClass
            self.validate_MeasureClass(self.MeasureClass)
        elif nodeName_ == 'CoordinateReferenceSystem':
            CoordinateReferenceSystem_ = child_.text
            CoordinateReferenceSystem_ = self.gds_validate_string(CoordinateReferenceSystem_, node, 'CoordinateReferenceSystem')
            self.CoordinateReferenceSystem = CoordinateReferenceSystem_
            # validate type String64
            self.validate_String64(self.CoordinateReferenceSystem)
        elif nodeName_ == 'Qualifier':
            Qualifier_ = child_.text
            Qualifier_ = self.gds_validate_string(Qualifier_, node, 'Qualifier')
            self.Qualifier = Qualifier_
            # validate type FlowQualifier
            self.validate_FlowQualifier(self.Qualifier)
        elif nodeName_ == 'SubQualifier':
            SubQualifier_ = child_.text
            SubQualifier_ = self.gds_validate_string(SubQualifier_, node, 'SubQualifier')
            self.SubQualifier = SubQualifier_
            # validate type FlowSubQualifier
            self.validate_FlowSubQualifier(self.SubQualifier)
        elif nodeName_ == 'Version':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.Version = dval_
        elif nodeName_ == 'VersionSource':
            VersionSource_ = child_.text
            VersionSource_ = self.gds_validate_string(VersionSource_, node, 'VersionSource')
            self.VersionSource = VersionSource_
            # validate type String64
            self.validate_String64(self.VersionSource)
        elif nodeName_ == 'Product':
            Product_ = child_.text
            Product_ = self.gds_validate_string(Product_, node, 'Product')
            self.Product = Product_
            # validate type ReportingProduct
            self.validate_ReportingProduct(self.Product)
        elif nodeName_ == 'PeriodKind':
            PeriodKind_ = child_.text
            PeriodKind_ = self.gds_validate_string(PeriodKind_, node, 'PeriodKind')
            self.PeriodKind = PeriodKind_
            # validate type ReportingDurationKind
            self.validate_ReportingDurationKind(self.PeriodKind)
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        elif nodeName_ == 'Parameter':
            obj_ = ProductVolumeParameterValue.factory()
            obj_.build(child_)
            self.Parameter.append(obj_)
            obj_.original_tagname_ = 'Parameter'
        elif nodeName_ == 'CurveDefinition':
            obj_ = CurveDefinition.factory()
            obj_.build(child_)
            self.CurveDefinition.append(obj_)
            obj_.original_tagname_ = 'CurveDefinition'
# end class ProductVolumeParameterSet


class ProductVolumeParameterValue(GeneratedsSuper):
    """Parameter Value Schema.A unique identifier for this data element. It
    is not globally unique (not a uuid) and only need be unique
    within the context of the parent top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, DTim=None, DTimEnd=None, Port=None, Unit=None, Alert=None, MeasureDataType=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        if isinstance(DTim, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DTim, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DTim
        self.DTim = initvalue_
        if isinstance(DTimEnd, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DTimEnd, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DTimEnd
        self.DTimEnd = initvalue_
        self.Port = Port
        self.validate_String64(self.Port)
        self.Unit = Unit
        self.validate_String64(self.Unit)
        self.Alert = Alert
        if MeasureDataType is None:
            self.MeasureDataType = []
        else:
            self.MeasureDataType = MeasureDataType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumeParameterValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumeParameterValue.subclass:
            return ProductVolumeParameterValue.subclass(*args_, **kwargs_)
        else:
            return ProductVolumeParameterValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DTim(self): return self.DTim
    def set_DTim(self, DTim): self.DTim = DTim
    DTimProp = property(get_DTim, set_DTim)
    def get_DTimEnd(self): return self.DTimEnd
    def set_DTimEnd(self, DTimEnd): self.DTimEnd = DTimEnd
    DTimEndProp = property(get_DTimEnd, set_DTimEnd)
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    PortProp = property(get_Port, set_Port)
    def get_Unit(self): return self.Unit
    def set_Unit(self, Unit): self.Unit = Unit
    UnitProp = property(get_Unit, set_Unit)
    def get_Alert(self): return self.Alert
    def set_Alert(self, Alert): self.Alert = Alert
    AlertProp = property(get_Alert, set_Alert)
    def get_MeasureDataType(self): return self.MeasureDataType
    def set_MeasureDataType(self, MeasureDataType): self.MeasureDataType = MeasureDataType
    def add_MeasureDataType(self, value): self.MeasureDataType.append(value)
    def insert_MeasureDataType_at(self, index, value): self.MeasureDataType.insert(index, value)
    def replace_MeasureDataType_at(self, index, value): self.MeasureDataType[index] = value
    MeasureDataTypeProp = property(get_MeasureDataType, set_MeasureDataType)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.DTim is not None or
            self.DTimEnd is not None or
            self.Port is not None or
            self.Unit is not None or
            self.Alert is not None or
            self.MeasureDataType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumeParameterValue', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumeParameterValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumeParameterValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumeParameterValue'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumeParameterValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DTim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTim>%s</%sDTim>%s' % (namespace_, self.gds_format_datetime(self.DTim, input_name='DTim'), namespace_, eol_))
        if self.DTimEnd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTimEnd>%s</%sDTimEnd>%s' % (namespace_, self.gds_format_datetime(self.DTimEnd, input_name='DTimEnd'), namespace_, eol_))
        if self.Port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPort>%s</%sPort>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Port), input_name='Port')), namespace_, eol_))
        if self.Unit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnit>%s</%sUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unit), input_name='Unit')), namespace_, eol_))
        if self.Alert is not None:
            self.Alert.export(outfile, level, namespace_, name_='Alert', pretty_print=pretty_print)
        for MeasureDataType_ in self.MeasureDataType:
            MeasureDataType_.export(outfile, level, namespace_, name_='MeasureDataType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DTim':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DTim = dval_
        elif nodeName_ == 'DTimEnd':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DTimEnd = dval_
        elif nodeName_ == 'Port':
            Port_ = child_.text
            Port_ = self.gds_validate_string(Port_, node, 'Port')
            self.Port = Port_
            # validate type String64
            self.validate_String64(self.Port)
        elif nodeName_ == 'Unit':
            Unit_ = child_.text
            Unit_ = self.gds_validate_string(Unit_, node, 'Unit')
            self.Unit = Unit_
            # validate type String64
            self.validate_String64(self.Unit)
        elif nodeName_ == 'Alert':
            obj_ = ProductVolumeAlert.factory()
            obj_.build(child_)
            self.Alert = obj_
            obj_.original_tagname_ = 'Alert'
        elif nodeName_ == 'MeasureDataType':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <MeasureDataType> element')
            self.MeasureDataType.append(obj_)
            obj_.original_tagname_ = 'MeasureDataType'
# end class ProductVolumeParameterValue


class ProductVolumePeriod(GeneratedsSuper):
    """Product Volume Period Schema.A unique identifier for this data
    element. It is not globally unique (not a uuid) and only need be
    unique within the context of the parent top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Kind=None, Comment=None, BalanceSet=None, ComponentContent=None, DateTime=None, Properties=None, Alert=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Kind = Kind
        self.validate_ReportingDurationKind(self.Kind)
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        if BalanceSet is None:
            self.BalanceSet = []
        else:
            self.BalanceSet = BalanceSet
        if ComponentContent is None:
            self.ComponentContent = []
        else:
            self.ComponentContent = ComponentContent
        self.DateTime = DateTime
        self.Properties = Properties
        self.Alert = Alert
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumePeriod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumePeriod.subclass:
            return ProductVolumePeriod.subclass(*args_, **kwargs_)
        else:
            return ProductVolumePeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    KindProp = property(get_Kind, set_Kind)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    CommentProp = property(get_Comment, set_Comment)
    def get_BalanceSet(self): return self.BalanceSet
    def set_BalanceSet(self, BalanceSet): self.BalanceSet = BalanceSet
    def add_BalanceSet(self, value): self.BalanceSet.append(value)
    def insert_BalanceSet_at(self, index, value): self.BalanceSet.insert(index, value)
    def replace_BalanceSet_at(self, index, value): self.BalanceSet[index] = value
    BalanceSetProp = property(get_BalanceSet, set_BalanceSet)
    def get_ComponentContent(self): return self.ComponentContent
    def set_ComponentContent(self, ComponentContent): self.ComponentContent = ComponentContent
    def add_ComponentContent(self, value): self.ComponentContent.append(value)
    def insert_ComponentContent_at(self, index, value): self.ComponentContent.insert(index, value)
    def replace_ComponentContent_at(self, index, value): self.ComponentContent[index] = value
    ComponentContentProp = property(get_ComponentContent, set_ComponentContent)
    def get_DateTime(self): return self.DateTime
    def set_DateTime(self, DateTime): self.DateTime = DateTime
    DateTimeProp = property(get_DateTime, set_DateTime)
    def get_Properties(self): return self.Properties
    def set_Properties(self, Properties): self.Properties = Properties
    PropertiesProp = property(get_Properties, set_Properties)
    def get_Alert(self): return self.Alert
    def set_Alert(self, Alert): self.Alert = Alert
    AlertProp = property(get_Alert, set_Alert)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_ReportingDurationKind(self, value):
        # Validate type ReportingDurationKind, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['day', 'life to date', 'month', 'month to date', 'total cumulative', 'week', 'year', 'year to date']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReportingDurationKind' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Kind is not None or
            self.Comment or
            self.BalanceSet or
            self.ComponentContent or
            self.DateTime is not None or
            self.Properties is not None or
            self.Alert is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumePeriod', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumePeriod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumePeriod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumePeriod'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumePeriod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKind>%s</%sKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Kind), input_name='Kind')), namespace_, eol_))
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        for BalanceSet_ in self.BalanceSet:
            BalanceSet_.export(outfile, level, namespace_, name_='BalanceSet', pretty_print=pretty_print)
        for ComponentContent_ in self.ComponentContent:
            ComponentContent_.export(outfile, level, namespace_, name_='ComponentContent', pretty_print=pretty_print)
        if self.DateTime is not None:
            self.DateTime.export(outfile, level, namespace_, name_='DateTime', pretty_print=pretty_print)
        if self.Properties is not None:
            self.Properties.export(outfile, level, namespace_, name_='Properties', pretty_print=pretty_print)
        if self.Alert is not None:
            self.Alert.export(outfile, level, namespace_, name_='Alert', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Kind':
            Kind_ = child_.text
            Kind_ = self.gds_validate_string(Kind_, node, 'Kind')
            self.Kind = Kind_
            # validate type ReportingDurationKind
            self.validate_ReportingDurationKind(self.Kind)
        elif nodeName_ == 'Comment':
            obj_ = DatedComment.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'BalanceSet':
            obj_ = ProductVolumeBalanceSet.factory()
            obj_.build(child_)
            self.BalanceSet.append(obj_)
            obj_.original_tagname_ = 'BalanceSet'
        elif nodeName_ == 'ComponentContent':
            obj_ = ProductVolumeComponentContent.factory()
            obj_.build(child_)
            self.ComponentContent.append(obj_)
            obj_.original_tagname_ = 'ComponentContent'
        elif nodeName_ == 'DateTime':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <DateTime> element')
            self.DateTime = obj_
            obj_.original_tagname_ = 'DateTime'
        elif nodeName_ == 'Properties':
            obj_ = CommonPropertiesProductVolume.factory()
            obj_.build(child_)
            self.Properties = obj_
            obj_.original_tagname_ = 'Properties'
        elif nodeName_ == 'Alert':
            obj_ = ProductVolumeAlert.factory()
            obj_.build(child_)
            self.Alert = obj_
            obj_.original_tagname_ = 'Alert'
# end class ProductVolumePeriod


class ProductVolumePortDifference(GeneratedsSuper):
    """Product Volume port differential characteristics.A unique identifier
    for this data element. It is not globally unique (not a uuid)
    and only need be unique within the context of the parent top-
    level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, PortReference=None, PresDiff=None, TempDiff=None, ChokeSize=None, ChokeRelative=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.PortReference = PortReference
        self.validate_String64(self.PortReference)
        self.PresDiff = PresDiff
        self.TempDiff = TempDiff
        self.ChokeSize = ChokeSize
        self.ChokeRelative = ChokeRelative
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumePortDifference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumePortDifference.subclass:
            return ProductVolumePortDifference.subclass(*args_, **kwargs_)
        else:
            return ProductVolumePortDifference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PortReference(self): return self.PortReference
    def set_PortReference(self, PortReference): self.PortReference = PortReference
    PortReferenceProp = property(get_PortReference, set_PortReference)
    def get_PresDiff(self): return self.PresDiff
    def set_PresDiff(self, PresDiff): self.PresDiff = PresDiff
    PresDiffProp = property(get_PresDiff, set_PresDiff)
    def get_TempDiff(self): return self.TempDiff
    def set_TempDiff(self, TempDiff): self.TempDiff = TempDiff
    TempDiffProp = property(get_TempDiff, set_TempDiff)
    def get_ChokeSize(self): return self.ChokeSize
    def set_ChokeSize(self, ChokeSize): self.ChokeSize = ChokeSize
    ChokeSizeProp = property(get_ChokeSize, set_ChokeSize)
    def get_ChokeRelative(self): return self.ChokeRelative
    def set_ChokeRelative(self, ChokeRelative): self.ChokeRelative = ChokeRelative
    ChokeRelativeProp = property(get_ChokeRelative, set_ChokeRelative)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.PortReference is not None or
            self.PresDiff is not None or
            self.TempDiff is not None or
            self.ChokeSize is not None or
            self.ChokeRelative is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumePortDifference', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumePortDifference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumePortDifference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumePortDifference'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumePortDifference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PortReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPortReference>%s</%sPortReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PortReference), input_name='PortReference')), namespace_, eol_))
        if self.PresDiff is not None:
            self.PresDiff.export(outfile, level, namespace_, name_='PresDiff', pretty_print=pretty_print)
        if self.TempDiff is not None:
            self.TempDiff.export(outfile, level, namespace_, name_='TempDiff', pretty_print=pretty_print)
        if self.ChokeSize is not None:
            self.ChokeSize.export(outfile, level, namespace_, name_='ChokeSize', pretty_print=pretty_print)
        if self.ChokeRelative is not None:
            self.ChokeRelative.export(outfile, level, namespace_, name_='ChokeRelative', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PortReference':
            PortReference_ = child_.text
            PortReference_ = self.gds_validate_string(PortReference_, node, 'PortReference')
            self.PortReference = PortReference_
            # validate type String64
            self.validate_String64(self.PortReference)
        elif nodeName_ == 'PresDiff':
            obj_ = PressureMeasure.factory()
            obj_.build(child_)
            self.PresDiff = obj_
            obj_.original_tagname_ = 'PresDiff'
        elif nodeName_ == 'TempDiff':
            obj_ = ThermodynamicTemperatureMeasure.factory()
            obj_.build(child_)
            self.TempDiff = obj_
            obj_.original_tagname_ = 'TempDiff'
        elif nodeName_ == 'ChokeSize':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.ChokeSize = obj_
            obj_.original_tagname_ = 'ChokeSize'
        elif nodeName_ == 'ChokeRelative':
            obj_ = LengthPerLengthMeasure.factory()
            obj_.build(child_)
            self.ChokeRelative = obj_
            obj_.original_tagname_ = 'ChokeRelative'
# end class ProductVolumePortDifference


class ProductVolumeProduct(GeneratedsSuper):
    """Product Volume Product Schema.A unique identifier for this data
    element. It is not globally unique (not a uuid) and only need be
    unique within the context of the parent top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Kind=None, Name=None, SplitFactor=None, MassFraction=None, MoleFraction=None, ComponentContent=None, SourceFlow=None, Period=None, Properties=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Kind = Kind
        self.validate_ReportingProduct(self.Kind)
        self.Name = Name
        self.SplitFactor = SplitFactor
        self.validate_NonNegativeFraction(self.SplitFactor)
        self.MassFraction = MassFraction
        self.MoleFraction = MoleFraction
        if ComponentContent is None:
            self.ComponentContent = []
        else:
            self.ComponentContent = ComponentContent
        self.SourceFlow = SourceFlow
        if Period is None:
            self.Period = []
        else:
            self.Period = Period
        self.Properties = Properties
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumeProduct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumeProduct.subclass:
            return ProductVolumeProduct.subclass(*args_, **kwargs_)
        else:
            return ProductVolumeProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    KindProp = property(get_Kind, set_Kind)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_SplitFactor(self): return self.SplitFactor
    def set_SplitFactor(self, SplitFactor): self.SplitFactor = SplitFactor
    SplitFactorProp = property(get_SplitFactor, set_SplitFactor)
    def get_MassFraction(self): return self.MassFraction
    def set_MassFraction(self, MassFraction): self.MassFraction = MassFraction
    MassFractionProp = property(get_MassFraction, set_MassFraction)
    def get_MoleFraction(self): return self.MoleFraction
    def set_MoleFraction(self, MoleFraction): self.MoleFraction = MoleFraction
    MoleFractionProp = property(get_MoleFraction, set_MoleFraction)
    def get_ComponentContent(self): return self.ComponentContent
    def set_ComponentContent(self, ComponentContent): self.ComponentContent = ComponentContent
    def add_ComponentContent(self, value): self.ComponentContent.append(value)
    def insert_ComponentContent_at(self, index, value): self.ComponentContent.insert(index, value)
    def replace_ComponentContent_at(self, index, value): self.ComponentContent[index] = value
    ComponentContentProp = property(get_ComponentContent, set_ComponentContent)
    def get_SourceFlow(self): return self.SourceFlow
    def set_SourceFlow(self, SourceFlow): self.SourceFlow = SourceFlow
    SourceFlowProp = property(get_SourceFlow, set_SourceFlow)
    def get_Period(self): return self.Period
    def set_Period(self, Period): self.Period = Period
    def add_Period(self, value): self.Period.append(value)
    def insert_Period_at(self, index, value): self.Period.insert(index, value)
    def replace_Period_at(self, index, value): self.Period[index] = value
    PeriodProp = property(get_Period, set_Period)
    def get_Properties(self): return self.Properties
    def set_Properties(self, Properties): self.Properties = Properties
    PropertiesProp = property(get_Properties, set_Properties)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_ReportingProduct(self, value):
        # Validate type ReportingProduct, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['aqueous', 'c10', 'c10-', 'c10+', 'c2-', 'c2+', 'c3-', 'c3+', 'c4-', 'c4+', 'c5-', 'c5+', 'c6-', 'c6+', 'c7', 'c7-', 'c7+', 'c8', 'c8-', 'c8+', 'c9', 'c9-', 'c9+', 'carbon dioxide gas', 'carbon monoxide gas', 'chemical', 'condensate', 'condensate - gross', 'condensate - net', 'crude - stabilized', 'cuttings', 'diesel', 'diethylene glycol', 'dioxygen', 'electric power', 'ethane', 'ethane - component', 'gas', 'gas - component in oil', 'gas - dry', 'gas - rich', 'gas - wet', 'helium gas', 'heptane', 'hydraulic control fluid', 'hydrogen gas', 'hydrogen sulfide', 'i-butane - component', 'isobutane', 'isopentane', 'liquefied natural gas', 'liquefied petroleum gas', 'liquid', 'methane', 'methane - component', 'methanol', 'mixed butane', 'monoethylene glycol', 'naphtha', 'natural gas liquid', 'n-butane - component', 'neopentane', 'NGL - component in gas', 'nitrogen gas', 'nitrogen oxide gas', 'normal butane', 'normal pentane', 'oil', 'oil - component in water', 'oil - gross', 'oil - net', 'oil and gas', 'oleic', 'pentane - component', 'petroleum gas liquid', 'propane', 'propane - component', 'salt', 'sand - component', 'triethylene glycol', 'unknown', 'vapor', 'water', 'water - discharge', 'water - processed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReportingProduct' % {"value" : value.encode("utf-8")} )
    def validate_NonNegativeFraction(self, value):
        # Validate type NonNegativeFraction, a restriction on xs:float.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeFraction' % {"value" : value} )
            if value > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on NonNegativeFraction' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Kind is not None or
            self.Name is not None or
            self.SplitFactor is not None or
            self.MassFraction is not None or
            self.MoleFraction is not None or
            self.ComponentContent or
            self.SourceFlow is not None or
            self.Period or
            self.Properties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumeProduct', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumeProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumeProduct', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumeProduct'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumeProduct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKind>%s</%sKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Kind), input_name='Kind')), namespace_, eol_))
        if self.Name is not None:
            self.Name.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        if self.SplitFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSplitFactor>%s</%sSplitFactor>%s' % (namespace_, self.gds_format_float(self.SplitFactor, input_name='SplitFactor'), namespace_, eol_))
        if self.MassFraction is not None:
            self.MassFraction.export(outfile, level, namespace_, name_='MassFraction', pretty_print=pretty_print)
        if self.MoleFraction is not None:
            self.MoleFraction.export(outfile, level, namespace_, name_='MoleFraction', pretty_print=pretty_print)
        for ComponentContent_ in self.ComponentContent:
            ComponentContent_.export(outfile, level, namespace_, name_='ComponentContent', pretty_print=pretty_print)
        if self.SourceFlow is not None:
            self.SourceFlow.export(outfile, level, namespace_, name_='SourceFlow', pretty_print=pretty_print)
        for Period_ in self.Period:
            Period_.export(outfile, level, namespace_, name_='Period', pretty_print=pretty_print)
        if self.Properties is not None:
            self.Properties.export(outfile, level, namespace_, name_='Properties', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Kind':
            Kind_ = child_.text
            Kind_ = self.gds_validate_string(Kind_, node, 'Kind')
            self.Kind = Kind_
            # validate type ReportingProduct
            self.validate_ReportingProduct(self.Kind)
        elif nodeName_ == 'Name':
            obj_ = NameStruct.factory()
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'SplitFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SplitFactor')
            self.SplitFactor = fval_
            # validate type NonNegativeFraction
            self.validate_NonNegativeFraction(self.SplitFactor)
        elif nodeName_ == 'MassFraction':
            obj_ = MassPerMassMeasure.factory()
            obj_.build(child_)
            self.MassFraction = obj_
            obj_.original_tagname_ = 'MassFraction'
        elif nodeName_ == 'MoleFraction':
            obj_ = AmountOfSubstancePerAmountOfSubstanceMeasure.factory()
            obj_.build(child_)
            self.MoleFraction = obj_
            obj_.original_tagname_ = 'MoleFraction'
        elif nodeName_ == 'ComponentContent':
            obj_ = ProductVolumeComponentContent.factory()
            obj_.build(child_)
            self.ComponentContent.append(obj_)
            obj_.original_tagname_ = 'ComponentContent'
        elif nodeName_ == 'SourceFlow':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <SourceFlow> element')
            self.SourceFlow = obj_
            obj_.original_tagname_ = 'SourceFlow'
        elif nodeName_ == 'Period':
            obj_ = ProductVolumePeriod.factory()
            obj_.build(child_)
            self.Period.append(obj_)
            obj_.original_tagname_ = 'Period'
        elif nodeName_ == 'Properties':
            obj_ = CommonPropertiesProductVolume.factory()
            obj_.build(child_)
            self.Properties = obj_
            obj_.original_tagname_ = 'Properties'
# end class ProductVolumeProduct


class ProductVolumeRelatedFacility(GeneratedsSuper):
    """A second facility related to this flow. For a production flow, this
    would represent a role of 'produced for'. For an import flow,
    this would represent a role of 'import from'. For an export
    flow, this would represent a role of 'export to'."""
    subclass = None
    superclass = None
    def __init__(self, Kind=None, RelatedFacilityObject=None):
        self.original_tagname_ = None
        self.Kind = Kind
        self.validate_ReportingFacility(self.Kind)
        self.RelatedFacilityObject = RelatedFacilityObject
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolumeRelatedFacility)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolumeRelatedFacility.subclass:
            return ProductVolumeRelatedFacility.subclass(*args_, **kwargs_)
        else:
            return ProductVolumeRelatedFacility(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    KindProp = property(get_Kind, set_Kind)
    def get_RelatedFacilityObject(self): return self.RelatedFacilityObject
    def set_RelatedFacilityObject(self, RelatedFacilityObject): self.RelatedFacilityObject = RelatedFacilityObject
    RelatedFacilityObjectProp = property(get_RelatedFacilityObject, set_RelatedFacilityObject)
    def validate_ReportingFacility(self, value):
        # Validate type ReportingFacility, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['block valve', 'bottomhole', 'casing', 'choke', 'cluster', 'commercial entity', 'company', 'completion', 'compressor', 'controller', 'controller -- lift', 'country', 'county', 'downhole monitoring system', 'electric submersible pump', 'field', 'field - area', 'field - group', 'field - part', 'flow meter', 'flowline', 'formation', 'gas lift valve mandrel', 'generator', 'installation', 'lease', 'license', 'manifold', 'organizational unit', 'packer', 'perforated interval', 'pipeline', 'plant - processing', 'platform', 'pressure meter', 'processing facility', 'production tubing', 'pump', 'rectifier', 'regulating valve', 'remote terminal unit', 'reservoir', 'separator', 'sleeve valve', 'state', 'storage', 'tank', 'temperature meter', 'template', 'terminal', 'trap', 'trunkline', 'tubing head', 'turbine', 'unknown', 'well', 'well group', 'wellbore', 'wellhead', 'zone']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReportingFacility' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Kind is not None or
            self.RelatedFacilityObject is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolumeRelatedFacility', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolumeRelatedFacility')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolumeRelatedFacility', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolumeRelatedFacility'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolumeRelatedFacility', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKind>%s</%sKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Kind), input_name='Kind')), namespace_, eol_))
        if self.RelatedFacilityObject is not None:
            self.RelatedFacilityObject.export(outfile, level, namespace_, name_='RelatedFacilityObject', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Kind':
            Kind_ = child_.text
            Kind_ = self.gds_validate_string(Kind_, node, 'Kind')
            self.Kind = Kind_
            # validate type ReportingFacility
            self.validate_ReportingFacility(self.Kind)
        elif nodeName_ == 'RelatedFacilityObject':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <RelatedFacilityObject> element')
            self.RelatedFacilityObject = obj_
            obj_.original_tagname_ = 'RelatedFacilityObject'
# end class ProductVolumeRelatedFacility


class ReferenceFlow(AbstractRefProductFlow):
    """Reference flow."""
    subclass = None
    superclass = AbstractRefProductFlow
    def __init__(self, FlowReference=None):
        self.original_tagname_ = None
        super(ReferenceFlow, self).__init__()
        self.FlowReference = FlowReference
        self.validate_String64(self.FlowReference)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceFlow)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceFlow.subclass:
            return ReferenceFlow.subclass(*args_, **kwargs_)
        else:
            return ReferenceFlow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FlowReference(self): return self.FlowReference
    def set_FlowReference(self, FlowReference): self.FlowReference = FlowReference
    FlowReferenceProp = property(get_FlowReference, set_FlowReference)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.FlowReference is not None or
            super(ReferenceFlow, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReferenceFlow', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceFlow')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReferenceFlow', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReferenceFlow'):
        super(ReferenceFlow, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceFlow')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReferenceFlow', fromsubclass_=False, pretty_print=True):
        super(ReferenceFlow, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FlowReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFlowReference>%s</%sFlowReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FlowReference), input_name='FlowReference')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReferenceFlow, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FlowReference':
            FlowReference_ = child_.text
            FlowReference_ = self.gds_validate_string(FlowReference_, node, 'FlowReference')
            self.FlowReference = FlowReference_
            # validate type String64
            self.validate_String64(self.FlowReference)
        super(ReferenceFlow, self).buildChildren(child_, node, nodeName_, True)
# end class ReferenceFlow


class StringData(AbstractMeasureDataType):
    """String data."""
    subclass = None
    superclass = AbstractMeasureDataType
    def __init__(self, StringValue=None):
        self.original_tagname_ = None
        super(StringData, self).__init__()
        self.StringValue = StringValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringData.subclass:
            return StringData.subclass(*args_, **kwargs_)
        else:
            return StringData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StringValue(self): return self.StringValue
    def set_StringValue(self, StringValue): self.StringValue = StringValue
    StringValueProp = property(get_StringValue, set_StringValue)
    def hasContent_(self):
        if (
            self.StringValue is not None or
            super(StringData, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='StringData', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StringData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='StringData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='StringData'):
        super(StringData, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StringData')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='StringData', fromsubclass_=False, pretty_print=True):
        super(StringData, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StringValue is not None:
            self.StringValue.export(outfile, level, namespace_, name_='StringValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StringData, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StringValue':
            obj_ = KindQualifiedString.factory()
            obj_.build(child_)
            self.StringValue = obj_
            obj_.original_tagname_ = 'StringValue'
        super(StringData, self).buildChildren(child_, node, nodeName_, True)
# end class StringData


class ConnectedNode(GeneratedsSuper):
    """Product Flow Connected Node Schema.A unique identifier for this data
    element. It is not globally unique (not a uuid) and only need be
    unique within the context of the parent top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Node=None, PlanName=None, DTimStart=None, DTimEnd=None, Comment=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Node = Node
        self.validate_String64(self.Node)
        self.PlanName = PlanName
        self.validate_String64(self.PlanName)
        if isinstance(DTimStart, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DTimStart, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DTimStart
        self.DTimStart = initvalue_
        if isinstance(DTimEnd, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DTimEnd, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DTimEnd
        self.DTimEnd = initvalue_
        self.Comment = Comment
        self.validate_String2000(self.Comment)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConnectedNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConnectedNode.subclass:
            return ConnectedNode.subclass(*args_, **kwargs_)
        else:
            return ConnectedNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Node(self): return self.Node
    def set_Node(self, Node): self.Node = Node
    NodeProp = property(get_Node, set_Node)
    def get_PlanName(self): return self.PlanName
    def set_PlanName(self, PlanName): self.PlanName = PlanName
    PlanNameProp = property(get_PlanName, set_PlanName)
    def get_DTimStart(self): return self.DTimStart
    def set_DTimStart(self, DTimStart): self.DTimStart = DTimStart
    DTimStartProp = property(get_DTimStart, set_DTimStart)
    def get_DTimEnd(self): return self.DTimEnd
    def set_DTimEnd(self, DTimEnd): self.DTimEnd = DTimEnd
    DTimEndProp = property(get_DTimEnd, set_DTimEnd)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Node is not None or
            self.PlanName is not None or
            self.DTimStart is not None or
            self.DTimEnd is not None or
            self.Comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ConnectedNode', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConnectedNode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ConnectedNode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ConnectedNode'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ConnectedNode', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Node is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNode>%s</%sNode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Node), input_name='Node')), namespace_, eol_))
        if self.PlanName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlanName>%s</%sPlanName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PlanName), input_name='PlanName')), namespace_, eol_))
        if self.DTimStart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTimStart>%s</%sDTimStart>%s' % (namespace_, self.gds_format_datetime(self.DTimStart, input_name='DTimStart'), namespace_, eol_))
        if self.DTimEnd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTimEnd>%s</%sDTimEnd>%s' % (namespace_, self.gds_format_datetime(self.DTimEnd, input_name='DTimEnd'), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Node':
            Node_ = child_.text
            Node_ = self.gds_validate_string(Node_, node, 'Node')
            self.Node = Node_
            # validate type String64
            self.validate_String64(self.Node)
        elif nodeName_ == 'PlanName':
            PlanName_ = child_.text
            PlanName_ = self.gds_validate_string(PlanName_, node, 'PlanName')
            self.PlanName = PlanName_
            # validate type String64
            self.validate_String64(self.PlanName)
        elif nodeName_ == 'DTimStart':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DTimStart = dval_
        elif nodeName_ == 'DTimEnd':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DTimEnd = dval_
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
# end class ConnectedNode


class ExpectedFlowQualifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExpectedFlowQualifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExpectedFlowQualifier.subclass:
            return ExpectedFlowQualifier.subclass(*args_, **kwargs_)
        else:
            return ExpectedFlowQualifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ExpectedFlowQualifier', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExpectedFlowQualifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ExpectedFlowQualifier', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ExpectedFlowQualifier'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ExpectedFlowQualifier', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExpectedFlowQualifier


class ProductFlowChangeLog(GeneratedsSuper):
    """Documents the point in time where changes were made.A unique
    identifier for this data element. It is not globally unique (not
    a uuid) and only need be unique within the context of the parent
    top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Name=None, DTim=None, Reason=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Name = Name
        self.validate_String64(self.Name)
        if isinstance(DTim, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DTim, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DTim
        self.DTim = initvalue_
        self.Reason = Reason
        self.validate_String2000(self.Reason)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductFlowChangeLog)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductFlowChangeLog.subclass:
            return ProductFlowChangeLog.subclass(*args_, **kwargs_)
        else:
            return ProductFlowChangeLog(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_DTim(self): return self.DTim
    def set_DTim(self, DTim): self.DTim = DTim
    DTimProp = property(get_DTim, set_DTim)
    def get_Reason(self): return self.Reason
    def set_Reason(self, Reason): self.Reason = Reason
    ReasonProp = property(get_Reason, set_Reason)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.DTim is not None or
            self.Reason is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductFlowChangeLog', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductFlowChangeLog')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductFlowChangeLog', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductFlowChangeLog'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductFlowChangeLog', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.DTim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTim>%s</%sDTim>%s' % (namespace_, self.gds_format_datetime(self.DTim, input_name='DTim'), namespace_, eol_))
        if self.Reason is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReason>%s</%sReason>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Reason), input_name='Reason')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'DTim':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DTim = dval_
        elif nodeName_ == 'Reason':
            Reason_ = child_.text
            Reason_ = self.gds_validate_string(Reason_, node, 'Reason')
            self.Reason = Reason_
            # validate type String2000
            self.validate_String2000(self.Reason)
# end class ProductFlowChangeLog


class ProductFlowExpectedUnitProperty(GeneratedsSuper):
    """Defines expected properties of a facility represented by a unit.A
    unique identifier for this data element. It is not globally
    unique (not a uuid) and only need be unique within the context
    of the parent top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Property=None, ChildFacilityIdentifier=None, TagAlias=None, Deadband=None, MaximumFrequency=None, Comment=None, ExpectedFlowQualifier=None, ExpectedFlowProduct=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Property = Property
        self.validate_FacilityParameter(self.Property)
        self.ChildFacilityIdentifier = ChildFacilityIdentifier
        self.validate_ProdmlRelativeIdentifier(self.ChildFacilityIdentifier)
        if TagAlias is None:
            self.TagAlias = []
        else:
            self.TagAlias = TagAlias
        self.Deadband = Deadband
        self.MaximumFrequency = MaximumFrequency
        self.Comment = Comment
        self.validate_String2000(self.Comment)
        self.ExpectedFlowQualifier = ExpectedFlowQualifier
        if ExpectedFlowProduct is None:
            self.ExpectedFlowProduct = []
        else:
            self.ExpectedFlowProduct = ExpectedFlowProduct
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductFlowExpectedUnitProperty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductFlowExpectedUnitProperty.subclass:
            return ProductFlowExpectedUnitProperty.subclass(*args_, **kwargs_)
        else:
            return ProductFlowExpectedUnitProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    PropertyProp = property(get_Property, set_Property)
    def get_ChildFacilityIdentifier(self): return self.ChildFacilityIdentifier
    def set_ChildFacilityIdentifier(self, ChildFacilityIdentifier): self.ChildFacilityIdentifier = ChildFacilityIdentifier
    ChildFacilityIdentifierProp = property(get_ChildFacilityIdentifier, set_ChildFacilityIdentifier)
    def get_TagAlias(self): return self.TagAlias
    def set_TagAlias(self, TagAlias): self.TagAlias = TagAlias
    def add_TagAlias(self, value): self.TagAlias.append(value)
    def insert_TagAlias_at(self, index, value): self.TagAlias.insert(index, value)
    def replace_TagAlias_at(self, index, value): self.TagAlias[index] = value
    TagAliasProp = property(get_TagAlias, set_TagAlias)
    def get_Deadband(self): return self.Deadband
    def set_Deadband(self, Deadband): self.Deadband = Deadband
    DeadbandProp = property(get_Deadband, set_Deadband)
    def get_MaximumFrequency(self): return self.MaximumFrequency
    def set_MaximumFrequency(self, MaximumFrequency): self.MaximumFrequency = MaximumFrequency
    MaximumFrequencyProp = property(get_MaximumFrequency, set_MaximumFrequency)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_ExpectedFlowQualifier(self): return self.ExpectedFlowQualifier
    def set_ExpectedFlowQualifier(self, ExpectedFlowQualifier): self.ExpectedFlowQualifier = ExpectedFlowQualifier
    ExpectedFlowQualifierProp = property(get_ExpectedFlowQualifier, set_ExpectedFlowQualifier)
    def get_ExpectedFlowProduct(self): return self.ExpectedFlowProduct
    def set_ExpectedFlowProduct(self, ExpectedFlowProduct): self.ExpectedFlowProduct = ExpectedFlowProduct
    def add_ExpectedFlowProduct(self, value): self.ExpectedFlowProduct.append(value)
    def insert_ExpectedFlowProduct_at(self, index, value): self.ExpectedFlowProduct.insert(index, value)
    def replace_ExpectedFlowProduct_at(self, index, value): self.ExpectedFlowProduct[index] = value
    ExpectedFlowProductProp = property(get_ExpectedFlowProduct, set_ExpectedFlowProduct)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_FacilityParameter(self, value):
        # Validate type FacilityParameter, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['absorbed dose class', 'acceleration linear class', 'activity (of radioactivity) class', 'alarm absolute pressure', 'amount of substance class', 'angle per length', 'angle per time', 'angle per volume', 'angular acceleration class', 'annulus inner diameter', 'annulus outer diameter', 'area class', 'area per area', 'area per volume', 'atmospheric pressure', 'attenuation class', 'attenuation per length', 'available', 'available room', 'block valve status', 'capacitance class', 'categorical', 'cathodic protection output current', 'cathodic protection output voltage', 'charge density class', 'chemical potential class', 'choke position', 'choke setting', 'code', 'compressibility class', 'concentration of B class', 'conductivity class', 'continuous', 'cross section absorption class', 'current density class', 'darcy flow coefficient class', 'data transmission speed class', 'delta temperature class', 'density', 'density class', 'density flow rate', 'density standard', 'dewpoint temperature', 'differential pressure', 'differential temperature', 'diffusion coefficient class', 'digital storage class', 'dimensionless class', 'discrete', 'dose equivalent class', 'dose equivalent rate class', 'dynamic viscosity class', 'electric charge class', 'electric conductance class', 'electric current class', 'electric dipole moment class', 'electric field strength class', 'electric polarization class', 'electric potential class', 'electrical resistivity class', 'electrochemical equivalent class', 'electromagnetic moment class', 'energy length per area', 'energy length per time area temperature', 'energy per area', 'energy per length', 'equivalent per mass', 'equivalent per volume', 'exposure (radioactivity) class', 'facility uptime', 'flow rate', 'flow rate standard', 'force area class', 'force class', 'force length per length', 'force per force', 'force per length', 'force per volume', 'frequency class', 'frequency interval class', 'gamma ray API unit class', 'gas liquid ratio', 'gas oil ratio', 'gross calorific value standard', 'heat capacity class', 'heat flow rate class', 'heat transfer coefficient class', 'illuminance class', 'internal control valve status', 'irradiance class', 'isothermal compressibility class', 'kinematic viscosity class', 'length class', 'length per length', 'length per temperature', 'length per volume', 'level of power intensity class', 'light exposure class', 'linear thermal expansion class', 'luminance class', 'luminous efficacy class', 'luminous flux class', 'luminous intensity class', 'magnetic dipole moment class', 'magnetic field strength class', 'magnetic flux class', 'magnetic induction class', 'magnetic permeability class', 'magnetic vector potential class', 'mass', 'mass attenuation coefficient class', 'mass class', 'mass concentration', 'mass concentration class', 'mass flow rate class', 'mass length class', 'mass per energy', 'mass per length', 'mass per time per area', 'mass per time per length', 'mass per volume per length', 'measured depth', 'mobility class', 'modulus of compression class', 'molar concentration', 'molar fraction', 'molar heat capacity class', 'molar volume class', 'mole per area', 'mole per time', 'mole per time per area', 'molecular weight', 'moment of force class', 'moment of inertia class', 'moment of section class', 'momentum class', 'motor current', 'motor current leakage', 'motor speed', 'motor temperature', 'motor vibration', 'motor voltage', 'neutron API unit class', 'nonDarcy flow coefficient class', 'opening size', 'operations per time', 'parachor class', 'per area', 'per electric potential', 'per force', 'per length', 'per mass', 'per volume', 'permeability length class', 'permeability rock class', 'permeance class', 'permittivity class', 'pH class', 'plane angle class', 'potential difference per power drop', 'power class', 'power per volume', 'pressure', 'pressure class', 'pressure per time', 'pressure squared class', 'pressure squared per force time per area', 'pressure time per volume', 'productivity index class', 'pump count online', 'pump status', 'quantity', 'quantity of light class', 'radiance class', 'radiant intensity class', 'reciprocating speed', 'rectifier structure potential', 'reid vapor pressure', 'relative opening size', 'relative power class', 'relative tank level', 'relative time class', 'relative valve opening', 'reluctance class', 'resistance class', 'resistivity per length', 'root property', 'scheduled downtime', 'second moment of area class', 'shutdown order', 'shutin pressure', 'shutin temperature', 'solid angle class', 'specific activity (of radioactivity)', 'specific energy class', 'specific gravity', 'specific heat capacity class', 'specific productivity index class', 'specific volume class', 'sub surface safety valve status', 'surface density class', 'surface safety valve status', 'tank fluid level', 'tank product standard volume', 'tank product volume', 'temperature', 'temperature per length', 'temperature per time', 'thermal conductance class', 'thermal conductivity class', 'thermal diffusivity class', 'thermal insulance class', 'thermal resistance class', 'thermodynamic temperature class', 'time class', 'time per length', 'time per volume', 'true vapor pressure', 'unit productivity index class', 'unitless', 'unknown', 'valve opening', 'valve status', 'velocity class', 'volume', 'volume class', 'volume concentration', 'volume flow rate class', 'volume length per time', 'volume per area', 'volume per length', 'volume per time per area', 'volume per time per length', 'volume per time per time', 'volume per time per volume', 'volume per volume', 'volume standard', 'volumetric efficiency', 'volumetric heat transfer coefficient', 'volumetric thermal expansion class', 'well operating status', 'well operation type', 'wobbe index', 'work', 'work class']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FacilityParameter' % {"value" : value.encode("utf-8")} )
    def validate_ProdmlRelativeIdentifier(self, value):
        # Validate type ProdmlRelativeIdentifier, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Property is not None or
            self.ChildFacilityIdentifier is not None or
            self.TagAlias or
            self.Deadband is not None or
            self.MaximumFrequency is not None or
            self.Comment is not None or
            self.ExpectedFlowQualifier is not None or
            self.ExpectedFlowProduct
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductFlowExpectedUnitProperty', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductFlowExpectedUnitProperty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductFlowExpectedUnitProperty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductFlowExpectedUnitProperty'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductFlowExpectedUnitProperty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Property is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProperty>%s</%sProperty>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Property), input_name='Property')), namespace_, eol_))
        if self.ChildFacilityIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChildFacilityIdentifier>%s</%sChildFacilityIdentifier>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ChildFacilityIdentifier), input_name='ChildFacilityIdentifier')), namespace_, eol_))
        for TagAlias_ in self.TagAlias:
            TagAlias_.export(outfile, level, namespace_, name_='TagAlias', pretty_print=pretty_print)
        if self.Deadband is not None:
            self.Deadband.export(outfile, level, namespace_, name_='Deadband', pretty_print=pretty_print)
        if self.MaximumFrequency is not None:
            self.MaximumFrequency.export(outfile, level, namespace_, name_='MaximumFrequency', pretty_print=pretty_print)
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
        if self.ExpectedFlowQualifier is not None:
            self.ExpectedFlowQualifier.export(outfile, level, namespace_, name_='ExpectedFlowQualifier', pretty_print=pretty_print)
        for ExpectedFlowProduct_ in self.ExpectedFlowProduct:
            ExpectedFlowProduct_.export(outfile, level, namespace_, name_='ExpectedFlowProduct', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Property':
            Property_ = child_.text
            Property_ = self.gds_validate_string(Property_, node, 'Property')
            self.Property = Property_
            # validate type FacilityParameter
            self.validate_FacilityParameter(self.Property)
        elif nodeName_ == 'ChildFacilityIdentifier':
            ChildFacilityIdentifier_ = child_.text
            ChildFacilityIdentifier_ = self.gds_validate_string(ChildFacilityIdentifier_, node, 'ChildFacilityIdentifier')
            self.ChildFacilityIdentifier = ChildFacilityIdentifier_
            # validate type ProdmlRelativeIdentifier
            self.validate_ProdmlRelativeIdentifier(self.ChildFacilityIdentifier)
        elif nodeName_ == 'TagAlias':
            obj_ = NameStruct.factory()
            obj_.build(child_)
            self.TagAlias.append(obj_)
            obj_.original_tagname_ = 'TagAlias'
        elif nodeName_ == 'Deadband':
            obj_ = GeneralMeasureType.factory()
            obj_.build(child_)
            self.Deadband = obj_
            obj_.original_tagname_ = 'Deadband'
        elif nodeName_ == 'MaximumFrequency':
            obj_ = TimeMeasure.factory()
            obj_.build(child_)
            self.MaximumFrequency = obj_
            obj_.original_tagname_ = 'MaximumFrequency'
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        elif nodeName_ == 'ExpectedFlowQualifier':
            class_obj_ = self.get_class_obj_(child_, ExpectedFlowQualifier)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ExpectedFlowQualifier = obj_
            obj_.original_tagname_ = 'ExpectedFlowQualifier'
        elif nodeName_ == 'ExpectedFlowProduct':
            obj_ = ProductFlowQualifierExpected.factory()
            obj_.build(child_)
            self.ExpectedFlowProduct.append(obj_)
            obj_.original_tagname_ = 'ExpectedFlowProduct'
# end class ProductFlowExpectedUnitProperty


class ProductFlowExternalPort(GeneratedsSuper):
    """Product Flow Network External Port Schema.A unique identifier for
    this data element. It is not globally unique (not a uuid) and
    only need be unique within the context of the parent top-level
    object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Name=None, Direction=None, Exposed=None, ConnectedNode=None, Comment=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Name = Name
        self.validate_String64(self.Name)
        self.Direction = Direction
        self.validate_ProductFlowPortType(self.Direction)
        self.Exposed = Exposed
        self.ConnectedNode = ConnectedNode
        self.validate_String64(self.ConnectedNode)
        self.Comment = Comment
        self.validate_String2000(self.Comment)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductFlowExternalPort)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductFlowExternalPort.subclass:
            return ProductFlowExternalPort.subclass(*args_, **kwargs_)
        else:
            return ProductFlowExternalPort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_Direction(self): return self.Direction
    def set_Direction(self, Direction): self.Direction = Direction
    DirectionProp = property(get_Direction, set_Direction)
    def get_Exposed(self): return self.Exposed
    def set_Exposed(self, Exposed): self.Exposed = Exposed
    ExposedProp = property(get_Exposed, set_Exposed)
    def get_ConnectedNode(self): return self.ConnectedNode
    def set_ConnectedNode(self, ConnectedNode): self.ConnectedNode = ConnectedNode
    ConnectedNodeProp = property(get_ConnectedNode, set_ConnectedNode)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_ProductFlowPortType(self, value):
        # Validate type ProductFlowPortType, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inlet', 'outlet', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ProductFlowPortType' % {"value" : value.encode("utf-8")} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Direction is not None or
            self.Exposed is not None or
            self.ConnectedNode is not None or
            self.Comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductFlowExternalPort', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductFlowExternalPort')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductFlowExternalPort', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductFlowExternalPort'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductFlowExternalPort', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.Direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDirection>%s</%sDirection>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Direction), input_name='Direction')), namespace_, eol_))
        if self.Exposed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExposed>%s</%sExposed>%s' % (namespace_, self.gds_format_boolean(self.Exposed, input_name='Exposed'), namespace_, eol_))
        if self.ConnectedNode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConnectedNode>%s</%sConnectedNode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ConnectedNode), input_name='ConnectedNode')), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'Direction':
            Direction_ = child_.text
            Direction_ = self.gds_validate_string(Direction_, node, 'Direction')
            self.Direction = Direction_
            # validate type ProductFlowPortType
            self.validate_ProductFlowPortType(self.Direction)
        elif nodeName_ == 'Exposed':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Exposed')
            self.Exposed = ival_
        elif nodeName_ == 'ConnectedNode':
            ConnectedNode_ = child_.text
            ConnectedNode_ = self.gds_validate_string(ConnectedNode_, node, 'ConnectedNode')
            self.ConnectedNode = ConnectedNode_
            # validate type String64
            self.validate_String64(self.ConnectedNode)
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
# end class ProductFlowExternalPort


class ProductFlowNetworkPlan(GeneratedsSuper):
    """A plan to extend an actual network.A unique identifier for this data
    element. It is not globally unique (not a uuid) and only need be
    unique within the context of the parent top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Name=None, DTimStart=None, Purpose=None, ChangeLog=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Name = Name
        self.validate_String64(self.Name)
        if isinstance(DTimStart, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DTimStart, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DTimStart
        self.DTimStart = initvalue_
        self.Purpose = Purpose
        self.validate_String2000(self.Purpose)
        if ChangeLog is None:
            self.ChangeLog = []
        else:
            self.ChangeLog = ChangeLog
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductFlowNetworkPlan)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductFlowNetworkPlan.subclass:
            return ProductFlowNetworkPlan.subclass(*args_, **kwargs_)
        else:
            return ProductFlowNetworkPlan(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_DTimStart(self): return self.DTimStart
    def set_DTimStart(self, DTimStart): self.DTimStart = DTimStart
    DTimStartProp = property(get_DTimStart, set_DTimStart)
    def get_Purpose(self): return self.Purpose
    def set_Purpose(self, Purpose): self.Purpose = Purpose
    PurposeProp = property(get_Purpose, set_Purpose)
    def get_ChangeLog(self): return self.ChangeLog
    def set_ChangeLog(self, ChangeLog): self.ChangeLog = ChangeLog
    def add_ChangeLog(self, value): self.ChangeLog.append(value)
    def insert_ChangeLog_at(self, index, value): self.ChangeLog.insert(index, value)
    def replace_ChangeLog_at(self, index, value): self.ChangeLog[index] = value
    ChangeLogProp = property(get_ChangeLog, set_ChangeLog)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.DTimStart is not None or
            self.Purpose is not None or
            self.ChangeLog
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductFlowNetworkPlan', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductFlowNetworkPlan')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductFlowNetworkPlan', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductFlowNetworkPlan'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductFlowNetworkPlan', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.DTimStart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTimStart>%s</%sDTimStart>%s' % (namespace_, self.gds_format_datetime(self.DTimStart, input_name='DTimStart'), namespace_, eol_))
        if self.Purpose is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPurpose>%s</%sPurpose>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Purpose), input_name='Purpose')), namespace_, eol_))
        for ChangeLog_ in self.ChangeLog:
            ChangeLog_.export(outfile, level, namespace_, name_='ChangeLog', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'DTimStart':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DTimStart = dval_
        elif nodeName_ == 'Purpose':
            Purpose_ = child_.text
            Purpose_ = self.gds_validate_string(Purpose_, node, 'Purpose')
            self.Purpose = Purpose_
            # validate type String2000
            self.validate_String2000(self.Purpose)
        elif nodeName_ == 'ChangeLog':
            obj_ = ProductFlowChangeLog.factory()
            obj_.build(child_)
            self.ChangeLog.append(obj_)
            obj_.original_tagname_ = 'ChangeLog'
# end class ProductFlowNetworkPlan


class ProductFlowPort(GeneratedsSuper):
    """Product Flow Port Schema.A unique identifier for this data element.
    It is not globally unique (not a uuid) and only need be unique
    within the context of the parent top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Direction=None, Name=None, PlanName=None, Facility=None, FacilityAlias=None, Exposed=None, Comment=None, ExpectedFlowProperty=None, ConnectedNode=None, ExpectedFlowProduct=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Direction = Direction
        self.validate_ProductFlowPortType(self.Direction)
        self.Name = Name
        self.validate_String64(self.Name)
        self.PlanName = PlanName
        self.validate_String64(self.PlanName)
        self.Facility = Facility
        if FacilityAlias is None:
            self.FacilityAlias = []
        else:
            self.FacilityAlias = FacilityAlias
        self.Exposed = Exposed
        self.Comment = Comment
        self.validate_String2000(self.Comment)
        if ExpectedFlowProperty is None:
            self.ExpectedFlowProperty = []
        else:
            self.ExpectedFlowProperty = ExpectedFlowProperty
        if ConnectedNode is None:
            self.ConnectedNode = []
        else:
            self.ConnectedNode = ConnectedNode
        if ExpectedFlowProduct is None:
            self.ExpectedFlowProduct = []
        else:
            self.ExpectedFlowProduct = ExpectedFlowProduct
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductFlowPort)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductFlowPort.subclass:
            return ProductFlowPort.subclass(*args_, **kwargs_)
        else:
            return ProductFlowPort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Direction(self): return self.Direction
    def set_Direction(self, Direction): self.Direction = Direction
    DirectionProp = property(get_Direction, set_Direction)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_PlanName(self): return self.PlanName
    def set_PlanName(self, PlanName): self.PlanName = PlanName
    PlanNameProp = property(get_PlanName, set_PlanName)
    def get_Facility(self): return self.Facility
    def set_Facility(self, Facility): self.Facility = Facility
    FacilityProp = property(get_Facility, set_Facility)
    def get_FacilityAlias(self): return self.FacilityAlias
    def set_FacilityAlias(self, FacilityAlias): self.FacilityAlias = FacilityAlias
    def add_FacilityAlias(self, value): self.FacilityAlias.append(value)
    def insert_FacilityAlias_at(self, index, value): self.FacilityAlias.insert(index, value)
    def replace_FacilityAlias_at(self, index, value): self.FacilityAlias[index] = value
    FacilityAliasProp = property(get_FacilityAlias, set_FacilityAlias)
    def get_Exposed(self): return self.Exposed
    def set_Exposed(self, Exposed): self.Exposed = Exposed
    ExposedProp = property(get_Exposed, set_Exposed)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_ExpectedFlowProperty(self): return self.ExpectedFlowProperty
    def set_ExpectedFlowProperty(self, ExpectedFlowProperty): self.ExpectedFlowProperty = ExpectedFlowProperty
    def add_ExpectedFlowProperty(self, value): self.ExpectedFlowProperty.append(value)
    def insert_ExpectedFlowProperty_at(self, index, value): self.ExpectedFlowProperty.insert(index, value)
    def replace_ExpectedFlowProperty_at(self, index, value): self.ExpectedFlowProperty[index] = value
    ExpectedFlowPropertyProp = property(get_ExpectedFlowProperty, set_ExpectedFlowProperty)
    def get_ConnectedNode(self): return self.ConnectedNode
    def set_ConnectedNode(self, ConnectedNode): self.ConnectedNode = ConnectedNode
    def add_ConnectedNode(self, value): self.ConnectedNode.append(value)
    def insert_ConnectedNode_at(self, index, value): self.ConnectedNode.insert(index, value)
    def replace_ConnectedNode_at(self, index, value): self.ConnectedNode[index] = value
    ConnectedNodeProp = property(get_ConnectedNode, set_ConnectedNode)
    def get_ExpectedFlowProduct(self): return self.ExpectedFlowProduct
    def set_ExpectedFlowProduct(self, ExpectedFlowProduct): self.ExpectedFlowProduct = ExpectedFlowProduct
    def add_ExpectedFlowProduct(self, value): self.ExpectedFlowProduct.append(value)
    def insert_ExpectedFlowProduct_at(self, index, value): self.ExpectedFlowProduct.insert(index, value)
    def replace_ExpectedFlowProduct_at(self, index, value): self.ExpectedFlowProduct[index] = value
    ExpectedFlowProductProp = property(get_ExpectedFlowProduct, set_ExpectedFlowProduct)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_ProductFlowPortType(self, value):
        # Validate type ProductFlowPortType, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inlet', 'outlet', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ProductFlowPortType' % {"value" : value.encode("utf-8")} )
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Direction is not None or
            self.Name is not None or
            self.PlanName is not None or
            self.Facility is not None or
            self.FacilityAlias or
            self.Exposed is not None or
            self.Comment is not None or
            self.ExpectedFlowProperty or
            self.ConnectedNode or
            self.ExpectedFlowProduct
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductFlowPort', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductFlowPort')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductFlowPort', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductFlowPort'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductFlowPort', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDirection>%s</%sDirection>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Direction), input_name='Direction')), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.PlanName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlanName>%s</%sPlanName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PlanName), input_name='PlanName')), namespace_, eol_))
        if self.Facility is not None:
            self.Facility.export(outfile, level, namespace_, name_='Facility', pretty_print=pretty_print)
        for FacilityAlias_ in self.FacilityAlias:
            FacilityAlias_.export(outfile, level, namespace_, name_='FacilityAlias', pretty_print=pretty_print)
        if self.Exposed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExposed>%s</%sExposed>%s' % (namespace_, self.gds_format_boolean(self.Exposed, input_name='Exposed'), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
        for ExpectedFlowProperty_ in self.ExpectedFlowProperty:
            ExpectedFlowProperty_.export(outfile, level, namespace_, name_='ExpectedFlowProperty', pretty_print=pretty_print)
        for ConnectedNode_ in self.ConnectedNode:
            ConnectedNode_.export(outfile, level, namespace_, name_='ConnectedNode', pretty_print=pretty_print)
        for ExpectedFlowProduct_ in self.ExpectedFlowProduct:
            ExpectedFlowProduct_.export(outfile, level, namespace_, name_='ExpectedFlowProduct', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Direction':
            Direction_ = child_.text
            Direction_ = self.gds_validate_string(Direction_, node, 'Direction')
            self.Direction = Direction_
            # validate type ProductFlowPortType
            self.validate_ProductFlowPortType(self.Direction)
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'PlanName':
            PlanName_ = child_.text
            PlanName_ = self.gds_validate_string(PlanName_, node, 'PlanName')
            self.PlanName = PlanName_
            # validate type String64
            self.validate_String64(self.PlanName)
        elif nodeName_ == 'Facility':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.Facility = obj_
            obj_.original_tagname_ = 'Facility'
        elif nodeName_ == 'FacilityAlias':
            obj_ = NameStruct.factory()
            obj_.build(child_)
            self.FacilityAlias.append(obj_)
            obj_.original_tagname_ = 'FacilityAlias'
        elif nodeName_ == 'Exposed':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Exposed')
            self.Exposed = ival_
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        elif nodeName_ == 'ExpectedFlowProperty':
            obj_ = ProductFlowExpectedUnitProperty.factory()
            obj_.build(child_)
            self.ExpectedFlowProperty.append(obj_)
            obj_.original_tagname_ = 'ExpectedFlowProperty'
        elif nodeName_ == 'ConnectedNode':
            obj_ = ConnectedNode.factory()
            obj_.build(child_)
            self.ConnectedNode.append(obj_)
            obj_.original_tagname_ = 'ConnectedNode'
        elif nodeName_ == 'ExpectedFlowProduct':
            obj_ = ProductFlowQualifierExpected.factory()
            obj_.build(child_)
            self.ExpectedFlowProduct.append(obj_)
            obj_.original_tagname_ = 'ExpectedFlowProduct'
# end class ProductFlowPort


class ProductFlowQualifierExpected(ExpectedFlowQualifier):
    """Defines an expected combination of kinds.A unique identifier for
    this data element. It is not globally unique (not a uuid) and
    only need be unique within the context of the parent top-level
    object."""
    subclass = None
    superclass = ExpectedFlowQualifier
    def __init__(self, uid=None, Flow=None, Product=None, Qualifier=None):
        self.original_tagname_ = None
        super(ProductFlowQualifierExpected, self).__init__()
        self.uid = _cast(None, uid)
        self.Flow = Flow
        self.validate_ReportingFlow(self.Flow)
        self.Product = Product
        self.validate_ReportingProduct(self.Product)
        if Qualifier is None:
            self.Qualifier = []
        else:
            self.Qualifier = Qualifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductFlowQualifierExpected)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductFlowQualifierExpected.subclass:
            return ProductFlowQualifierExpected.subclass(*args_, **kwargs_)
        else:
            return ProductFlowQualifierExpected(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Flow(self): return self.Flow
    def set_Flow(self, Flow): self.Flow = Flow
    FlowProp = property(get_Flow, set_Flow)
    def get_Product(self): return self.Product
    def set_Product(self, Product): self.Product = Product
    ProductProp = property(get_Product, set_Product)
    def get_Qualifier(self): return self.Qualifier
    def set_Qualifier(self, Qualifier): self.Qualifier = Qualifier
    def add_Qualifier(self, value): self.Qualifier.append(value)
    def insert_Qualifier_at(self, index, value): self.Qualifier.insert(index, value)
    def replace_Qualifier_at(self, index, value): self.Qualifier[index] = value
    QualifierProp = property(get_Qualifier, set_Qualifier)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_ReportingFlow(self, value):
        # Validate type ReportingFlow, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['consume', 'consume - black start', 'consume - compressor', 'consume - emitted', 'consume - flare', 'consume - fuel', 'consume - HP flare', 'consume - LP flare', 'consume - non compressor', 'consume - venting', 'disposal', 'export', 'export - nominated', 'export - requested', 'export - shortfall', 'gas lift', 'hydrocarbon accounting', 'import', 'injection', 'inventory', 'overboard', 'production', 'sale', 'storage', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReportingFlow' % {"value" : value.encode("utf-8")} )
    def validate_ReportingProduct(self, value):
        # Validate type ReportingProduct, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['aqueous', 'c10', 'c10-', 'c10+', 'c2-', 'c2+', 'c3-', 'c3+', 'c4-', 'c4+', 'c5-', 'c5+', 'c6-', 'c6+', 'c7', 'c7-', 'c7+', 'c8', 'c8-', 'c8+', 'c9', 'c9-', 'c9+', 'carbon dioxide gas', 'carbon monoxide gas', 'chemical', 'condensate', 'condensate - gross', 'condensate - net', 'crude - stabilized', 'cuttings', 'diesel', 'diethylene glycol', 'dioxygen', 'electric power', 'ethane', 'ethane - component', 'gas', 'gas - component in oil', 'gas - dry', 'gas - rich', 'gas - wet', 'helium gas', 'heptane', 'hydraulic control fluid', 'hydrogen gas', 'hydrogen sulfide', 'i-butane - component', 'isobutane', 'isopentane', 'liquefied natural gas', 'liquefied petroleum gas', 'liquid', 'methane', 'methane - component', 'methanol', 'mixed butane', 'monoethylene glycol', 'naphtha', 'natural gas liquid', 'n-butane - component', 'neopentane', 'NGL - component in gas', 'nitrogen gas', 'nitrogen oxide gas', 'normal butane', 'normal pentane', 'oil', 'oil - component in water', 'oil - gross', 'oil - net', 'oil and gas', 'oleic', 'pentane - component', 'petroleum gas liquid', 'propane', 'propane - component', 'salt', 'sand - component', 'triethylene glycol', 'unknown', 'vapor', 'water', 'water - discharge', 'water - processed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReportingProduct' % {"value" : value.encode("utf-8")} )
    def validate_FlowQualifier(self, value):
        # Validate type FlowQualifier, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['allocated', 'budget', 'constraint', 'derived', 'difference', 'estimate', 'forecast', 'mass adjusted', 'measured', 'metered', 'metered - fiscal', 'nominated', 'potential', 'processed', 'quota', 'recommended', 'simulated', 'target', 'tariff basis', 'value adjusted']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FlowQualifier' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Flow is not None or
            self.Product is not None or
            self.Qualifier or
            super(ProductFlowQualifierExpected, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductFlowQualifierExpected', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductFlowQualifierExpected')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductFlowQualifierExpected', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductFlowQualifierExpected'):
        super(ProductFlowQualifierExpected, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProductFlowQualifierExpected')
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductFlowQualifierExpected', fromsubclass_=False, pretty_print=True):
        super(ProductFlowQualifierExpected, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Flow is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFlow>%s</%sFlow>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Flow), input_name='Flow')), namespace_, eol_))
        if self.Product is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProduct>%s</%sProduct>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Product), input_name='Product')), namespace_, eol_))
        for Qualifier_ in self.Qualifier:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQualifier>%s</%sQualifier>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(Qualifier_), input_name='Qualifier')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
        super(ProductFlowQualifierExpected, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Flow':
            Flow_ = child_.text
            Flow_ = self.gds_validate_string(Flow_, node, 'Flow')
            self.Flow = Flow_
            # validate type ReportingFlow
            self.validate_ReportingFlow(self.Flow)
        elif nodeName_ == 'Product':
            Product_ = child_.text
            Product_ = self.gds_validate_string(Product_, node, 'Product')
            self.Product = Product_
            # validate type ReportingProduct
            self.validate_ReportingProduct(self.Product)
        elif nodeName_ == 'Qualifier':
            Qualifier_ = child_.text
            Qualifier_ = self.gds_validate_string(Qualifier_, node, 'Qualifier')
            self.Qualifier.append(Qualifier_)
            # validate type FlowQualifier
            self.validate_FlowQualifier(self.Qualifier[-1])
        super(ProductFlowQualifierExpected, self).buildChildren(child_, node, nodeName_, True)
# end class ProductFlowQualifierExpected


class ProductFlowUnit(GeneratedsSuper):
    """Product Flow Unit Schema.A unique identifier for this data element.
    It is not globally unique (not a uuid) and only need be unique
    within the context of the parent top-level object."""
    subclass = None
    superclass = None
    def __init__(self, uid=None, Name=None, PlanName=None, InternalNetworkReference=None, Facility=None, FacilityParent1=None, FacilityParent2=None, ContextFacility=None, Comment=None, ExpectedProperty=None, Port=None, RelativeCoordinate=None, FacilityAlias=None):
        self.original_tagname_ = None
        self.uid = _cast(None, uid)
        self.Name = Name
        self.validate_String64(self.Name)
        self.PlanName = PlanName
        self.validate_String64(self.PlanName)
        self.InternalNetworkReference = InternalNetworkReference
        self.validate_String64(self.InternalNetworkReference)
        self.Facility = Facility
        self.FacilityParent1 = FacilityParent1
        self.FacilityParent2 = FacilityParent2
        if ContextFacility is None:
            self.ContextFacility = []
        else:
            self.ContextFacility = ContextFacility
        self.Comment = Comment
        self.validate_String2000(self.Comment)
        if ExpectedProperty is None:
            self.ExpectedProperty = []
        else:
            self.ExpectedProperty = ExpectedProperty
        if Port is None:
            self.Port = []
        else:
            self.Port = Port
        self.RelativeCoordinate = RelativeCoordinate
        if FacilityAlias is None:
            self.FacilityAlias = []
        else:
            self.FacilityAlias = FacilityAlias
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductFlowUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductFlowUnit.subclass:
            return ProductFlowUnit.subclass(*args_, **kwargs_)
        else:
            return ProductFlowUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_PlanName(self): return self.PlanName
    def set_PlanName(self, PlanName): self.PlanName = PlanName
    PlanNameProp = property(get_PlanName, set_PlanName)
    def get_InternalNetworkReference(self): return self.InternalNetworkReference
    def set_InternalNetworkReference(self, InternalNetworkReference): self.InternalNetworkReference = InternalNetworkReference
    InternalNetworkReferenceProp = property(get_InternalNetworkReference, set_InternalNetworkReference)
    def get_Facility(self): return self.Facility
    def set_Facility(self, Facility): self.Facility = Facility
    FacilityProp = property(get_Facility, set_Facility)
    def get_FacilityParent1(self): return self.FacilityParent1
    def set_FacilityParent1(self, FacilityParent1): self.FacilityParent1 = FacilityParent1
    FacilityParent1Prop = property(get_FacilityParent1, set_FacilityParent1)
    def get_FacilityParent2(self): return self.FacilityParent2
    def set_FacilityParent2(self, FacilityParent2): self.FacilityParent2 = FacilityParent2
    FacilityParent2Prop = property(get_FacilityParent2, set_FacilityParent2)
    def get_ContextFacility(self): return self.ContextFacility
    def set_ContextFacility(self, ContextFacility): self.ContextFacility = ContextFacility
    def add_ContextFacility(self, value): self.ContextFacility.append(value)
    def insert_ContextFacility_at(self, index, value): self.ContextFacility.insert(index, value)
    def replace_ContextFacility_at(self, index, value): self.ContextFacility[index] = value
    ContextFacilityProp = property(get_ContextFacility, set_ContextFacility)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_ExpectedProperty(self): return self.ExpectedProperty
    def set_ExpectedProperty(self, ExpectedProperty): self.ExpectedProperty = ExpectedProperty
    def add_ExpectedProperty(self, value): self.ExpectedProperty.append(value)
    def insert_ExpectedProperty_at(self, index, value): self.ExpectedProperty.insert(index, value)
    def replace_ExpectedProperty_at(self, index, value): self.ExpectedProperty[index] = value
    ExpectedPropertyProp = property(get_ExpectedProperty, set_ExpectedProperty)
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    def add_Port(self, value): self.Port.append(value)
    def insert_Port_at(self, index, value): self.Port.insert(index, value)
    def replace_Port_at(self, index, value): self.Port[index] = value
    PortProp = property(get_Port, set_Port)
    def get_RelativeCoordinate(self): return self.RelativeCoordinate
    def set_RelativeCoordinate(self, RelativeCoordinate): self.RelativeCoordinate = RelativeCoordinate
    RelativeCoordinateProp = property(get_RelativeCoordinate, set_RelativeCoordinate)
    def get_FacilityAlias(self): return self.FacilityAlias
    def set_FacilityAlias(self, FacilityAlias): self.FacilityAlias = FacilityAlias
    def add_FacilityAlias(self, value): self.FacilityAlias.append(value)
    def insert_FacilityAlias_at(self, index, value): self.FacilityAlias.insert(index, value)
    def replace_FacilityAlias_at(self, index, value): self.FacilityAlias[index] = value
    FacilityAliasProp = property(get_FacilityAlias, set_FacilityAlias)
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    uidProp = property(get_uid, set_uid)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.PlanName is not None or
            self.InternalNetworkReference is not None or
            self.Facility is not None or
            self.FacilityParent1 is not None or
            self.FacilityParent2 is not None or
            self.ContextFacility or
            self.Comment is not None or
            self.ExpectedProperty or
            self.Port or
            self.RelativeCoordinate is not None or
            self.FacilityAlias
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductFlowUnit', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductFlowUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductFlowUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductFlowUnit'):
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(' uid=%s' % (quote_attrib(self.uid), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductFlowUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.PlanName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlanName>%s</%sPlanName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PlanName), input_name='PlanName')), namespace_, eol_))
        if self.InternalNetworkReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInternalNetworkReference>%s</%sInternalNetworkReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.InternalNetworkReference), input_name='InternalNetworkReference')), namespace_, eol_))
        if self.Facility is not None:
            self.Facility.export(outfile, level, namespace_, name_='Facility', pretty_print=pretty_print)
        if self.FacilityParent1 is not None:
            self.FacilityParent1.export(outfile, level, namespace_, name_='FacilityParent1', pretty_print=pretty_print)
        if self.FacilityParent2 is not None:
            self.FacilityParent2.export(outfile, level, namespace_, name_='FacilityParent2', pretty_print=pretty_print)
        for ContextFacility_ in self.ContextFacility:
            ContextFacility_.export(outfile, level, namespace_, name_='ContextFacility', pretty_print=pretty_print)
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
        for ExpectedProperty_ in self.ExpectedProperty:
            ExpectedProperty_.export(outfile, level, namespace_, name_='ExpectedProperty', pretty_print=pretty_print)
        for Port_ in self.Port:
            Port_.export(outfile, level, namespace_, name_='Port', pretty_print=pretty_print)
        if self.RelativeCoordinate is not None:
            self.RelativeCoordinate.export(outfile, level, namespace_, name_='RelativeCoordinate', pretty_print=pretty_print)
        for FacilityAlias_ in self.FacilityAlias:
            FacilityAlias_.export(outfile, level, namespace_, name_='FacilityAlias', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'PlanName':
            PlanName_ = child_.text
            PlanName_ = self.gds_validate_string(PlanName_, node, 'PlanName')
            self.PlanName = PlanName_
            # validate type String64
            self.validate_String64(self.PlanName)
        elif nodeName_ == 'InternalNetworkReference':
            InternalNetworkReference_ = child_.text
            InternalNetworkReference_ = self.gds_validate_string(InternalNetworkReference_, node, 'InternalNetworkReference')
            self.InternalNetworkReference = InternalNetworkReference_
            # validate type String64
            self.validate_String64(self.InternalNetworkReference)
        elif nodeName_ == 'Facility':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.Facility = obj_
            obj_.original_tagname_ = 'Facility'
        elif nodeName_ == 'FacilityParent1':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.FacilityParent1 = obj_
            obj_.original_tagname_ = 'FacilityParent1'
        elif nodeName_ == 'FacilityParent2':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.FacilityParent2 = obj_
            obj_.original_tagname_ = 'FacilityParent2'
        elif nodeName_ == 'ContextFacility':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.ContextFacility.append(obj_)
            obj_.original_tagname_ = 'ContextFacility'
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        elif nodeName_ == 'ExpectedProperty':
            obj_ = ProductFlowExpectedUnitProperty.factory()
            obj_.build(child_)
            self.ExpectedProperty.append(obj_)
            obj_.original_tagname_ = 'ExpectedProperty'
        elif nodeName_ == 'Port':
            obj_ = ProductFlowPort.factory()
            obj_.build(child_)
            self.Port.append(obj_)
            obj_.original_tagname_ = 'Port'
        elif nodeName_ == 'RelativeCoordinate':
            obj_ = RelativeCoordinate.factory()
            obj_.build(child_)
            self.RelativeCoordinate = obj_
            obj_.original_tagname_ = 'RelativeCoordinate'
        elif nodeName_ == 'FacilityAlias':
            obj_ = NameStruct.factory()
            obj_.build(child_)
            self.FacilityAlias.append(obj_)
            obj_.original_tagname_ = 'FacilityAlias'
# end class ProductFlowUnit


class Qualifier(ExpectedFlowQualifier):
    subclass = None
    superclass = ExpectedFlowQualifier
    def __init__(self, Qualifier_member=None):
        self.original_tagname_ = None
        super(Qualifier, self).__init__()
        if Qualifier_member is None:
            self.Qualifier = []
        else:
            self.Qualifier = Qualifier_member
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Qualifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Qualifier.subclass:
            return Qualifier.subclass(*args_, **kwargs_)
        else:
            return Qualifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Qualifier(self): return self.Qualifier
    def set_Qualifier(self, Qualifier): self.Qualifier = Qualifier
    def add_Qualifier(self, value): self.Qualifier.append(value)
    def insert_Qualifier_at(self, index, value): self.Qualifier.insert(index, value)
    def replace_Qualifier_at(self, index, value): self.Qualifier[index] = value
    QualifierProp = property(get_Qualifier, set_Qualifier)
    def validate_FlowQualifier(self, value):
        # Validate type FlowQualifier, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['allocated', 'budget', 'constraint', 'derived', 'difference', 'estimate', 'forecast', 'mass adjusted', 'measured', 'metered', 'metered - fiscal', 'nominated', 'potential', 'processed', 'quota', 'recommended', 'simulated', 'target', 'tariff basis', 'value adjusted']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FlowQualifier' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Qualifier or
            super(Qualifier, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='Qualifier', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Qualifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='Qualifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='Qualifier'):
        super(Qualifier, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Qualifier')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='Qualifier', fromsubclass_=False, pretty_print=True):
        super(Qualifier, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Qualifier_ in self.Qualifier:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQualifier>%s</%sQualifier>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(Qualifier_), input_name='Qualifier')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Qualifier, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Qualifier':
            Qualifier_ = child_.text
            Qualifier_ = self.gds_validate_string(Qualifier_, node, 'Qualifier')
            self.Qualifier.append(Qualifier_)
            # validate type FlowQualifier
            self.validate_FlowQualifier(self.Qualifier[-1])
        super(Qualifier, self).buildChildren(child_, node, nodeName_, True)
# end class Qualifier


class RelativeCoordinate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, X=None, Y=None, Z=None):
        self.original_tagname_ = None
        self.X = X
        self.Y = Y
        self.Z = Z
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelativeCoordinate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelativeCoordinate.subclass:
            return RelativeCoordinate.subclass(*args_, **kwargs_)
        else:
            return RelativeCoordinate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    XProp = property(get_X, set_X)
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    YProp = property(get_Y, set_Y)
    def get_Z(self): return self.Z
    def set_Z(self, Z): self.Z = Z
    ZProp = property(get_Z, set_Z)
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None or
            self.Z is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='RelativeCoordinate', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeCoordinate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='RelativeCoordinate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='RelativeCoordinate'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='RelativeCoordinate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            self.X.export(outfile, level, namespace_, name_='X', pretty_print=pretty_print)
        if self.Y is not None:
            self.Y.export(outfile, level, namespace_, name_='Y', pretty_print=pretty_print)
        if self.Z is not None:
            self.Z.export(outfile, level, namespace_, name_='Z', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X':
            obj_ = LengthPerLengthMeasure.factory()
            obj_.build(child_)
            self.X = obj_
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = LengthPerLengthMeasure.factory()
            obj_.build(child_)
            self.Y = obj_
            obj_.original_tagname_ = 'Y'
        elif nodeName_ == 'Z':
            obj_ = LengthPerLengthMeasure.factory()
            obj_.build(child_)
            self.Z = obj_
            obj_.original_tagname_ = 'Z'
# end class RelativeCoordinate


class AbstractObject(GeneratedsSuper):
    """The parent class for all top-level elements across the Energistics
    MLs. A lifecycle state like actual, required, planned,
    predicted, etc. This is used to qualify any top-level element
    (from Epicentre 2.1)."""
    subclass = None
    superclass = None
    def __init__(self, objectVersion=None, schemaVersion=None, uuid=None, existenceKind=None, Aliases=None, Citation=None, CustomData=None, ExtensionNameValue=None):
        self.original_tagname_ = None
        self.objectVersion = _cast(None, objectVersion)
        self.schemaVersion = _cast(None, schemaVersion)
        self.uuid = _cast(None, uuid)
        self.existenceKind = _cast(None, existenceKind)
        if Aliases is None:
            self.Aliases = []
        else:
            self.Aliases = Aliases
        self.Citation = Citation
        self.CustomData = CustomData
        if ExtensionNameValue is None:
            self.ExtensionNameValue = []
        else:
            self.ExtensionNameValue = ExtensionNameValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractObject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractObject.subclass:
            return AbstractObject.subclass(*args_, **kwargs_)
        else:
            return AbstractObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Aliases(self): return self.Aliases
    def set_Aliases(self, Aliases): self.Aliases = Aliases
    def add_Aliases(self, value): self.Aliases.append(value)
    def insert_Aliases_at(self, index, value): self.Aliases.insert(index, value)
    def replace_Aliases_at(self, index, value): self.Aliases[index] = value
    AliasesProp = property(get_Aliases, set_Aliases)
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    CitationProp = property(get_Citation, set_Citation)
    def get_CustomData(self): return self.CustomData
    def set_CustomData(self, CustomData): self.CustomData = CustomData
    CustomDataProp = property(get_CustomData, set_CustomData)
    def get_ExtensionNameValue(self): return self.ExtensionNameValue
    def set_ExtensionNameValue(self, ExtensionNameValue): self.ExtensionNameValue = ExtensionNameValue
    def add_ExtensionNameValue(self, value): self.ExtensionNameValue.append(value)
    def insert_ExtensionNameValue_at(self, index, value): self.ExtensionNameValue.insert(index, value)
    def replace_ExtensionNameValue_at(self, index, value): self.ExtensionNameValue[index] = value
    ExtensionNameValueProp = property(get_ExtensionNameValue, set_ExtensionNameValue)
    def get_objectVersion(self): return self.objectVersion
    def set_objectVersion(self, objectVersion): self.objectVersion = objectVersion
    objectVersionProp = property(get_objectVersion, set_objectVersion)
    def get_schemaVersion(self): return self.schemaVersion
    def set_schemaVersion(self, schemaVersion): self.schemaVersion = schemaVersion
    schemaVersionProp = property(get_schemaVersion, set_schemaVersion)
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    uuidProp = property(get_uuid, set_uuid)
    def get_existenceKind(self): return self.existenceKind
    def set_existenceKind(self, existenceKind): self.existenceKind = existenceKind
    existenceKindProp = property(get_existenceKind, set_existenceKind)
    def hasContent_(self):
        if (
            self.Aliases or
            self.Citation is not None or
            self.CustomData is not None or
            self.ExtensionNameValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractObject', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractObject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractObject'):
        if self.objectVersion is not None and 'objectVersion' not in already_processed:
            already_processed.add('objectVersion')
            outfile.write(' objectVersion=%s' % (quote_attrib(self.objectVersion), ))
        if self.schemaVersion is not None and 'schemaVersion' not in already_processed:
            already_processed.add('schemaVersion')
            outfile.write(' schemaVersion=%s' % (quote_attrib(self.schemaVersion), ))
        if self.uuid is not None and 'uuid' not in already_processed:
            already_processed.add('uuid')
            outfile.write(' uuid=%s' % (quote_attrib(self.uuid), ))
        if self.existenceKind is not None and 'existenceKind' not in already_processed:
            already_processed.add('existenceKind')
            outfile.write(' existenceKind=%s' % (quote_attrib(self.existenceKind), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractObject', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Aliases_ in self.Aliases:
            Aliases_.export(outfile, level, namespace_, name_='Aliases', pretty_print=pretty_print)
        if self.Citation is not None:
            self.Citation.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        if self.CustomData is not None:
            self.CustomData.export(outfile, level, namespace_, name_='CustomData', pretty_print=pretty_print)
        for ExtensionNameValue_ in self.ExtensionNameValue:
            ExtensionNameValue_.export(outfile, level, namespace_, name_='ExtensionNameValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('objectVersion', node)
        if value is not None and 'objectVersion' not in already_processed:
            already_processed.add('objectVersion')
            self.objectVersion = value
        value = find_attr_value_('schemaVersion', node)
        if value is not None and 'schemaVersion' not in already_processed:
            already_processed.add('schemaVersion')
            self.schemaVersion = value
        value = find_attr_value_('uuid', node)
        if value is not None and 'uuid' not in already_processed:
            already_processed.add('uuid')
            self.uuid = value
        value = find_attr_value_('existenceKind', node)
        if value is not None and 'existenceKind' not in already_processed:
            already_processed.add('existenceKind')
            self.existenceKind = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Aliases':
            obj_ = ObjectAlias.factory()
            obj_.build(child_)
            self.Aliases.append(obj_)
            obj_.original_tagname_ = 'Aliases'
        elif nodeName_ == 'Citation':
            obj_ = Citation.factory()
            obj_.build(child_)
            self.Citation = obj_
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'CustomData':
            obj_ = CustomData.factory()
            obj_.build(child_)
            self.CustomData = obj_
            obj_.original_tagname_ = 'CustomData'
        elif nodeName_ == 'ExtensionNameValue':
            obj_ = ExtensionNameValue.factory()
            obj_.build(child_)
            self.ExtensionNameValue.append(obj_)
            obj_.original_tagname_ = 'ExtensionNameValue'
# end class AbstractObject


class Citation(GeneratedsSuper):
    """An ISO 19115 EIP-derived set of metadata attached to all
    specializations of AbstractObject to ensure the traceability of
    each individual independent (top level) element."""
    subclass = None
    superclass = None
    def __init__(self, Title=None, Originator=None, Creation=None, Format=None, Editor=None, LastUpdate=None, VersionString=None, Description=None, DescriptiveKeywords=None):
        self.original_tagname_ = None
        self.Title = Title
        self.validate_String2000(self.Title)
        self.Originator = Originator
        self.validate_String64(self.Originator)
        if isinstance(Creation, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Creation, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Creation
        self.Creation = initvalue_
        self.Format = Format
        self.validate_String2000(self.Format)
        self.Editor = Editor
        self.validate_String64(self.Editor)
        if isinstance(LastUpdate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(LastUpdate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = LastUpdate
        self.LastUpdate = initvalue_
        self.VersionString = VersionString
        self.validate_String64(self.VersionString)
        self.Description = Description
        self.validate_String2000(self.Description)
        self.DescriptiveKeywords = DescriptiveKeywords
        self.validate_String2000(self.DescriptiveKeywords)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Citation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Citation.subclass:
            return Citation.subclass(*args_, **kwargs_)
        else:
            return Citation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    TitleProp = property(get_Title, set_Title)
    def get_Originator(self): return self.Originator
    def set_Originator(self, Originator): self.Originator = Originator
    OriginatorProp = property(get_Originator, set_Originator)
    def get_Creation(self): return self.Creation
    def set_Creation(self, Creation): self.Creation = Creation
    CreationProp = property(get_Creation, set_Creation)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    FormatProp = property(get_Format, set_Format)
    def get_Editor(self): return self.Editor
    def set_Editor(self, Editor): self.Editor = Editor
    EditorProp = property(get_Editor, set_Editor)
    def get_LastUpdate(self): return self.LastUpdate
    def set_LastUpdate(self, LastUpdate): self.LastUpdate = LastUpdate
    LastUpdateProp = property(get_LastUpdate, set_LastUpdate)
    def get_VersionString(self): return self.VersionString
    def set_VersionString(self, VersionString): self.VersionString = VersionString
    VersionStringProp = property(get_VersionString, set_VersionString)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    DescriptionProp = property(get_Description, set_Description)
    def get_DescriptiveKeywords(self): return self.DescriptiveKeywords
    def set_DescriptiveKeywords(self, DescriptiveKeywords): self.DescriptiveKeywords = DescriptiveKeywords
    DescriptiveKeywordsProp = property(get_DescriptiveKeywords, set_DescriptiveKeywords)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Title is not None or
            self.Originator is not None or
            self.Creation is not None or
            self.Format is not None or
            self.Editor is not None or
            self.LastUpdate is not None or
            self.VersionString is not None or
            self.Description is not None or
            self.DescriptiveKeywords is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='Citation', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Citation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='Citation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='Citation'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='Citation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Title), input_name='Title')), namespace_, eol_))
        if self.Originator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOriginator>%s</%sOriginator>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Originator), input_name='Originator')), namespace_, eol_))
        if self.Creation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCreation>%s</%sCreation>%s' % (namespace_, self.gds_format_datetime(self.Creation, input_name='Creation'), namespace_, eol_))
        if self.Format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFormat>%s</%sFormat>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Format), input_name='Format')), namespace_, eol_))
        if self.Editor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEditor>%s</%sEditor>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Editor), input_name='Editor')), namespace_, eol_))
        if self.LastUpdate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLastUpdate>%s</%sLastUpdate>%s' % (namespace_, self.gds_format_datetime(self.LastUpdate, input_name='LastUpdate'), namespace_, eol_))
        if self.VersionString is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersionString>%s</%sVersionString>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.VersionString), input_name='VersionString')), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), namespace_, eol_))
        if self.DescriptiveKeywords is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescriptiveKeywords>%s</%sDescriptiveKeywords>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DescriptiveKeywords), input_name='DescriptiveKeywords')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
            # validate type String2000
            self.validate_String2000(self.Title)
        elif nodeName_ == 'Originator':
            Originator_ = child_.text
            Originator_ = self.gds_validate_string(Originator_, node, 'Originator')
            self.Originator = Originator_
            # validate type String64
            self.validate_String64(self.Originator)
        elif nodeName_ == 'Creation':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.Creation = dval_
        elif nodeName_ == 'Format':
            Format_ = child_.text
            Format_ = self.gds_validate_string(Format_, node, 'Format')
            self.Format = Format_
            # validate type String2000
            self.validate_String2000(self.Format)
        elif nodeName_ == 'Editor':
            Editor_ = child_.text
            Editor_ = self.gds_validate_string(Editor_, node, 'Editor')
            self.Editor = Editor_
            # validate type String64
            self.validate_String64(self.Editor)
        elif nodeName_ == 'LastUpdate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.LastUpdate = dval_
        elif nodeName_ == 'VersionString':
            VersionString_ = child_.text
            VersionString_ = self.gds_validate_string(VersionString_, node, 'VersionString')
            self.VersionString = VersionString_
            # validate type String64
            self.validate_String64(self.VersionString)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            # validate type String2000
            self.validate_String2000(self.Description)
        elif nodeName_ == 'DescriptiveKeywords':
            DescriptiveKeywords_ = child_.text
            DescriptiveKeywords_ = self.gds_validate_string(DescriptiveKeywords_, node, 'DescriptiveKeywords')
            self.DescriptiveKeywords = DescriptiveKeywords_
            # validate type String2000
            self.validate_String2000(self.DescriptiveKeywords)
# end class Citation


class CustomData(GeneratedsSuper):
    """WITSML - Custom or User Defined Element and Attributes Component
    Schema. Specify custom element, attributes, and types in the
    custom data area."""
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomData.subclass:
            return CustomData.subclass(*args_, **kwargs_)
        else:
            return CustomData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CustomData', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CustomData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CustomData'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CustomData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'CustomData')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class CustomData


class ExtensionNameValue(GeneratedsSuper):
    """WITSML - Extension values Schema. The intent is to allow standard
    WITSML "named" extensions without having to modify the schema. A
    client or server can ignore any name that it does not recognize
    but certain meta data is required in order to allow generic
    clients or servers to process the value."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, Value=None, MeasureClass=None, DTim=None, Index=None, Description=None):
        self.original_tagname_ = None
        self.Name = Name
        self.validate_String64(self.Name)
        self.Value = Value
        self.MeasureClass = MeasureClass
        self.validate_MeasureClass(self.MeasureClass)
        self.DTim = DTim
        self.validate_TimeStamp(self.DTim)
        self.Index = Index
        self.Description = Description
        self.validate_String2000(self.Description)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExtensionNameValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExtensionNameValue.subclass:
            return ExtensionNameValue.subclass(*args_, **kwargs_)
        else:
            return ExtensionNameValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    NameProp = property(get_Name, set_Name)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    ValueProp = property(get_Value, set_Value)
    def get_MeasureClass(self): return self.MeasureClass
    def set_MeasureClass(self, MeasureClass): self.MeasureClass = MeasureClass
    MeasureClassProp = property(get_MeasureClass, set_MeasureClass)
    def get_DTim(self): return self.DTim
    def set_DTim(self, DTim): self.DTim = DTim
    DTimProp = property(get_DTim, set_DTim)
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    IndexProp = property(get_Index, set_Index)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    DescriptionProp = property(get_Description, set_Description)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_MeasureClass(self, value):
        # Validate type MeasureClass, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['absorbed dose', 'activity of radioactivity', 'amount of substance', 'amount of substance per amount of substance', 'amount of substance per area', 'amount of substance per time', 'amount of substance per time per area', 'amount of substance per volume', 'angle per length', 'angle per volume', 'angular acceleration', 'angular velocity', 'api gamma ray', 'api gravity', 'api neutron', 'area', 'area per amount of substance', 'area per area', 'area per count', 'area per mass', 'area per time', 'area per volume', 'attenuation per frequency interval', 'capacitance', 'cation exchange capacity', 'data transfer speed', 'diffusion coefficient', 'diffusive time of flight', 'digital storage', 'dimensionless', 'dipole moment', 'dose equivalent', 'dynamic viscosity', 'electric charge', 'electric charge per area', 'electric charge per mass', 'electric charge per volume', 'electric conductance', 'electric conductivity', 'electric current', 'electric current density', 'electric field strength', 'electric potential difference', 'electric resistance', 'electric resistance per length', 'electrical resistivity', 'electromagnetic moment', 'energy', 'energy length per area', 'energy length per time area temperature', 'energy per area', 'energy per length', 'energy per mass', 'energy per mass per time', 'energy per volume', 'force', 'force area', 'force length per length', 'force per force', 'force per length', 'force per volume', 'frequency', 'frequency interval', 'heat capacity', 'heat flow rate', 'heat transfer coefficient', 'illuminance', 'inductance', 'isothermal compressibility', 'kinematic viscosity', 'length', 'length per length', 'length per mass', 'length per pressure', 'length per temperature', 'length per time', 'length per volume', 'light exposure', 'linear acceleration', 'linear thermal expansion', 'logarithmic power ratio', 'logarithmic power ratio per length', 'luminance', 'luminous efficacy', 'luminous flux', 'luminous intensity', 'magnetic dipole moment', 'magnetic field strength', 'magnetic flux', 'magnetic flux density', 'magnetic flux density per length', 'magnetic permeability', 'magnetic vector potential', 'mass', 'mass length', 'mass per area', 'mass per energy', 'mass per length', 'mass per mass', 'mass per time', 'mass per time per area', 'mass per time per length', 'mass per volume', 'mass per volume per length', 'mass per volume per pressure', 'mass per volume per temperature', 'mobility', 'molar energy', 'molar heat capacity', 'molar volume', 'molecular weight', 'moment of force', 'moment of inertia', 'momentum', 'normalized power', 'permeability length', 'permeability rock', 'permittivity', 'plane angle', 'potential difference per power drop', 'power', 'power per area', 'power per power', 'power per volume', 'pressure', 'pressure per pressure', 'pressure per time', 'pressure per volume', 'pressure squared', 'pressure squared per force time per area', 'pressure time per volume', 'quantity of light', 'radiance', 'radiant intensity', 'reciprocal area', 'reciprocal electric potential difference', 'reciprocal force', 'reciprocal length', 'reciprocal mass', 'reciprocal mass time', 'reciprocal pressure', 'reciprocal time', 'reciprocal volume', 'reluctance', 'second moment of area', 'signaling event per time', 'solid angle', 'specific heat capacity', 'temperature interval', 'temperature interval per length', 'temperature interval per pressure', 'temperature interval per time', 'thermal conductance', 'thermal conductivity', 'thermal diffusivity', 'thermal insulance', 'thermal resistance', 'thermodynamic temperature', 'thermodynamic temperature per thermodynamic temperature', 'time', 'time per length', 'time per mass', 'time per time', 'time per volume', 'vertical coordinate', 'volume', 'volume flow rate per volume flow rate', 'volume per area', 'volume per length', 'volume per mass', 'volume per pressure', 'volume per rotation', 'volume per time', 'volume per time length', 'volume per time per area', 'volume per time per length', 'volume per time per pressure', 'volume per time per pressure length', 'volume per time per time', 'volume per time per volume', 'volume per volume', 'volumetric heat transfer coefficient', 'volumetric thermal expansion', 'unitless']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureClass' % {"value" : value.encode("utf-8")} )
    def validate_TimeStamp(self, value):
        # Validate type TimeStamp, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TimeStamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TimeStamp_patterns_, ))
    validate_TimeStamp_patterns_ = [['^.+T.+[Z+\\-].*$']]
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Value is not None or
            self.MeasureClass is not None or
            self.DTim is not None or
            self.Index is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ExtensionNameValue', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExtensionNameValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ExtensionNameValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ExtensionNameValue'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ExtensionNameValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespace_, eol_))
        if self.Value is not None:
            self.Value.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
        if self.MeasureClass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureClass>%s</%sMeasureClass>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MeasureClass), input_name='MeasureClass')), namespace_, eol_))
        if self.DTim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTim>%s</%sDTim>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DTim), input_name='DTim')), namespace_, eol_))
        if self.Index is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndex>%s</%sIndex>%s' % (namespace_, self.gds_format_integer(self.Index, input_name='Index'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type String64
            self.validate_String64(self.Name)
        elif nodeName_ == 'Value':
            obj_ = StringMeasure.factory()
            obj_.build(child_)
            self.Value = obj_
            obj_.original_tagname_ = 'Value'
        elif nodeName_ == 'MeasureClass':
            MeasureClass_ = child_.text
            MeasureClass_ = self.gds_validate_string(MeasureClass_, node, 'MeasureClass')
            self.MeasureClass = MeasureClass_
            # validate type MeasureClass
            self.validate_MeasureClass(self.MeasureClass)
        elif nodeName_ == 'DTim':
            DTim_ = child_.text
            DTim_ = self.gds_validate_string(DTim_, node, 'DTim')
            self.DTim = DTim_
            # validate type TimeStamp
            self.validate_TimeStamp(self.DTim)
        elif nodeName_ == 'Index':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Index')
            self.Index = ival_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            # validate type String2000
            self.validate_String2000(self.Description)
# end class ExtensionNameValue


class ObjectAlias(GeneratedsSuper):
    """Use this to create multiple aliases for any object instance. Note
    that an Authority is required for each alias."""
    subclass = None
    superclass = None
    def __init__(self, authority=None, Identifier=None, Description=None):
        self.original_tagname_ = None
        self.authority = _cast(None, authority)
        self.Identifier = Identifier
        self.validate_String64(self.Identifier)
        self.Description = Description
        self.validate_String2000(self.Description)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObjectAlias)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObjectAlias.subclass:
            return ObjectAlias.subclass(*args_, **kwargs_)
        else:
            return ObjectAlias(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Identifier(self): return self.Identifier
    def set_Identifier(self, Identifier): self.Identifier = Identifier
    IdentifierProp = property(get_Identifier, set_Identifier)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    DescriptionProp = property(get_Description, set_Description)
    def get_authority(self): return self.authority
    def set_authority(self, authority): self.authority = authority
    authorityProp = property(get_authority, set_authority)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Identifier is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ObjectAlias', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectAlias')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ObjectAlias', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ObjectAlias'):
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (quote_attrib(self.authority), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ObjectAlias', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Identifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIdentifier>%s</%sIdentifier>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Identifier), input_name='Identifier')), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Identifier':
            Identifier_ = child_.text
            Identifier_ = self.gds_validate_string(Identifier_, node, 'Identifier')
            self.Identifier = Identifier_
            # validate type String64
            self.validate_String64(self.Identifier)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            # validate type String2000
            self.validate_String2000(self.Description)
# end class ObjectAlias


class AbstractValueArray(GeneratedsSuper):
    """Generic representation of an array of numeric, Boolean, and string
    values. Each derived element provides specialized implementation
    for specific content types or for optimization of the
    representation."""
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractValueArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractValueArray.subclass:
            return AbstractValueArray.subclass(*args_, **kwargs_)
        else:
            return AbstractValueArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractValueArray', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractValueArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractValueArray', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractValueArray'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractValueArray', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractValueArray


class AuthorityQualifiedName(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, authority=None, code=None, valueOf_=None):
        self.original_tagname_ = None
        self.authority = _cast(None, authority)
        self.code = _cast(None, code)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AuthorityQualifiedName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AuthorityQualifiedName.subclass:
            return AuthorityQualifiedName.subclass(*args_, **kwargs_)
        else:
            return AuthorityQualifiedName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_authority(self): return self.authority
    def set_authority(self, authority): self.authority = authority
    authorityProp = property(get_authority, set_authority)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    codeProp = property(get_code, set_code)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AuthorityQualifiedName', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AuthorityQualifiedName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AuthorityQualifiedName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AuthorityQualifiedName'):
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (quote_attrib(self.authority), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AuthorityQualifiedName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AuthorityQualifiedName


class GenericMeasure(GeneratedsSuper):
    """A generic measure type. This should not be used except in situations
    where the underlying class of data is captured elsewhere. For
    example, for a log curve."""
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericMeasure.subclass:
            return GenericMeasure.subclass(*args_, **kwargs_)
        else:
            return GenericMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GenericMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GenericMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GenericMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GenericMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GenericMeasure


class JaggedArray(GeneratedsSuper):
    """Data storage object for an array of variable length 1D sub-arrays.
    The jagged array object consists of these two arrays: - An
    aggregation of all the variable length sub-arrays into a single
    1D array. - The offsets into the single 1D array, given by the
    sum of all the sub-array lengths up to and including the current
    sub-array. Often referred to as a "list-of-lists" or "array-of-
    arrays" construction. For example to store the following three
    arrays as a jagged array: (a b c) (d e f g) (h) Elements = (a b
    c d e f g h) Cumulative Length = (3 7 8)"""
    subclass = None
    superclass = None
    def __init__(self, Elements=None, CumulativeLength=None):
        self.original_tagname_ = None
        self.Elements = Elements
        self.CumulativeLength = CumulativeLength
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, JaggedArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if JaggedArray.subclass:
            return JaggedArray.subclass(*args_, **kwargs_)
        else:
            return JaggedArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Elements(self): return self.Elements
    def set_Elements(self, Elements): self.Elements = Elements
    ElementsProp = property(get_Elements, set_Elements)
    def get_CumulativeLength(self): return self.CumulativeLength
    def set_CumulativeLength(self, CumulativeLength): self.CumulativeLength = CumulativeLength
    CumulativeLengthProp = property(get_CumulativeLength, set_CumulativeLength)
    def hasContent_(self):
        if (
            self.Elements is not None or
            self.CumulativeLength is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='JaggedArray', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JaggedArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='JaggedArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='JaggedArray'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='JaggedArray', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Elements is not None:
            self.Elements.export(outfile, level, namespace_, name_='Elements', pretty_print=pretty_print)
        if self.CumulativeLength is not None:
            self.CumulativeLength.export(outfile, level, namespace_, name_='CumulativeLength', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Elements':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Elements> element')
            self.Elements = obj_
            obj_.original_tagname_ = 'Elements'
        elif nodeName_ == 'CumulativeLength':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <CumulativeLength> element')
            self.CumulativeLength = obj_
            obj_.original_tagname_ = 'CumulativeLength'
# end class JaggedArray


class MdInterval(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, datum=None, MdTop=None, MdBase=None):
        self.original_tagname_ = None
        self.datum = _cast(None, datum)
        self.MdTop = MdTop
        self.MdBase = MdBase
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MdInterval)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MdInterval.subclass:
            return MdInterval.subclass(*args_, **kwargs_)
        else:
            return MdInterval(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MdTop(self): return self.MdTop
    def set_MdTop(self, MdTop): self.MdTop = MdTop
    MdTopProp = property(get_MdTop, set_MdTop)
    def get_MdBase(self): return self.MdBase
    def set_MdBase(self, MdBase): self.MdBase = MdBase
    MdBaseProp = property(get_MdBase, set_MdBase)
    def get_datum(self): return self.datum
    def set_datum(self, datum): self.datum = datum
    datumProp = property(get_datum, set_datum)
    def hasContent_(self):
        if (
            self.MdTop is not None or
            self.MdBase is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MdInterval', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MdInterval')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MdInterval', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MdInterval'):
        if self.datum is not None and 'datum' not in already_processed:
            already_processed.add('datum')
            outfile.write(' datum=%s' % (quote_attrib(self.datum), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MdInterval', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MdTop is not None:
            self.MdTop.export(outfile, level, namespace_, name_='MdTop', pretty_print=pretty_print)
        if self.MdBase is not None:
            self.MdBase.export(outfile, level, namespace_, name_='MdBase', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datum', node)
        if value is not None and 'datum' not in already_processed:
            already_processed.add('datum')
            self.datum = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MdTop':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.MdTop = obj_
            obj_.original_tagname_ = 'MdTop'
        elif nodeName_ == 'MdBase':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.MdBase = obj_
            obj_.original_tagname_ = 'MdBase'
# end class MdInterval


class StringMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringMeasure.subclass:
            return StringMeasure.subclass(*args_, **kwargs_)
        else:
            return StringMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='StringMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StringMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='StringMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='StringMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='StringMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StringMeasure


class TvdInterval(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, datum=None, TvdTop=None, TvdBase=None):
        self.original_tagname_ = None
        self.datum = _cast(None, datum)
        self.TvdTop = TvdTop
        self.TvdBase = TvdBase
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TvdInterval)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TvdInterval.subclass:
            return TvdInterval.subclass(*args_, **kwargs_)
        else:
            return TvdInterval(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TvdTop(self): return self.TvdTop
    def set_TvdTop(self, TvdTop): self.TvdTop = TvdTop
    TvdTopProp = property(get_TvdTop, set_TvdTop)
    def get_TvdBase(self): return self.TvdBase
    def set_TvdBase(self, TvdBase): self.TvdBase = TvdBase
    TvdBaseProp = property(get_TvdBase, set_TvdBase)
    def get_datum(self): return self.datum
    def set_datum(self, datum): self.datum = datum
    datumProp = property(get_datum, set_datum)
    def hasContent_(self):
        if (
            self.TvdTop is not None or
            self.TvdBase is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TvdInterval', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TvdInterval')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TvdInterval', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TvdInterval'):
        if self.datum is not None and 'datum' not in already_processed:
            already_processed.add('datum')
            outfile.write(' datum=%s' % (quote_attrib(self.datum), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TvdInterval', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TvdTop is not None:
            self.TvdTop.export(outfile, level, namespace_, name_='TvdTop', pretty_print=pretty_print)
        if self.TvdBase is not None:
            self.TvdBase.export(outfile, level, namespace_, name_='TvdBase', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datum', node)
        if value is not None and 'datum' not in already_processed:
            already_processed.add('datum')
            self.datum = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TvdTop':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.TvdTop = obj_
            obj_.original_tagname_ = 'TvdTop'
        elif nodeName_ == 'TvdBase':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.TvdBase = obj_
            obj_.original_tagname_ = 'TvdBase'
# end class TvdInterval


class AbsorbedDoseMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbsorbedDoseMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbsorbedDoseMeasure.subclass:
            return AbsorbedDoseMeasure.subclass(*args_, **kwargs_)
        else:
            return AbsorbedDoseMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbsorbedDoseMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbsorbedDoseMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbsorbedDoseMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbsorbedDoseMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbsorbedDoseMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbsorbedDoseMeasure


class AbsorbedDoseMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbsorbedDoseMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbsorbedDoseMeasureExt.subclass:
            return AbsorbedDoseMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AbsorbedDoseMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbsorbedDoseMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbsorbedDoseMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbsorbedDoseMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbsorbedDoseMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbsorbedDoseMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbsorbedDoseMeasureExt


class ActivityOfRadioactivityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActivityOfRadioactivityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActivityOfRadioactivityMeasure.subclass:
            return ActivityOfRadioactivityMeasure.subclass(*args_, **kwargs_)
        else:
            return ActivityOfRadioactivityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ActivityOfRadioactivityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActivityOfRadioactivityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ActivityOfRadioactivityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ActivityOfRadioactivityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ActivityOfRadioactivityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActivityOfRadioactivityMeasure


class ActivityOfRadioactivityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActivityOfRadioactivityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActivityOfRadioactivityMeasureExt.subclass:
            return ActivityOfRadioactivityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ActivityOfRadioactivityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ActivityOfRadioactivityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActivityOfRadioactivityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ActivityOfRadioactivityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ActivityOfRadioactivityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ActivityOfRadioactivityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActivityOfRadioactivityMeasureExt


class AmountOfSubstanceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountOfSubstanceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountOfSubstanceMeasure.subclass:
            return AmountOfSubstanceMeasure.subclass(*args_, **kwargs_)
        else:
            return AmountOfSubstanceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstanceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountOfSubstanceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AmountOfSubstanceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AmountOfSubstanceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstanceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AmountOfSubstanceMeasure


class AmountOfSubstanceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountOfSubstanceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountOfSubstanceMeasureExt.subclass:
            return AmountOfSubstanceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AmountOfSubstanceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstanceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountOfSubstanceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AmountOfSubstanceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AmountOfSubstanceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstanceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AmountOfSubstanceMeasureExt


class AmountOfSubstancePerAmountOfSubstanceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountOfSubstancePerAmountOfSubstanceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountOfSubstancePerAmountOfSubstanceMeasure.subclass:
            return AmountOfSubstancePerAmountOfSubstanceMeasure.subclass(*args_, **kwargs_)
        else:
            return AmountOfSubstancePerAmountOfSubstanceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerAmountOfSubstanceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountOfSubstancePerAmountOfSubstanceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AmountOfSubstancePerAmountOfSubstanceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AmountOfSubstancePerAmountOfSubstanceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerAmountOfSubstanceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AmountOfSubstancePerAmountOfSubstanceMeasure


class AmountOfSubstancePerAmountOfSubstanceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountOfSubstancePerAmountOfSubstanceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountOfSubstancePerAmountOfSubstanceMeasureExt.subclass:
            return AmountOfSubstancePerAmountOfSubstanceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AmountOfSubstancePerAmountOfSubstanceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerAmountOfSubstanceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountOfSubstancePerAmountOfSubstanceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AmountOfSubstancePerAmountOfSubstanceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AmountOfSubstancePerAmountOfSubstanceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerAmountOfSubstanceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AmountOfSubstancePerAmountOfSubstanceMeasureExt


class AmountOfSubstancePerAreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountOfSubstancePerAreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountOfSubstancePerAreaMeasure.subclass:
            return AmountOfSubstancePerAreaMeasure.subclass(*args_, **kwargs_)
        else:
            return AmountOfSubstancePerAreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerAreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountOfSubstancePerAreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AmountOfSubstancePerAreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AmountOfSubstancePerAreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerAreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AmountOfSubstancePerAreaMeasure


class AmountOfSubstancePerAreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountOfSubstancePerAreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountOfSubstancePerAreaMeasureExt.subclass:
            return AmountOfSubstancePerAreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AmountOfSubstancePerAreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerAreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountOfSubstancePerAreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AmountOfSubstancePerAreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AmountOfSubstancePerAreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerAreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AmountOfSubstancePerAreaMeasureExt


class AmountOfSubstancePerTimeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountOfSubstancePerTimeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountOfSubstancePerTimeMeasure.subclass:
            return AmountOfSubstancePerTimeMeasure.subclass(*args_, **kwargs_)
        else:
            return AmountOfSubstancePerTimeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerTimeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountOfSubstancePerTimeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AmountOfSubstancePerTimeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AmountOfSubstancePerTimeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerTimeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AmountOfSubstancePerTimeMeasure


class AmountOfSubstancePerTimeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountOfSubstancePerTimeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountOfSubstancePerTimeMeasureExt.subclass:
            return AmountOfSubstancePerTimeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AmountOfSubstancePerTimeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerTimeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountOfSubstancePerTimeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AmountOfSubstancePerTimeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AmountOfSubstancePerTimeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerTimeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AmountOfSubstancePerTimeMeasureExt


class AmountOfSubstancePerTimePerAreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountOfSubstancePerTimePerAreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountOfSubstancePerTimePerAreaMeasure.subclass:
            return AmountOfSubstancePerTimePerAreaMeasure.subclass(*args_, **kwargs_)
        else:
            return AmountOfSubstancePerTimePerAreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerTimePerAreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountOfSubstancePerTimePerAreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AmountOfSubstancePerTimePerAreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AmountOfSubstancePerTimePerAreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerTimePerAreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AmountOfSubstancePerTimePerAreaMeasure


class AmountOfSubstancePerTimePerAreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountOfSubstancePerTimePerAreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountOfSubstancePerTimePerAreaMeasureExt.subclass:
            return AmountOfSubstancePerTimePerAreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AmountOfSubstancePerTimePerAreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerTimePerAreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountOfSubstancePerTimePerAreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AmountOfSubstancePerTimePerAreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AmountOfSubstancePerTimePerAreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerTimePerAreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AmountOfSubstancePerTimePerAreaMeasureExt


class AmountOfSubstancePerVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountOfSubstancePerVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountOfSubstancePerVolumeMeasure.subclass:
            return AmountOfSubstancePerVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return AmountOfSubstancePerVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountOfSubstancePerVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AmountOfSubstancePerVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AmountOfSubstancePerVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AmountOfSubstancePerVolumeMeasure


class AmountOfSubstancePerVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountOfSubstancePerVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountOfSubstancePerVolumeMeasureExt.subclass:
            return AmountOfSubstancePerVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AmountOfSubstancePerVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountOfSubstancePerVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AmountOfSubstancePerVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AmountOfSubstancePerVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AmountOfSubstancePerVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AmountOfSubstancePerVolumeMeasureExt


class AnglePerLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnglePerLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnglePerLengthMeasure.subclass:
            return AnglePerLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return AnglePerLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AnglePerLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnglePerLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AnglePerLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AnglePerLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AnglePerLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnglePerLengthMeasure


class AnglePerLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnglePerLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnglePerLengthMeasureExt.subclass:
            return AnglePerLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AnglePerLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AnglePerLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnglePerLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AnglePerLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AnglePerLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AnglePerLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnglePerLengthMeasureExt


class AnglePerVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnglePerVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnglePerVolumeMeasure.subclass:
            return AnglePerVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return AnglePerVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AnglePerVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnglePerVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AnglePerVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AnglePerVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AnglePerVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnglePerVolumeMeasure


class AnglePerVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnglePerVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnglePerVolumeMeasureExt.subclass:
            return AnglePerVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AnglePerVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AnglePerVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnglePerVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AnglePerVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AnglePerVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AnglePerVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnglePerVolumeMeasureExt


class AngularAccelerationMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AngularAccelerationMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AngularAccelerationMeasure.subclass:
            return AngularAccelerationMeasure.subclass(*args_, **kwargs_)
        else:
            return AngularAccelerationMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AngularAccelerationMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AngularAccelerationMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AngularAccelerationMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AngularAccelerationMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AngularAccelerationMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AngularAccelerationMeasure


class AngularAccelerationMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AngularAccelerationMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AngularAccelerationMeasureExt.subclass:
            return AngularAccelerationMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AngularAccelerationMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AngularAccelerationMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AngularAccelerationMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AngularAccelerationMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AngularAccelerationMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AngularAccelerationMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AngularAccelerationMeasureExt


class AngularVelocityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AngularVelocityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AngularVelocityMeasure.subclass:
            return AngularVelocityMeasure.subclass(*args_, **kwargs_)
        else:
            return AngularVelocityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AngularVelocityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AngularVelocityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AngularVelocityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AngularVelocityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AngularVelocityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AngularVelocityMeasure


class AngularVelocityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AngularVelocityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AngularVelocityMeasureExt.subclass:
            return AngularVelocityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AngularVelocityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AngularVelocityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AngularVelocityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AngularVelocityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AngularVelocityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AngularVelocityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AngularVelocityMeasureExt


class APIGammaRayMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, APIGammaRayMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if APIGammaRayMeasure.subclass:
            return APIGammaRayMeasure.subclass(*args_, **kwargs_)
        else:
            return APIGammaRayMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='APIGammaRayMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='APIGammaRayMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='APIGammaRayMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='APIGammaRayMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='APIGammaRayMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class APIGammaRayMeasure


class APIGammaRayMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, APIGammaRayMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if APIGammaRayMeasureExt.subclass:
            return APIGammaRayMeasureExt.subclass(*args_, **kwargs_)
        else:
            return APIGammaRayMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='APIGammaRayMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='APIGammaRayMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='APIGammaRayMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='APIGammaRayMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='APIGammaRayMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class APIGammaRayMeasureExt


class APIGravityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, APIGravityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if APIGravityMeasure.subclass:
            return APIGravityMeasure.subclass(*args_, **kwargs_)
        else:
            return APIGravityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='APIGravityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='APIGravityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='APIGravityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='APIGravityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='APIGravityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class APIGravityMeasure


class APIGravityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, APIGravityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if APIGravityMeasureExt.subclass:
            return APIGravityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return APIGravityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='APIGravityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='APIGravityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='APIGravityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='APIGravityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='APIGravityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class APIGravityMeasureExt


class APINeutronMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, APINeutronMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if APINeutronMeasure.subclass:
            return APINeutronMeasure.subclass(*args_, **kwargs_)
        else:
            return APINeutronMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='APINeutronMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='APINeutronMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='APINeutronMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='APINeutronMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='APINeutronMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class APINeutronMeasure


class APINeutronMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, APINeutronMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if APINeutronMeasureExt.subclass:
            return APINeutronMeasureExt.subclass(*args_, **kwargs_)
        else:
            return APINeutronMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='APINeutronMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='APINeutronMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='APINeutronMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='APINeutronMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='APINeutronMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class APINeutronMeasureExt


class AreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaMeasure.subclass:
            return AreaMeasure.subclass(*args_, **kwargs_)
        else:
            return AreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaMeasure


class AreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaMeasureExt.subclass:
            return AreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaMeasureExt


class AreaPerAmountOfSubstanceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaPerAmountOfSubstanceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaPerAmountOfSubstanceMeasure.subclass:
            return AreaPerAmountOfSubstanceMeasure.subclass(*args_, **kwargs_)
        else:
            return AreaPerAmountOfSubstanceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AreaPerAmountOfSubstanceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaPerAmountOfSubstanceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AreaPerAmountOfSubstanceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AreaPerAmountOfSubstanceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AreaPerAmountOfSubstanceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaPerAmountOfSubstanceMeasure


class AreaPerAmountOfSubstanceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaPerAmountOfSubstanceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaPerAmountOfSubstanceMeasureExt.subclass:
            return AreaPerAmountOfSubstanceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AreaPerAmountOfSubstanceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AreaPerAmountOfSubstanceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaPerAmountOfSubstanceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AreaPerAmountOfSubstanceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AreaPerAmountOfSubstanceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AreaPerAmountOfSubstanceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaPerAmountOfSubstanceMeasureExt


class AreaPerAreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaPerAreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaPerAreaMeasure.subclass:
            return AreaPerAreaMeasure.subclass(*args_, **kwargs_)
        else:
            return AreaPerAreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AreaPerAreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaPerAreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AreaPerAreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AreaPerAreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AreaPerAreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaPerAreaMeasure


class AreaPerAreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaPerAreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaPerAreaMeasureExt.subclass:
            return AreaPerAreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AreaPerAreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AreaPerAreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaPerAreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AreaPerAreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AreaPerAreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AreaPerAreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaPerAreaMeasureExt


class AreaPerCountMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaPerCountMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaPerCountMeasure.subclass:
            return AreaPerCountMeasure.subclass(*args_, **kwargs_)
        else:
            return AreaPerCountMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AreaPerCountMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaPerCountMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AreaPerCountMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AreaPerCountMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AreaPerCountMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaPerCountMeasure


class AreaPerCountMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaPerCountMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaPerCountMeasureExt.subclass:
            return AreaPerCountMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AreaPerCountMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AreaPerCountMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaPerCountMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AreaPerCountMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AreaPerCountMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AreaPerCountMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaPerCountMeasureExt


class AreaPerMassMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaPerMassMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaPerMassMeasure.subclass:
            return AreaPerMassMeasure.subclass(*args_, **kwargs_)
        else:
            return AreaPerMassMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AreaPerMassMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaPerMassMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AreaPerMassMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AreaPerMassMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AreaPerMassMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaPerMassMeasure


class AreaPerMassMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaPerMassMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaPerMassMeasureExt.subclass:
            return AreaPerMassMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AreaPerMassMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AreaPerMassMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaPerMassMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AreaPerMassMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AreaPerMassMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AreaPerMassMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaPerMassMeasureExt


class AreaPerTimeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaPerTimeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaPerTimeMeasure.subclass:
            return AreaPerTimeMeasure.subclass(*args_, **kwargs_)
        else:
            return AreaPerTimeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AreaPerTimeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaPerTimeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AreaPerTimeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AreaPerTimeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AreaPerTimeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaPerTimeMeasure


class AreaPerTimeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaPerTimeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaPerTimeMeasureExt.subclass:
            return AreaPerTimeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AreaPerTimeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AreaPerTimeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaPerTimeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AreaPerTimeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AreaPerTimeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AreaPerTimeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaPerTimeMeasureExt


class AreaPerVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaPerVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaPerVolumeMeasure.subclass:
            return AreaPerVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return AreaPerVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AreaPerVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaPerVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AreaPerVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AreaPerVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AreaPerVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaPerVolumeMeasure


class AreaPerVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaPerVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaPerVolumeMeasureExt.subclass:
            return AreaPerVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AreaPerVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AreaPerVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaPerVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AreaPerVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AreaPerVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AreaPerVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaPerVolumeMeasureExt


class AttenuationPerFrequencyIntervalMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttenuationPerFrequencyIntervalMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttenuationPerFrequencyIntervalMeasure.subclass:
            return AttenuationPerFrequencyIntervalMeasure.subclass(*args_, **kwargs_)
        else:
            return AttenuationPerFrequencyIntervalMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AttenuationPerFrequencyIntervalMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttenuationPerFrequencyIntervalMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AttenuationPerFrequencyIntervalMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AttenuationPerFrequencyIntervalMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AttenuationPerFrequencyIntervalMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttenuationPerFrequencyIntervalMeasure


class AttenuationPerFrequencyIntervalMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttenuationPerFrequencyIntervalMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttenuationPerFrequencyIntervalMeasureExt.subclass:
            return AttenuationPerFrequencyIntervalMeasureExt.subclass(*args_, **kwargs_)
        else:
            return AttenuationPerFrequencyIntervalMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AttenuationPerFrequencyIntervalMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttenuationPerFrequencyIntervalMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AttenuationPerFrequencyIntervalMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AttenuationPerFrequencyIntervalMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AttenuationPerFrequencyIntervalMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttenuationPerFrequencyIntervalMeasureExt


class CapacitanceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CapacitanceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CapacitanceMeasure.subclass:
            return CapacitanceMeasure.subclass(*args_, **kwargs_)
        else:
            return CapacitanceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CapacitanceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CapacitanceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CapacitanceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CapacitanceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CapacitanceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CapacitanceMeasure


class CapacitanceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CapacitanceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CapacitanceMeasureExt.subclass:
            return CapacitanceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return CapacitanceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CapacitanceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CapacitanceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CapacitanceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CapacitanceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CapacitanceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CapacitanceMeasureExt


class CationExchangeCapacityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CationExchangeCapacityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CationExchangeCapacityMeasure.subclass:
            return CationExchangeCapacityMeasure.subclass(*args_, **kwargs_)
        else:
            return CationExchangeCapacityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CationExchangeCapacityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CationExchangeCapacityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CationExchangeCapacityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CationExchangeCapacityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CationExchangeCapacityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CationExchangeCapacityMeasure


class CationExchangeCapacityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CationExchangeCapacityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CationExchangeCapacityMeasureExt.subclass:
            return CationExchangeCapacityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return CationExchangeCapacityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CationExchangeCapacityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CationExchangeCapacityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CationExchangeCapacityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CationExchangeCapacityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CationExchangeCapacityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CationExchangeCapacityMeasureExt


class DataTransferSpeedMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataTransferSpeedMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataTransferSpeedMeasure.subclass:
            return DataTransferSpeedMeasure.subclass(*args_, **kwargs_)
        else:
            return DataTransferSpeedMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DataTransferSpeedMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataTransferSpeedMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DataTransferSpeedMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DataTransferSpeedMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DataTransferSpeedMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DataTransferSpeedMeasure


class DataTransferSpeedMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataTransferSpeedMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataTransferSpeedMeasureExt.subclass:
            return DataTransferSpeedMeasureExt.subclass(*args_, **kwargs_)
        else:
            return DataTransferSpeedMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DataTransferSpeedMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataTransferSpeedMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DataTransferSpeedMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DataTransferSpeedMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DataTransferSpeedMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DataTransferSpeedMeasureExt


class DiffusionCoefficientMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiffusionCoefficientMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiffusionCoefficientMeasure.subclass:
            return DiffusionCoefficientMeasure.subclass(*args_, **kwargs_)
        else:
            return DiffusionCoefficientMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DiffusionCoefficientMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiffusionCoefficientMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DiffusionCoefficientMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DiffusionCoefficientMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DiffusionCoefficientMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DiffusionCoefficientMeasure


class DiffusionCoefficientMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiffusionCoefficientMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiffusionCoefficientMeasureExt.subclass:
            return DiffusionCoefficientMeasureExt.subclass(*args_, **kwargs_)
        else:
            return DiffusionCoefficientMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DiffusionCoefficientMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiffusionCoefficientMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DiffusionCoefficientMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DiffusionCoefficientMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DiffusionCoefficientMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DiffusionCoefficientMeasureExt


class DiffusiveTimeOfFlightMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiffusiveTimeOfFlightMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiffusiveTimeOfFlightMeasure.subclass:
            return DiffusiveTimeOfFlightMeasure.subclass(*args_, **kwargs_)
        else:
            return DiffusiveTimeOfFlightMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DiffusiveTimeOfFlightMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiffusiveTimeOfFlightMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DiffusiveTimeOfFlightMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DiffusiveTimeOfFlightMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DiffusiveTimeOfFlightMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DiffusiveTimeOfFlightMeasure


class DiffusiveTimeOfFlightMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiffusiveTimeOfFlightMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiffusiveTimeOfFlightMeasureExt.subclass:
            return DiffusiveTimeOfFlightMeasureExt.subclass(*args_, **kwargs_)
        else:
            return DiffusiveTimeOfFlightMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DiffusiveTimeOfFlightMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiffusiveTimeOfFlightMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DiffusiveTimeOfFlightMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DiffusiveTimeOfFlightMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DiffusiveTimeOfFlightMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DiffusiveTimeOfFlightMeasureExt


class DigitalStorageMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DigitalStorageMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DigitalStorageMeasure.subclass:
            return DigitalStorageMeasure.subclass(*args_, **kwargs_)
        else:
            return DigitalStorageMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DigitalStorageMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DigitalStorageMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DigitalStorageMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DigitalStorageMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DigitalStorageMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DigitalStorageMeasure


class DigitalStorageMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DigitalStorageMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DigitalStorageMeasureExt.subclass:
            return DigitalStorageMeasureExt.subclass(*args_, **kwargs_)
        else:
            return DigitalStorageMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DigitalStorageMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DigitalStorageMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DigitalStorageMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DigitalStorageMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DigitalStorageMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DigitalStorageMeasureExt


class DimensionlessMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionlessMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionlessMeasure.subclass:
            return DimensionlessMeasure.subclass(*args_, **kwargs_)
        else:
            return DimensionlessMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DimensionlessMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DimensionlessMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DimensionlessMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DimensionlessMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DimensionlessMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DimensionlessMeasure


class DimensionlessMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionlessMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionlessMeasureExt.subclass:
            return DimensionlessMeasureExt.subclass(*args_, **kwargs_)
        else:
            return DimensionlessMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DimensionlessMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DimensionlessMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DimensionlessMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DimensionlessMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DimensionlessMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DimensionlessMeasureExt


class DipoleMomentMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DipoleMomentMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DipoleMomentMeasure.subclass:
            return DipoleMomentMeasure.subclass(*args_, **kwargs_)
        else:
            return DipoleMomentMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DipoleMomentMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DipoleMomentMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DipoleMomentMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DipoleMomentMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DipoleMomentMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DipoleMomentMeasure


class DipoleMomentMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DipoleMomentMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DipoleMomentMeasureExt.subclass:
            return DipoleMomentMeasureExt.subclass(*args_, **kwargs_)
        else:
            return DipoleMomentMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DipoleMomentMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DipoleMomentMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DipoleMomentMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DipoleMomentMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DipoleMomentMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DipoleMomentMeasureExt


class DoseEquivalentMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DoseEquivalentMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DoseEquivalentMeasure.subclass:
            return DoseEquivalentMeasure.subclass(*args_, **kwargs_)
        else:
            return DoseEquivalentMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DoseEquivalentMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DoseEquivalentMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DoseEquivalentMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DoseEquivalentMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DoseEquivalentMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DoseEquivalentMeasure


class DoseEquivalentMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DoseEquivalentMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DoseEquivalentMeasureExt.subclass:
            return DoseEquivalentMeasureExt.subclass(*args_, **kwargs_)
        else:
            return DoseEquivalentMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DoseEquivalentMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DoseEquivalentMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DoseEquivalentMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DoseEquivalentMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DoseEquivalentMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DoseEquivalentMeasureExt


class DynamicViscosityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DynamicViscosityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DynamicViscosityMeasure.subclass:
            return DynamicViscosityMeasure.subclass(*args_, **kwargs_)
        else:
            return DynamicViscosityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DynamicViscosityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DynamicViscosityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DynamicViscosityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DynamicViscosityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DynamicViscosityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DynamicViscosityMeasure


class DynamicViscosityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DynamicViscosityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DynamicViscosityMeasureExt.subclass:
            return DynamicViscosityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return DynamicViscosityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DynamicViscosityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DynamicViscosityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DynamicViscosityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DynamicViscosityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DynamicViscosityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DynamicViscosityMeasureExt


class ElectricalResistivityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricalResistivityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricalResistivityMeasure.subclass:
            return ElectricalResistivityMeasure.subclass(*args_, **kwargs_)
        else:
            return ElectricalResistivityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricalResistivityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricalResistivityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricalResistivityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricalResistivityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricalResistivityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricalResistivityMeasure


class ElectricalResistivityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricalResistivityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricalResistivityMeasureExt.subclass:
            return ElectricalResistivityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ElectricalResistivityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricalResistivityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricalResistivityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricalResistivityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricalResistivityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricalResistivityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricalResistivityMeasureExt


class ElectricChargeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricChargeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricChargeMeasure.subclass:
            return ElectricChargeMeasure.subclass(*args_, **kwargs_)
        else:
            return ElectricChargeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricChargeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricChargeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricChargeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricChargeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricChargeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricChargeMeasure


class ElectricChargeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricChargeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricChargeMeasureExt.subclass:
            return ElectricChargeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ElectricChargeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricChargeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricChargeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricChargeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricChargeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricChargeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricChargeMeasureExt


class ElectricChargePerAreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricChargePerAreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricChargePerAreaMeasure.subclass:
            return ElectricChargePerAreaMeasure.subclass(*args_, **kwargs_)
        else:
            return ElectricChargePerAreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricChargePerAreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricChargePerAreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricChargePerAreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricChargePerAreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricChargePerAreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricChargePerAreaMeasure


class ElectricChargePerAreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricChargePerAreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricChargePerAreaMeasureExt.subclass:
            return ElectricChargePerAreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ElectricChargePerAreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricChargePerAreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricChargePerAreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricChargePerAreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricChargePerAreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricChargePerAreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricChargePerAreaMeasureExt


class ElectricChargePerMassMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricChargePerMassMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricChargePerMassMeasure.subclass:
            return ElectricChargePerMassMeasure.subclass(*args_, **kwargs_)
        else:
            return ElectricChargePerMassMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricChargePerMassMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricChargePerMassMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricChargePerMassMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricChargePerMassMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricChargePerMassMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricChargePerMassMeasure


class ElectricChargePerMassMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricChargePerMassMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricChargePerMassMeasureExt.subclass:
            return ElectricChargePerMassMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ElectricChargePerMassMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricChargePerMassMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricChargePerMassMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricChargePerMassMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricChargePerMassMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricChargePerMassMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricChargePerMassMeasureExt


class ElectricChargePerVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricChargePerVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricChargePerVolumeMeasure.subclass:
            return ElectricChargePerVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return ElectricChargePerVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricChargePerVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricChargePerVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricChargePerVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricChargePerVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricChargePerVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricChargePerVolumeMeasure


class ElectricChargePerVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricChargePerVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricChargePerVolumeMeasureExt.subclass:
            return ElectricChargePerVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ElectricChargePerVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricChargePerVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricChargePerVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricChargePerVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricChargePerVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricChargePerVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricChargePerVolumeMeasureExt


class ElectricConductanceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricConductanceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricConductanceMeasure.subclass:
            return ElectricConductanceMeasure.subclass(*args_, **kwargs_)
        else:
            return ElectricConductanceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricConductanceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricConductanceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricConductanceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricConductanceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricConductanceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricConductanceMeasure


class ElectricConductanceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricConductanceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricConductanceMeasureExt.subclass:
            return ElectricConductanceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ElectricConductanceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricConductanceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricConductanceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricConductanceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricConductanceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricConductanceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricConductanceMeasureExt


class ElectricConductivityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricConductivityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricConductivityMeasure.subclass:
            return ElectricConductivityMeasure.subclass(*args_, **kwargs_)
        else:
            return ElectricConductivityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricConductivityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricConductivityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricConductivityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricConductivityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricConductivityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricConductivityMeasure


class ElectricConductivityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricConductivityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricConductivityMeasureExt.subclass:
            return ElectricConductivityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ElectricConductivityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricConductivityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricConductivityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricConductivityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricConductivityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricConductivityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricConductivityMeasureExt


class ElectricCurrentDensityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricCurrentDensityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricCurrentDensityMeasure.subclass:
            return ElectricCurrentDensityMeasure.subclass(*args_, **kwargs_)
        else:
            return ElectricCurrentDensityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricCurrentDensityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricCurrentDensityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricCurrentDensityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricCurrentDensityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricCurrentDensityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricCurrentDensityMeasure


class ElectricCurrentDensityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricCurrentDensityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricCurrentDensityMeasureExt.subclass:
            return ElectricCurrentDensityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ElectricCurrentDensityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricCurrentDensityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricCurrentDensityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricCurrentDensityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricCurrentDensityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricCurrentDensityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricCurrentDensityMeasureExt


class ElectricCurrentMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricCurrentMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricCurrentMeasure.subclass:
            return ElectricCurrentMeasure.subclass(*args_, **kwargs_)
        else:
            return ElectricCurrentMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricCurrentMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricCurrentMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricCurrentMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricCurrentMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricCurrentMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricCurrentMeasure


class ElectricCurrentMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricCurrentMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricCurrentMeasureExt.subclass:
            return ElectricCurrentMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ElectricCurrentMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricCurrentMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricCurrentMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricCurrentMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricCurrentMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricCurrentMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricCurrentMeasureExt


class ElectricFieldStrengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricFieldStrengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricFieldStrengthMeasure.subclass:
            return ElectricFieldStrengthMeasure.subclass(*args_, **kwargs_)
        else:
            return ElectricFieldStrengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricFieldStrengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricFieldStrengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricFieldStrengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricFieldStrengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricFieldStrengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricFieldStrengthMeasure


class ElectricFieldStrengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricFieldStrengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricFieldStrengthMeasureExt.subclass:
            return ElectricFieldStrengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ElectricFieldStrengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricFieldStrengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricFieldStrengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricFieldStrengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricFieldStrengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricFieldStrengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricFieldStrengthMeasureExt


class ElectricPotentialDifferenceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricPotentialDifferenceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricPotentialDifferenceMeasure.subclass:
            return ElectricPotentialDifferenceMeasure.subclass(*args_, **kwargs_)
        else:
            return ElectricPotentialDifferenceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricPotentialDifferenceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricPotentialDifferenceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricPotentialDifferenceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricPotentialDifferenceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricPotentialDifferenceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricPotentialDifferenceMeasure


class ElectricPotentialDifferenceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricPotentialDifferenceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricPotentialDifferenceMeasureExt.subclass:
            return ElectricPotentialDifferenceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ElectricPotentialDifferenceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricPotentialDifferenceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricPotentialDifferenceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricPotentialDifferenceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricPotentialDifferenceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricPotentialDifferenceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricPotentialDifferenceMeasureExt


class ElectricResistanceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricResistanceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricResistanceMeasure.subclass:
            return ElectricResistanceMeasure.subclass(*args_, **kwargs_)
        else:
            return ElectricResistanceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricResistanceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricResistanceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricResistanceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricResistanceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricResistanceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricResistanceMeasure


class ElectricResistanceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricResistanceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricResistanceMeasureExt.subclass:
            return ElectricResistanceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ElectricResistanceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricResistanceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricResistanceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricResistanceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricResistanceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricResistanceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricResistanceMeasureExt


class ElectricResistancePerLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricResistancePerLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricResistancePerLengthMeasure.subclass:
            return ElectricResistancePerLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return ElectricResistancePerLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricResistancePerLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricResistancePerLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricResistancePerLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricResistancePerLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricResistancePerLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricResistancePerLengthMeasure


class ElectricResistancePerLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricResistancePerLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricResistancePerLengthMeasureExt.subclass:
            return ElectricResistancePerLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ElectricResistancePerLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectricResistancePerLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricResistancePerLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectricResistancePerLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectricResistancePerLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectricResistancePerLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricResistancePerLengthMeasureExt


class ElectromagneticMomentMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectromagneticMomentMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectromagneticMomentMeasure.subclass:
            return ElectromagneticMomentMeasure.subclass(*args_, **kwargs_)
        else:
            return ElectromagneticMomentMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectromagneticMomentMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectromagneticMomentMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectromagneticMomentMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectromagneticMomentMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectromagneticMomentMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectromagneticMomentMeasure


class ElectromagneticMomentMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectromagneticMomentMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectromagneticMomentMeasureExt.subclass:
            return ElectromagneticMomentMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ElectromagneticMomentMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ElectromagneticMomentMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectromagneticMomentMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ElectromagneticMomentMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ElectromagneticMomentMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ElectromagneticMomentMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectromagneticMomentMeasureExt


class EnergyLengthPerAreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyLengthPerAreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyLengthPerAreaMeasure.subclass:
            return EnergyLengthPerAreaMeasure.subclass(*args_, **kwargs_)
        else:
            return EnergyLengthPerAreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyLengthPerAreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyLengthPerAreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyLengthPerAreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyLengthPerAreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyLengthPerAreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyLengthPerAreaMeasure


class EnergyLengthPerAreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyLengthPerAreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyLengthPerAreaMeasureExt.subclass:
            return EnergyLengthPerAreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return EnergyLengthPerAreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyLengthPerAreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyLengthPerAreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyLengthPerAreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyLengthPerAreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyLengthPerAreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyLengthPerAreaMeasureExt


class EnergyLengthPerTimeAreaTemperatureMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyLengthPerTimeAreaTemperatureMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyLengthPerTimeAreaTemperatureMeasure.subclass:
            return EnergyLengthPerTimeAreaTemperatureMeasure.subclass(*args_, **kwargs_)
        else:
            return EnergyLengthPerTimeAreaTemperatureMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyLengthPerTimeAreaTemperatureMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyLengthPerTimeAreaTemperatureMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyLengthPerTimeAreaTemperatureMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyLengthPerTimeAreaTemperatureMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyLengthPerTimeAreaTemperatureMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyLengthPerTimeAreaTemperatureMeasure


class EnergyLengthPerTimeAreaTemperatureMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyLengthPerTimeAreaTemperatureMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyLengthPerTimeAreaTemperatureMeasureExt.subclass:
            return EnergyLengthPerTimeAreaTemperatureMeasureExt.subclass(*args_, **kwargs_)
        else:
            return EnergyLengthPerTimeAreaTemperatureMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyLengthPerTimeAreaTemperatureMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyLengthPerTimeAreaTemperatureMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyLengthPerTimeAreaTemperatureMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyLengthPerTimeAreaTemperatureMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyLengthPerTimeAreaTemperatureMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyLengthPerTimeAreaTemperatureMeasureExt


class EnergyMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyMeasure.subclass:
            return EnergyMeasure.subclass(*args_, **kwargs_)
        else:
            return EnergyMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyMeasure


class EnergyMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyMeasureExt.subclass:
            return EnergyMeasureExt.subclass(*args_, **kwargs_)
        else:
            return EnergyMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyMeasureExt


class EnergyPerAreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyPerAreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyPerAreaMeasure.subclass:
            return EnergyPerAreaMeasure.subclass(*args_, **kwargs_)
        else:
            return EnergyPerAreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyPerAreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyPerAreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyPerAreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyPerAreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyPerAreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyPerAreaMeasure


class EnergyPerAreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyPerAreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyPerAreaMeasureExt.subclass:
            return EnergyPerAreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return EnergyPerAreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyPerAreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyPerAreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyPerAreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyPerAreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyPerAreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyPerAreaMeasureExt


class EnergyPerLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyPerLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyPerLengthMeasure.subclass:
            return EnergyPerLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return EnergyPerLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyPerLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyPerLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyPerLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyPerLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyPerLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyPerLengthMeasure


class EnergyPerLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyPerLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyPerLengthMeasureExt.subclass:
            return EnergyPerLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return EnergyPerLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyPerLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyPerLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyPerLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyPerLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyPerLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyPerLengthMeasureExt


class EnergyPerMassMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyPerMassMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyPerMassMeasure.subclass:
            return EnergyPerMassMeasure.subclass(*args_, **kwargs_)
        else:
            return EnergyPerMassMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyPerMassMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyPerMassMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyPerMassMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyPerMassMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyPerMassMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyPerMassMeasure


class EnergyPerMassMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyPerMassMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyPerMassMeasureExt.subclass:
            return EnergyPerMassMeasureExt.subclass(*args_, **kwargs_)
        else:
            return EnergyPerMassMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyPerMassMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyPerMassMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyPerMassMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyPerMassMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyPerMassMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyPerMassMeasureExt


class EnergyPerMassPerTimeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyPerMassPerTimeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyPerMassPerTimeMeasure.subclass:
            return EnergyPerMassPerTimeMeasure.subclass(*args_, **kwargs_)
        else:
            return EnergyPerMassPerTimeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyPerMassPerTimeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyPerMassPerTimeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyPerMassPerTimeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyPerMassPerTimeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyPerMassPerTimeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyPerMassPerTimeMeasure


class EnergyPerMassPerTimeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyPerMassPerTimeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyPerMassPerTimeMeasureExt.subclass:
            return EnergyPerMassPerTimeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return EnergyPerMassPerTimeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyPerMassPerTimeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyPerMassPerTimeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyPerMassPerTimeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyPerMassPerTimeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyPerMassPerTimeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyPerMassPerTimeMeasureExt


class EnergyPerVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyPerVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyPerVolumeMeasure.subclass:
            return EnergyPerVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return EnergyPerVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyPerVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyPerVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyPerVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyPerVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyPerVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyPerVolumeMeasure


class EnergyPerVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyPerVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyPerVolumeMeasureExt.subclass:
            return EnergyPerVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return EnergyPerVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EnergyPerVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyPerVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EnergyPerVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EnergyPerVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EnergyPerVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyPerVolumeMeasureExt


class ForceAreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForceAreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForceAreaMeasure.subclass:
            return ForceAreaMeasure.subclass(*args_, **kwargs_)
        else:
            return ForceAreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ForceAreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForceAreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ForceAreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ForceAreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ForceAreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ForceAreaMeasure


class ForceAreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForceAreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForceAreaMeasureExt.subclass:
            return ForceAreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ForceAreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ForceAreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForceAreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ForceAreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ForceAreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ForceAreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ForceAreaMeasureExt


class ForceLengthPerLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForceLengthPerLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForceLengthPerLengthMeasure.subclass:
            return ForceLengthPerLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return ForceLengthPerLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ForceLengthPerLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForceLengthPerLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ForceLengthPerLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ForceLengthPerLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ForceLengthPerLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ForceLengthPerLengthMeasure


class ForceLengthPerLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForceLengthPerLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForceLengthPerLengthMeasureExt.subclass:
            return ForceLengthPerLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ForceLengthPerLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ForceLengthPerLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForceLengthPerLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ForceLengthPerLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ForceLengthPerLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ForceLengthPerLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ForceLengthPerLengthMeasureExt


class ForceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForceMeasure.subclass:
            return ForceMeasure.subclass(*args_, **kwargs_)
        else:
            return ForceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ForceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ForceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ForceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ForceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ForceMeasure


class ForceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForceMeasureExt.subclass:
            return ForceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ForceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ForceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ForceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ForceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ForceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ForceMeasureExt


class ForcePerForceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForcePerForceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForcePerForceMeasure.subclass:
            return ForcePerForceMeasure.subclass(*args_, **kwargs_)
        else:
            return ForcePerForceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ForcePerForceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForcePerForceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ForcePerForceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ForcePerForceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ForcePerForceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ForcePerForceMeasure


class ForcePerForceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForcePerForceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForcePerForceMeasureExt.subclass:
            return ForcePerForceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ForcePerForceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ForcePerForceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForcePerForceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ForcePerForceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ForcePerForceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ForcePerForceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ForcePerForceMeasureExt


class ForcePerLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForcePerLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForcePerLengthMeasure.subclass:
            return ForcePerLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return ForcePerLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ForcePerLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForcePerLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ForcePerLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ForcePerLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ForcePerLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ForcePerLengthMeasure


class ForcePerLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForcePerLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForcePerLengthMeasureExt.subclass:
            return ForcePerLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ForcePerLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ForcePerLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForcePerLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ForcePerLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ForcePerLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ForcePerLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ForcePerLengthMeasureExt


class ForcePerVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForcePerVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForcePerVolumeMeasure.subclass:
            return ForcePerVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return ForcePerVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ForcePerVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForcePerVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ForcePerVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ForcePerVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ForcePerVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ForcePerVolumeMeasure


class ForcePerVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForcePerVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForcePerVolumeMeasureExt.subclass:
            return ForcePerVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ForcePerVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ForcePerVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForcePerVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ForcePerVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ForcePerVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ForcePerVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ForcePerVolumeMeasureExt


class FrequencyIntervalMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FrequencyIntervalMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FrequencyIntervalMeasure.subclass:
            return FrequencyIntervalMeasure.subclass(*args_, **kwargs_)
        else:
            return FrequencyIntervalMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FrequencyIntervalMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrequencyIntervalMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FrequencyIntervalMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FrequencyIntervalMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FrequencyIntervalMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FrequencyIntervalMeasure


class FrequencyIntervalMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FrequencyIntervalMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FrequencyIntervalMeasureExt.subclass:
            return FrequencyIntervalMeasureExt.subclass(*args_, **kwargs_)
        else:
            return FrequencyIntervalMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FrequencyIntervalMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrequencyIntervalMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FrequencyIntervalMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FrequencyIntervalMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FrequencyIntervalMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FrequencyIntervalMeasureExt


class FrequencyMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FrequencyMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FrequencyMeasure.subclass:
            return FrequencyMeasure.subclass(*args_, **kwargs_)
        else:
            return FrequencyMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FrequencyMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrequencyMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FrequencyMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FrequencyMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FrequencyMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FrequencyMeasure


class FrequencyMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FrequencyMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FrequencyMeasureExt.subclass:
            return FrequencyMeasureExt.subclass(*args_, **kwargs_)
        else:
            return FrequencyMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FrequencyMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrequencyMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FrequencyMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FrequencyMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FrequencyMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FrequencyMeasureExt


class HeatCapacityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatCapacityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatCapacityMeasure.subclass:
            return HeatCapacityMeasure.subclass(*args_, **kwargs_)
        else:
            return HeatCapacityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='HeatCapacityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatCapacityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='HeatCapacityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='HeatCapacityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='HeatCapacityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatCapacityMeasure


class HeatCapacityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatCapacityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatCapacityMeasureExt.subclass:
            return HeatCapacityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return HeatCapacityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='HeatCapacityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatCapacityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='HeatCapacityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='HeatCapacityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='HeatCapacityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatCapacityMeasureExt


class HeatFlowRateMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatFlowRateMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatFlowRateMeasure.subclass:
            return HeatFlowRateMeasure.subclass(*args_, **kwargs_)
        else:
            return HeatFlowRateMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='HeatFlowRateMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatFlowRateMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='HeatFlowRateMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='HeatFlowRateMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='HeatFlowRateMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatFlowRateMeasure


class HeatFlowRateMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatFlowRateMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatFlowRateMeasureExt.subclass:
            return HeatFlowRateMeasureExt.subclass(*args_, **kwargs_)
        else:
            return HeatFlowRateMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='HeatFlowRateMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatFlowRateMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='HeatFlowRateMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='HeatFlowRateMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='HeatFlowRateMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatFlowRateMeasureExt


class HeatTransferCoefficientMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatTransferCoefficientMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatTransferCoefficientMeasure.subclass:
            return HeatTransferCoefficientMeasure.subclass(*args_, **kwargs_)
        else:
            return HeatTransferCoefficientMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='HeatTransferCoefficientMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatTransferCoefficientMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='HeatTransferCoefficientMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='HeatTransferCoefficientMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='HeatTransferCoefficientMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatTransferCoefficientMeasure


class HeatTransferCoefficientMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatTransferCoefficientMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatTransferCoefficientMeasureExt.subclass:
            return HeatTransferCoefficientMeasureExt.subclass(*args_, **kwargs_)
        else:
            return HeatTransferCoefficientMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='HeatTransferCoefficientMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatTransferCoefficientMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='HeatTransferCoefficientMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='HeatTransferCoefficientMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='HeatTransferCoefficientMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatTransferCoefficientMeasureExt


class IlluminanceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IlluminanceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IlluminanceMeasure.subclass:
            return IlluminanceMeasure.subclass(*args_, **kwargs_)
        else:
            return IlluminanceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='IlluminanceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IlluminanceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='IlluminanceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='IlluminanceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='IlluminanceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IlluminanceMeasure


class IlluminanceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IlluminanceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IlluminanceMeasureExt.subclass:
            return IlluminanceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return IlluminanceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='IlluminanceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IlluminanceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='IlluminanceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='IlluminanceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='IlluminanceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IlluminanceMeasureExt


class InductanceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InductanceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InductanceMeasure.subclass:
            return InductanceMeasure.subclass(*args_, **kwargs_)
        else:
            return InductanceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='InductanceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InductanceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='InductanceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='InductanceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='InductanceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InductanceMeasure


class InductanceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InductanceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InductanceMeasureExt.subclass:
            return InductanceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return InductanceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='InductanceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InductanceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='InductanceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='InductanceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='InductanceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InductanceMeasureExt


class IsothermalCompressibilityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IsothermalCompressibilityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IsothermalCompressibilityMeasure.subclass:
            return IsothermalCompressibilityMeasure.subclass(*args_, **kwargs_)
        else:
            return IsothermalCompressibilityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='IsothermalCompressibilityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IsothermalCompressibilityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='IsothermalCompressibilityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='IsothermalCompressibilityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='IsothermalCompressibilityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IsothermalCompressibilityMeasure


class IsothermalCompressibilityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IsothermalCompressibilityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IsothermalCompressibilityMeasureExt.subclass:
            return IsothermalCompressibilityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return IsothermalCompressibilityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='IsothermalCompressibilityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IsothermalCompressibilityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='IsothermalCompressibilityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='IsothermalCompressibilityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='IsothermalCompressibilityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IsothermalCompressibilityMeasureExt


class KinematicViscosityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KinematicViscosityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KinematicViscosityMeasure.subclass:
            return KinematicViscosityMeasure.subclass(*args_, **kwargs_)
        else:
            return KinematicViscosityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='KinematicViscosityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KinematicViscosityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='KinematicViscosityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='KinematicViscosityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='KinematicViscosityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class KinematicViscosityMeasure


class KinematicViscosityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KinematicViscosityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KinematicViscosityMeasureExt.subclass:
            return KinematicViscosityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return KinematicViscosityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='KinematicViscosityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KinematicViscosityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='KinematicViscosityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='KinematicViscosityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='KinematicViscosityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class KinematicViscosityMeasureExt


class LengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthMeasure.subclass:
            return LengthMeasure.subclass(*args_, **kwargs_)
        else:
            return LengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthMeasure


class LengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthMeasureExt.subclass:
            return LengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthMeasureExt


class LengthPerLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthPerLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthPerLengthMeasure.subclass:
            return LengthPerLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return LengthPerLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LengthPerLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthPerLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LengthPerLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LengthPerLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LengthPerLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthPerLengthMeasure


class LengthPerLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthPerLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthPerLengthMeasureExt.subclass:
            return LengthPerLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LengthPerLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LengthPerLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthPerLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LengthPerLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LengthPerLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LengthPerLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthPerLengthMeasureExt


class LengthPerMassMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthPerMassMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthPerMassMeasure.subclass:
            return LengthPerMassMeasure.subclass(*args_, **kwargs_)
        else:
            return LengthPerMassMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LengthPerMassMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthPerMassMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LengthPerMassMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LengthPerMassMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LengthPerMassMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthPerMassMeasure


class LengthPerMassMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthPerMassMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthPerMassMeasureExt.subclass:
            return LengthPerMassMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LengthPerMassMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LengthPerMassMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthPerMassMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LengthPerMassMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LengthPerMassMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LengthPerMassMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthPerMassMeasureExt


class LengthPerPressureMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthPerPressureMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthPerPressureMeasure.subclass:
            return LengthPerPressureMeasure.subclass(*args_, **kwargs_)
        else:
            return LengthPerPressureMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LengthPerPressureMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthPerPressureMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LengthPerPressureMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LengthPerPressureMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LengthPerPressureMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthPerPressureMeasure


class LengthPerPressureMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthPerPressureMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthPerPressureMeasureExt.subclass:
            return LengthPerPressureMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LengthPerPressureMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LengthPerPressureMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthPerPressureMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LengthPerPressureMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LengthPerPressureMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LengthPerPressureMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthPerPressureMeasureExt


class LengthPerTemperatureMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthPerTemperatureMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthPerTemperatureMeasure.subclass:
            return LengthPerTemperatureMeasure.subclass(*args_, **kwargs_)
        else:
            return LengthPerTemperatureMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LengthPerTemperatureMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthPerTemperatureMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LengthPerTemperatureMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LengthPerTemperatureMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LengthPerTemperatureMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthPerTemperatureMeasure


class LengthPerTemperatureMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthPerTemperatureMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthPerTemperatureMeasureExt.subclass:
            return LengthPerTemperatureMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LengthPerTemperatureMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LengthPerTemperatureMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthPerTemperatureMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LengthPerTemperatureMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LengthPerTemperatureMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LengthPerTemperatureMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthPerTemperatureMeasureExt


class LengthPerTimeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthPerTimeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthPerTimeMeasure.subclass:
            return LengthPerTimeMeasure.subclass(*args_, **kwargs_)
        else:
            return LengthPerTimeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LengthPerTimeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthPerTimeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LengthPerTimeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LengthPerTimeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LengthPerTimeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthPerTimeMeasure


class LengthPerTimeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthPerTimeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthPerTimeMeasureExt.subclass:
            return LengthPerTimeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LengthPerTimeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LengthPerTimeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthPerTimeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LengthPerTimeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LengthPerTimeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LengthPerTimeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthPerTimeMeasureExt


class LengthPerVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthPerVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthPerVolumeMeasure.subclass:
            return LengthPerVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return LengthPerVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LengthPerVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthPerVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LengthPerVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LengthPerVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LengthPerVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthPerVolumeMeasure


class LengthPerVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthPerVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthPerVolumeMeasureExt.subclass:
            return LengthPerVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LengthPerVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LengthPerVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthPerVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LengthPerVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LengthPerVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LengthPerVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthPerVolumeMeasureExt


class LightExposureMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LightExposureMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LightExposureMeasure.subclass:
            return LightExposureMeasure.subclass(*args_, **kwargs_)
        else:
            return LightExposureMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LightExposureMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LightExposureMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LightExposureMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LightExposureMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LightExposureMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LightExposureMeasure


class LightExposureMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LightExposureMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LightExposureMeasureExt.subclass:
            return LightExposureMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LightExposureMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LightExposureMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LightExposureMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LightExposureMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LightExposureMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LightExposureMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LightExposureMeasureExt


class LinearAccelerationMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinearAccelerationMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinearAccelerationMeasure.subclass:
            return LinearAccelerationMeasure.subclass(*args_, **kwargs_)
        else:
            return LinearAccelerationMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LinearAccelerationMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearAccelerationMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LinearAccelerationMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LinearAccelerationMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LinearAccelerationMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinearAccelerationMeasure


class LinearAccelerationMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinearAccelerationMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinearAccelerationMeasureExt.subclass:
            return LinearAccelerationMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LinearAccelerationMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LinearAccelerationMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearAccelerationMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LinearAccelerationMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LinearAccelerationMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LinearAccelerationMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinearAccelerationMeasureExt


class LinearThermalExpansionMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinearThermalExpansionMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinearThermalExpansionMeasure.subclass:
            return LinearThermalExpansionMeasure.subclass(*args_, **kwargs_)
        else:
            return LinearThermalExpansionMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LinearThermalExpansionMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearThermalExpansionMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LinearThermalExpansionMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LinearThermalExpansionMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LinearThermalExpansionMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinearThermalExpansionMeasure


class LinearThermalExpansionMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinearThermalExpansionMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinearThermalExpansionMeasureExt.subclass:
            return LinearThermalExpansionMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LinearThermalExpansionMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LinearThermalExpansionMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearThermalExpansionMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LinearThermalExpansionMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LinearThermalExpansionMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LinearThermalExpansionMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinearThermalExpansionMeasureExt


class LogarithmicPowerRatioMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogarithmicPowerRatioMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogarithmicPowerRatioMeasure.subclass:
            return LogarithmicPowerRatioMeasure.subclass(*args_, **kwargs_)
        else:
            return LogarithmicPowerRatioMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LogarithmicPowerRatioMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LogarithmicPowerRatioMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LogarithmicPowerRatioMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LogarithmicPowerRatioMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LogarithmicPowerRatioMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LogarithmicPowerRatioMeasure


class LogarithmicPowerRatioMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogarithmicPowerRatioMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogarithmicPowerRatioMeasureExt.subclass:
            return LogarithmicPowerRatioMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LogarithmicPowerRatioMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LogarithmicPowerRatioMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LogarithmicPowerRatioMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LogarithmicPowerRatioMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LogarithmicPowerRatioMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LogarithmicPowerRatioMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LogarithmicPowerRatioMeasureExt


class LogarithmicPowerRatioPerLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogarithmicPowerRatioPerLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogarithmicPowerRatioPerLengthMeasure.subclass:
            return LogarithmicPowerRatioPerLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return LogarithmicPowerRatioPerLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LogarithmicPowerRatioPerLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LogarithmicPowerRatioPerLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LogarithmicPowerRatioPerLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LogarithmicPowerRatioPerLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LogarithmicPowerRatioPerLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LogarithmicPowerRatioPerLengthMeasure


class LogarithmicPowerRatioPerLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogarithmicPowerRatioPerLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogarithmicPowerRatioPerLengthMeasureExt.subclass:
            return LogarithmicPowerRatioPerLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LogarithmicPowerRatioPerLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LogarithmicPowerRatioPerLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LogarithmicPowerRatioPerLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LogarithmicPowerRatioPerLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LogarithmicPowerRatioPerLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LogarithmicPowerRatioPerLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LogarithmicPowerRatioPerLengthMeasureExt


class LuminanceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LuminanceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LuminanceMeasure.subclass:
            return LuminanceMeasure.subclass(*args_, **kwargs_)
        else:
            return LuminanceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LuminanceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LuminanceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LuminanceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LuminanceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LuminanceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LuminanceMeasure


class LuminanceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LuminanceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LuminanceMeasureExt.subclass:
            return LuminanceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LuminanceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LuminanceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LuminanceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LuminanceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LuminanceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LuminanceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LuminanceMeasureExt


class LuminousEfficacyMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LuminousEfficacyMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LuminousEfficacyMeasure.subclass:
            return LuminousEfficacyMeasure.subclass(*args_, **kwargs_)
        else:
            return LuminousEfficacyMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LuminousEfficacyMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LuminousEfficacyMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LuminousEfficacyMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LuminousEfficacyMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LuminousEfficacyMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LuminousEfficacyMeasure


class LuminousEfficacyMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LuminousEfficacyMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LuminousEfficacyMeasureExt.subclass:
            return LuminousEfficacyMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LuminousEfficacyMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LuminousEfficacyMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LuminousEfficacyMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LuminousEfficacyMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LuminousEfficacyMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LuminousEfficacyMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LuminousEfficacyMeasureExt


class LuminousFluxMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LuminousFluxMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LuminousFluxMeasure.subclass:
            return LuminousFluxMeasure.subclass(*args_, **kwargs_)
        else:
            return LuminousFluxMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LuminousFluxMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LuminousFluxMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LuminousFluxMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LuminousFluxMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LuminousFluxMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LuminousFluxMeasure


class LuminousFluxMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LuminousFluxMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LuminousFluxMeasureExt.subclass:
            return LuminousFluxMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LuminousFluxMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LuminousFluxMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LuminousFluxMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LuminousFluxMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LuminousFluxMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LuminousFluxMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LuminousFluxMeasureExt


class LuminousIntensityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LuminousIntensityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LuminousIntensityMeasure.subclass:
            return LuminousIntensityMeasure.subclass(*args_, **kwargs_)
        else:
            return LuminousIntensityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LuminousIntensityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LuminousIntensityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LuminousIntensityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LuminousIntensityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LuminousIntensityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LuminousIntensityMeasure


class LuminousIntensityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LuminousIntensityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LuminousIntensityMeasureExt.subclass:
            return LuminousIntensityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return LuminousIntensityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LuminousIntensityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LuminousIntensityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LuminousIntensityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LuminousIntensityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LuminousIntensityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LuminousIntensityMeasureExt


class MagneticDipoleMomentMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MagneticDipoleMomentMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MagneticDipoleMomentMeasure.subclass:
            return MagneticDipoleMomentMeasure.subclass(*args_, **kwargs_)
        else:
            return MagneticDipoleMomentMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MagneticDipoleMomentMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MagneticDipoleMomentMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MagneticDipoleMomentMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MagneticDipoleMomentMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MagneticDipoleMomentMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MagneticDipoleMomentMeasure


class MagneticDipoleMomentMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MagneticDipoleMomentMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MagneticDipoleMomentMeasureExt.subclass:
            return MagneticDipoleMomentMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MagneticDipoleMomentMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MagneticDipoleMomentMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MagneticDipoleMomentMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MagneticDipoleMomentMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MagneticDipoleMomentMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MagneticDipoleMomentMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MagneticDipoleMomentMeasureExt


class MagneticFieldStrengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MagneticFieldStrengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MagneticFieldStrengthMeasure.subclass:
            return MagneticFieldStrengthMeasure.subclass(*args_, **kwargs_)
        else:
            return MagneticFieldStrengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MagneticFieldStrengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MagneticFieldStrengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MagneticFieldStrengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MagneticFieldStrengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MagneticFieldStrengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MagneticFieldStrengthMeasure


class MagneticFieldStrengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MagneticFieldStrengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MagneticFieldStrengthMeasureExt.subclass:
            return MagneticFieldStrengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MagneticFieldStrengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MagneticFieldStrengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MagneticFieldStrengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MagneticFieldStrengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MagneticFieldStrengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MagneticFieldStrengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MagneticFieldStrengthMeasureExt


class MagneticFluxDensityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MagneticFluxDensityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MagneticFluxDensityMeasure.subclass:
            return MagneticFluxDensityMeasure.subclass(*args_, **kwargs_)
        else:
            return MagneticFluxDensityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MagneticFluxDensityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MagneticFluxDensityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MagneticFluxDensityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MagneticFluxDensityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MagneticFluxDensityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MagneticFluxDensityMeasure


class MagneticFluxDensityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MagneticFluxDensityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MagneticFluxDensityMeasureExt.subclass:
            return MagneticFluxDensityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MagneticFluxDensityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MagneticFluxDensityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MagneticFluxDensityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MagneticFluxDensityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MagneticFluxDensityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MagneticFluxDensityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MagneticFluxDensityMeasureExt


class MagneticFluxDensityPerLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MagneticFluxDensityPerLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MagneticFluxDensityPerLengthMeasure.subclass:
            return MagneticFluxDensityPerLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return MagneticFluxDensityPerLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MagneticFluxDensityPerLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MagneticFluxDensityPerLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MagneticFluxDensityPerLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MagneticFluxDensityPerLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MagneticFluxDensityPerLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MagneticFluxDensityPerLengthMeasure


class MagneticFluxDensityPerLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MagneticFluxDensityPerLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MagneticFluxDensityPerLengthMeasureExt.subclass:
            return MagneticFluxDensityPerLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MagneticFluxDensityPerLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MagneticFluxDensityPerLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MagneticFluxDensityPerLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MagneticFluxDensityPerLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MagneticFluxDensityPerLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MagneticFluxDensityPerLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MagneticFluxDensityPerLengthMeasureExt


class MagneticFluxMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MagneticFluxMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MagneticFluxMeasure.subclass:
            return MagneticFluxMeasure.subclass(*args_, **kwargs_)
        else:
            return MagneticFluxMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MagneticFluxMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MagneticFluxMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MagneticFluxMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MagneticFluxMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MagneticFluxMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MagneticFluxMeasure


class MagneticFluxMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MagneticFluxMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MagneticFluxMeasureExt.subclass:
            return MagneticFluxMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MagneticFluxMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MagneticFluxMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MagneticFluxMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MagneticFluxMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MagneticFluxMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MagneticFluxMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MagneticFluxMeasureExt


class MagneticPermeabilityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MagneticPermeabilityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MagneticPermeabilityMeasure.subclass:
            return MagneticPermeabilityMeasure.subclass(*args_, **kwargs_)
        else:
            return MagneticPermeabilityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MagneticPermeabilityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MagneticPermeabilityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MagneticPermeabilityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MagneticPermeabilityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MagneticPermeabilityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MagneticPermeabilityMeasure


class MagneticPermeabilityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MagneticPermeabilityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MagneticPermeabilityMeasureExt.subclass:
            return MagneticPermeabilityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MagneticPermeabilityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MagneticPermeabilityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MagneticPermeabilityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MagneticPermeabilityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MagneticPermeabilityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MagneticPermeabilityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MagneticPermeabilityMeasureExt


class MagneticVectorPotentialMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MagneticVectorPotentialMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MagneticVectorPotentialMeasure.subclass:
            return MagneticVectorPotentialMeasure.subclass(*args_, **kwargs_)
        else:
            return MagneticVectorPotentialMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MagneticVectorPotentialMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MagneticVectorPotentialMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MagneticVectorPotentialMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MagneticVectorPotentialMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MagneticVectorPotentialMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MagneticVectorPotentialMeasure


class MagneticVectorPotentialMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MagneticVectorPotentialMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MagneticVectorPotentialMeasureExt.subclass:
            return MagneticVectorPotentialMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MagneticVectorPotentialMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MagneticVectorPotentialMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MagneticVectorPotentialMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MagneticVectorPotentialMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MagneticVectorPotentialMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MagneticVectorPotentialMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MagneticVectorPotentialMeasureExt


class MassLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassLengthMeasure.subclass:
            return MassLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return MassLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassLengthMeasure


class MassLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassLengthMeasureExt.subclass:
            return MassLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MassLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassLengthMeasureExt


class MassMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassMeasure.subclass:
            return MassMeasure.subclass(*args_, **kwargs_)
        else:
            return MassMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassMeasure


class MassMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassMeasureExt.subclass:
            return MassMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MassMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassMeasureExt


class MassPerAreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerAreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerAreaMeasure.subclass:
            return MassPerAreaMeasure.subclass(*args_, **kwargs_)
        else:
            return MassPerAreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerAreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerAreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerAreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerAreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerAreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerAreaMeasure


class MassPerAreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerAreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerAreaMeasureExt.subclass:
            return MassPerAreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MassPerAreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerAreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerAreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerAreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerAreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerAreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerAreaMeasureExt


class MassPerEnergyMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerEnergyMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerEnergyMeasure.subclass:
            return MassPerEnergyMeasure.subclass(*args_, **kwargs_)
        else:
            return MassPerEnergyMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerEnergyMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerEnergyMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerEnergyMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerEnergyMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerEnergyMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerEnergyMeasure


class MassPerEnergyMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerEnergyMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerEnergyMeasureExt.subclass:
            return MassPerEnergyMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MassPerEnergyMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerEnergyMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerEnergyMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerEnergyMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerEnergyMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerEnergyMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerEnergyMeasureExt


class MassPerLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerLengthMeasure.subclass:
            return MassPerLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return MassPerLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerLengthMeasure


class MassPerLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerLengthMeasureExt.subclass:
            return MassPerLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MassPerLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerLengthMeasureExt


class MassPerMassMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerMassMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerMassMeasure.subclass:
            return MassPerMassMeasure.subclass(*args_, **kwargs_)
        else:
            return MassPerMassMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerMassMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerMassMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerMassMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerMassMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerMassMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerMassMeasure


class MassPerMassMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerMassMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerMassMeasureExt.subclass:
            return MassPerMassMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MassPerMassMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerMassMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerMassMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerMassMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerMassMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerMassMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerMassMeasureExt


class MassPerTimeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerTimeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerTimeMeasure.subclass:
            return MassPerTimeMeasure.subclass(*args_, **kwargs_)
        else:
            return MassPerTimeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerTimeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerTimeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerTimeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerTimeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerTimeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerTimeMeasure


class MassPerTimeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerTimeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerTimeMeasureExt.subclass:
            return MassPerTimeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MassPerTimeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerTimeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerTimeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerTimeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerTimeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerTimeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerTimeMeasureExt


class MassPerTimePerAreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerTimePerAreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerTimePerAreaMeasure.subclass:
            return MassPerTimePerAreaMeasure.subclass(*args_, **kwargs_)
        else:
            return MassPerTimePerAreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerTimePerAreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerTimePerAreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerTimePerAreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerTimePerAreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerTimePerAreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerTimePerAreaMeasure


class MassPerTimePerAreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerTimePerAreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerTimePerAreaMeasureExt.subclass:
            return MassPerTimePerAreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MassPerTimePerAreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerTimePerAreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerTimePerAreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerTimePerAreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerTimePerAreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerTimePerAreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerTimePerAreaMeasureExt


class MassPerTimePerLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerTimePerLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerTimePerLengthMeasure.subclass:
            return MassPerTimePerLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return MassPerTimePerLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerTimePerLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerTimePerLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerTimePerLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerTimePerLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerTimePerLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerTimePerLengthMeasure


class MassPerTimePerLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerTimePerLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerTimePerLengthMeasureExt.subclass:
            return MassPerTimePerLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MassPerTimePerLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerTimePerLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerTimePerLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerTimePerLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerTimePerLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerTimePerLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerTimePerLengthMeasureExt


class MassPerVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerVolumeMeasure.subclass:
            return MassPerVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return MassPerVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerVolumeMeasure


class MassPerVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerVolumeMeasureExt.subclass:
            return MassPerVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MassPerVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerVolumeMeasureExt


class MassPerVolumePerLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerVolumePerLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerVolumePerLengthMeasure.subclass:
            return MassPerVolumePerLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return MassPerVolumePerLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerVolumePerLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerVolumePerLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerVolumePerLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerVolumePerLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerVolumePerLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerVolumePerLengthMeasure


class MassPerVolumePerLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerVolumePerLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerVolumePerLengthMeasureExt.subclass:
            return MassPerVolumePerLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MassPerVolumePerLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerVolumePerLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerVolumePerLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerVolumePerLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerVolumePerLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerVolumePerLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerVolumePerLengthMeasureExt


class MassPerVolumePerPressureMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerVolumePerPressureMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerVolumePerPressureMeasure.subclass:
            return MassPerVolumePerPressureMeasure.subclass(*args_, **kwargs_)
        else:
            return MassPerVolumePerPressureMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerVolumePerPressureMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerVolumePerPressureMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerVolumePerPressureMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerVolumePerPressureMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerVolumePerPressureMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerVolumePerPressureMeasure


class MassPerVolumePerPressureMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerVolumePerPressureMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerVolumePerPressureMeasureExt.subclass:
            return MassPerVolumePerPressureMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MassPerVolumePerPressureMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerVolumePerPressureMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerVolumePerPressureMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerVolumePerPressureMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerVolumePerPressureMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerVolumePerPressureMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerVolumePerPressureMeasureExt


class MassPerVolumePerTemperatureMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerVolumePerTemperatureMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerVolumePerTemperatureMeasure.subclass:
            return MassPerVolumePerTemperatureMeasure.subclass(*args_, **kwargs_)
        else:
            return MassPerVolumePerTemperatureMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerVolumePerTemperatureMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerVolumePerTemperatureMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerVolumePerTemperatureMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerVolumePerTemperatureMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerVolumePerTemperatureMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerVolumePerTemperatureMeasure


class MassPerVolumePerTemperatureMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MassPerVolumePerTemperatureMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MassPerVolumePerTemperatureMeasureExt.subclass:
            return MassPerVolumePerTemperatureMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MassPerVolumePerTemperatureMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MassPerVolumePerTemperatureMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassPerVolumePerTemperatureMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MassPerVolumePerTemperatureMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MassPerVolumePerTemperatureMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MassPerVolumePerTemperatureMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassPerVolumePerTemperatureMeasureExt


class MobilityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MobilityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MobilityMeasure.subclass:
            return MobilityMeasure.subclass(*args_, **kwargs_)
        else:
            return MobilityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MobilityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MobilityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MobilityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MobilityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MobilityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MobilityMeasure


class MobilityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MobilityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MobilityMeasureExt.subclass:
            return MobilityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MobilityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MobilityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MobilityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MobilityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MobilityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MobilityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MobilityMeasureExt


class MolarEnergyMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MolarEnergyMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MolarEnergyMeasure.subclass:
            return MolarEnergyMeasure.subclass(*args_, **kwargs_)
        else:
            return MolarEnergyMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MolarEnergyMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MolarEnergyMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MolarEnergyMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MolarEnergyMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MolarEnergyMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MolarEnergyMeasure


class MolarEnergyMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MolarEnergyMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MolarEnergyMeasureExt.subclass:
            return MolarEnergyMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MolarEnergyMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MolarEnergyMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MolarEnergyMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MolarEnergyMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MolarEnergyMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MolarEnergyMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MolarEnergyMeasureExt


class MolarHeatCapacityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MolarHeatCapacityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MolarHeatCapacityMeasure.subclass:
            return MolarHeatCapacityMeasure.subclass(*args_, **kwargs_)
        else:
            return MolarHeatCapacityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MolarHeatCapacityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MolarHeatCapacityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MolarHeatCapacityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MolarHeatCapacityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MolarHeatCapacityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MolarHeatCapacityMeasure


class MolarHeatCapacityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MolarHeatCapacityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MolarHeatCapacityMeasureExt.subclass:
            return MolarHeatCapacityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MolarHeatCapacityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MolarHeatCapacityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MolarHeatCapacityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MolarHeatCapacityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MolarHeatCapacityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MolarHeatCapacityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MolarHeatCapacityMeasureExt


class MolarVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MolarVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MolarVolumeMeasure.subclass:
            return MolarVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return MolarVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MolarVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MolarVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MolarVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MolarVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MolarVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MolarVolumeMeasure


class MolarVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MolarVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MolarVolumeMeasureExt.subclass:
            return MolarVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MolarVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MolarVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MolarVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MolarVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MolarVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MolarVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MolarVolumeMeasureExt


class MolecularWeightMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MolecularWeightMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MolecularWeightMeasure.subclass:
            return MolecularWeightMeasure.subclass(*args_, **kwargs_)
        else:
            return MolecularWeightMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MolecularWeightMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MolecularWeightMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MolecularWeightMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MolecularWeightMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MolecularWeightMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MolecularWeightMeasure


class MolecularWeightMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MolecularWeightMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MolecularWeightMeasureExt.subclass:
            return MolecularWeightMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MolecularWeightMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MolecularWeightMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MolecularWeightMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MolecularWeightMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MolecularWeightMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MolecularWeightMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MolecularWeightMeasureExt


class MomentOfForceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MomentOfForceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MomentOfForceMeasure.subclass:
            return MomentOfForceMeasure.subclass(*args_, **kwargs_)
        else:
            return MomentOfForceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MomentOfForceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MomentOfForceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MomentOfForceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MomentOfForceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MomentOfForceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MomentOfForceMeasure


class MomentOfForceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MomentOfForceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MomentOfForceMeasureExt.subclass:
            return MomentOfForceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MomentOfForceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MomentOfForceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MomentOfForceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MomentOfForceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MomentOfForceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MomentOfForceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MomentOfForceMeasureExt


class MomentOfInertiaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MomentOfInertiaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MomentOfInertiaMeasure.subclass:
            return MomentOfInertiaMeasure.subclass(*args_, **kwargs_)
        else:
            return MomentOfInertiaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MomentOfInertiaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MomentOfInertiaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MomentOfInertiaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MomentOfInertiaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MomentOfInertiaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MomentOfInertiaMeasure


class MomentOfInertiaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MomentOfInertiaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MomentOfInertiaMeasureExt.subclass:
            return MomentOfInertiaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MomentOfInertiaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MomentOfInertiaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MomentOfInertiaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MomentOfInertiaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MomentOfInertiaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MomentOfInertiaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MomentOfInertiaMeasureExt


class MomentumMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MomentumMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MomentumMeasure.subclass:
            return MomentumMeasure.subclass(*args_, **kwargs_)
        else:
            return MomentumMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MomentumMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MomentumMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MomentumMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MomentumMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MomentumMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MomentumMeasure


class MomentumMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MomentumMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MomentumMeasureExt.subclass:
            return MomentumMeasureExt.subclass(*args_, **kwargs_)
        else:
            return MomentumMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MomentumMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MomentumMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MomentumMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MomentumMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MomentumMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MomentumMeasureExt


class NormalizedPowerMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NormalizedPowerMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NormalizedPowerMeasure.subclass:
            return NormalizedPowerMeasure.subclass(*args_, **kwargs_)
        else:
            return NormalizedPowerMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='NormalizedPowerMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NormalizedPowerMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='NormalizedPowerMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='NormalizedPowerMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='NormalizedPowerMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NormalizedPowerMeasure


class NormalizedPowerMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NormalizedPowerMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NormalizedPowerMeasureExt.subclass:
            return NormalizedPowerMeasureExt.subclass(*args_, **kwargs_)
        else:
            return NormalizedPowerMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='NormalizedPowerMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NormalizedPowerMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='NormalizedPowerMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='NormalizedPowerMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='NormalizedPowerMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NormalizedPowerMeasureExt


class PermeabilityLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PermeabilityLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PermeabilityLengthMeasure.subclass:
            return PermeabilityLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return PermeabilityLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PermeabilityLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PermeabilityLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PermeabilityLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PermeabilityLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PermeabilityLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PermeabilityLengthMeasure


class PermeabilityLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PermeabilityLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PermeabilityLengthMeasureExt.subclass:
            return PermeabilityLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PermeabilityLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PermeabilityLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PermeabilityLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PermeabilityLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PermeabilityLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PermeabilityLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PermeabilityLengthMeasureExt


class PermeabilityRockMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PermeabilityRockMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PermeabilityRockMeasure.subclass:
            return PermeabilityRockMeasure.subclass(*args_, **kwargs_)
        else:
            return PermeabilityRockMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PermeabilityRockMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PermeabilityRockMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PermeabilityRockMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PermeabilityRockMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PermeabilityRockMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PermeabilityRockMeasure


class PermeabilityRockMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PermeabilityRockMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PermeabilityRockMeasureExt.subclass:
            return PermeabilityRockMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PermeabilityRockMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PermeabilityRockMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PermeabilityRockMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PermeabilityRockMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PermeabilityRockMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PermeabilityRockMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PermeabilityRockMeasureExt


class PermittivityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PermittivityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PermittivityMeasure.subclass:
            return PermittivityMeasure.subclass(*args_, **kwargs_)
        else:
            return PermittivityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PermittivityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PermittivityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PermittivityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PermittivityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PermittivityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PermittivityMeasure


class PermittivityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PermittivityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PermittivityMeasureExt.subclass:
            return PermittivityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PermittivityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PermittivityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PermittivityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PermittivityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PermittivityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PermittivityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PermittivityMeasureExt


class PlaneAngleMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlaneAngleMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlaneAngleMeasure.subclass:
            return PlaneAngleMeasure.subclass(*args_, **kwargs_)
        else:
            return PlaneAngleMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PlaneAngleMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlaneAngleMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PlaneAngleMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PlaneAngleMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PlaneAngleMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PlaneAngleMeasure


class PlaneAngleMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlaneAngleMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlaneAngleMeasureExt.subclass:
            return PlaneAngleMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PlaneAngleMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PlaneAngleMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlaneAngleMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PlaneAngleMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PlaneAngleMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PlaneAngleMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PlaneAngleMeasureExt


class PotentialDifferencePerPowerDropMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PotentialDifferencePerPowerDropMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PotentialDifferencePerPowerDropMeasure.subclass:
            return PotentialDifferencePerPowerDropMeasure.subclass(*args_, **kwargs_)
        else:
            return PotentialDifferencePerPowerDropMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PotentialDifferencePerPowerDropMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PotentialDifferencePerPowerDropMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PotentialDifferencePerPowerDropMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PotentialDifferencePerPowerDropMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PotentialDifferencePerPowerDropMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PotentialDifferencePerPowerDropMeasure


class PotentialDifferencePerPowerDropMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PotentialDifferencePerPowerDropMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PotentialDifferencePerPowerDropMeasureExt.subclass:
            return PotentialDifferencePerPowerDropMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PotentialDifferencePerPowerDropMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PotentialDifferencePerPowerDropMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PotentialDifferencePerPowerDropMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PotentialDifferencePerPowerDropMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PotentialDifferencePerPowerDropMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PotentialDifferencePerPowerDropMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PotentialDifferencePerPowerDropMeasureExt


class PowerMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerMeasure.subclass:
            return PowerMeasure.subclass(*args_, **kwargs_)
        else:
            return PowerMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PowerMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PowerMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PowerMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PowerMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PowerMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PowerMeasure


class PowerMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerMeasureExt.subclass:
            return PowerMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PowerMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PowerMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PowerMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PowerMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PowerMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PowerMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PowerMeasureExt


class PowerPerAreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerPerAreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerPerAreaMeasure.subclass:
            return PowerPerAreaMeasure.subclass(*args_, **kwargs_)
        else:
            return PowerPerAreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PowerPerAreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PowerPerAreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PowerPerAreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PowerPerAreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PowerPerAreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PowerPerAreaMeasure


class PowerPerAreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerPerAreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerPerAreaMeasureExt.subclass:
            return PowerPerAreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PowerPerAreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PowerPerAreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PowerPerAreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PowerPerAreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PowerPerAreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PowerPerAreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PowerPerAreaMeasureExt


class PowerPerPowerMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerPerPowerMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerPerPowerMeasure.subclass:
            return PowerPerPowerMeasure.subclass(*args_, **kwargs_)
        else:
            return PowerPerPowerMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PowerPerPowerMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PowerPerPowerMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PowerPerPowerMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PowerPerPowerMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PowerPerPowerMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PowerPerPowerMeasure


class PowerPerPowerMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerPerPowerMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerPerPowerMeasureExt.subclass:
            return PowerPerPowerMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PowerPerPowerMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PowerPerPowerMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PowerPerPowerMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PowerPerPowerMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PowerPerPowerMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PowerPerPowerMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PowerPerPowerMeasureExt


class PowerPerVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerPerVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerPerVolumeMeasure.subclass:
            return PowerPerVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return PowerPerVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PowerPerVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PowerPerVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PowerPerVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PowerPerVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PowerPerVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PowerPerVolumeMeasure


class PowerPerVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerPerVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerPerVolumeMeasureExt.subclass:
            return PowerPerVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PowerPerVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PowerPerVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PowerPerVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PowerPerVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PowerPerVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PowerPerVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PowerPerVolumeMeasureExt


class PressureMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressureMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressureMeasure.subclass:
            return PressureMeasure.subclass(*args_, **kwargs_)
        else:
            return PressureMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PressureMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PressureMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PressureMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PressureMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PressureMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PressureMeasure


class PressureMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressureMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressureMeasureExt.subclass:
            return PressureMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PressureMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PressureMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PressureMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PressureMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PressureMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PressureMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PressureMeasureExt


class PressurePerPressureMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressurePerPressureMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressurePerPressureMeasure.subclass:
            return PressurePerPressureMeasure.subclass(*args_, **kwargs_)
        else:
            return PressurePerPressureMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PressurePerPressureMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PressurePerPressureMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PressurePerPressureMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PressurePerPressureMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PressurePerPressureMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PressurePerPressureMeasure


class PressurePerPressureMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressurePerPressureMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressurePerPressureMeasureExt.subclass:
            return PressurePerPressureMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PressurePerPressureMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PressurePerPressureMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PressurePerPressureMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PressurePerPressureMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PressurePerPressureMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PressurePerPressureMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PressurePerPressureMeasureExt


class PressurePerTimeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressurePerTimeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressurePerTimeMeasure.subclass:
            return PressurePerTimeMeasure.subclass(*args_, **kwargs_)
        else:
            return PressurePerTimeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PressurePerTimeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PressurePerTimeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PressurePerTimeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PressurePerTimeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PressurePerTimeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PressurePerTimeMeasure


class PressurePerTimeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressurePerTimeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressurePerTimeMeasureExt.subclass:
            return PressurePerTimeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PressurePerTimeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PressurePerTimeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PressurePerTimeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PressurePerTimeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PressurePerTimeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PressurePerTimeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PressurePerTimeMeasureExt


class PressurePerVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressurePerVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressurePerVolumeMeasure.subclass:
            return PressurePerVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return PressurePerVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PressurePerVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PressurePerVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PressurePerVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PressurePerVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PressurePerVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PressurePerVolumeMeasure


class PressurePerVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressurePerVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressurePerVolumeMeasureExt.subclass:
            return PressurePerVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PressurePerVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PressurePerVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PressurePerVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PressurePerVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PressurePerVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PressurePerVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PressurePerVolumeMeasureExt


class PressureSquaredMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressureSquaredMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressureSquaredMeasure.subclass:
            return PressureSquaredMeasure.subclass(*args_, **kwargs_)
        else:
            return PressureSquaredMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PressureSquaredMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PressureSquaredMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PressureSquaredMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PressureSquaredMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PressureSquaredMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PressureSquaredMeasure


class PressureSquaredMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressureSquaredMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressureSquaredMeasureExt.subclass:
            return PressureSquaredMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PressureSquaredMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PressureSquaredMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PressureSquaredMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PressureSquaredMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PressureSquaredMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PressureSquaredMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PressureSquaredMeasureExt


class PressureSquaredPerForceTimePerAreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressureSquaredPerForceTimePerAreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressureSquaredPerForceTimePerAreaMeasure.subclass:
            return PressureSquaredPerForceTimePerAreaMeasure.subclass(*args_, **kwargs_)
        else:
            return PressureSquaredPerForceTimePerAreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PressureSquaredPerForceTimePerAreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PressureSquaredPerForceTimePerAreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PressureSquaredPerForceTimePerAreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PressureSquaredPerForceTimePerAreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PressureSquaredPerForceTimePerAreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PressureSquaredPerForceTimePerAreaMeasure


class PressureSquaredPerForceTimePerAreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressureSquaredPerForceTimePerAreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressureSquaredPerForceTimePerAreaMeasureExt.subclass:
            return PressureSquaredPerForceTimePerAreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PressureSquaredPerForceTimePerAreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PressureSquaredPerForceTimePerAreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PressureSquaredPerForceTimePerAreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PressureSquaredPerForceTimePerAreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PressureSquaredPerForceTimePerAreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PressureSquaredPerForceTimePerAreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PressureSquaredPerForceTimePerAreaMeasureExt


class PressureTimePerVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressureTimePerVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressureTimePerVolumeMeasure.subclass:
            return PressureTimePerVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return PressureTimePerVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PressureTimePerVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PressureTimePerVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PressureTimePerVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PressureTimePerVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PressureTimePerVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PressureTimePerVolumeMeasure


class PressureTimePerVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressureTimePerVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressureTimePerVolumeMeasureExt.subclass:
            return PressureTimePerVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return PressureTimePerVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PressureTimePerVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PressureTimePerVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PressureTimePerVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PressureTimePerVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PressureTimePerVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PressureTimePerVolumeMeasureExt


class QuantityOfLightMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuantityOfLightMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuantityOfLightMeasure.subclass:
            return QuantityOfLightMeasure.subclass(*args_, **kwargs_)
        else:
            return QuantityOfLightMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='QuantityOfLightMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuantityOfLightMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='QuantityOfLightMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='QuantityOfLightMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='QuantityOfLightMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QuantityOfLightMeasure


class QuantityOfLightMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuantityOfLightMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuantityOfLightMeasureExt.subclass:
            return QuantityOfLightMeasureExt.subclass(*args_, **kwargs_)
        else:
            return QuantityOfLightMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='QuantityOfLightMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuantityOfLightMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='QuantityOfLightMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='QuantityOfLightMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='QuantityOfLightMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QuantityOfLightMeasureExt


class RadianceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadianceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadianceMeasure.subclass:
            return RadianceMeasure.subclass(*args_, **kwargs_)
        else:
            return RadianceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='RadianceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadianceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='RadianceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='RadianceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='RadianceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RadianceMeasure


class RadianceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadianceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadianceMeasureExt.subclass:
            return RadianceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return RadianceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='RadianceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadianceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='RadianceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='RadianceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='RadianceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RadianceMeasureExt


class RadiantIntensityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadiantIntensityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadiantIntensityMeasure.subclass:
            return RadiantIntensityMeasure.subclass(*args_, **kwargs_)
        else:
            return RadiantIntensityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='RadiantIntensityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadiantIntensityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='RadiantIntensityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='RadiantIntensityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='RadiantIntensityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RadiantIntensityMeasure


class RadiantIntensityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadiantIntensityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadiantIntensityMeasureExt.subclass:
            return RadiantIntensityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return RadiantIntensityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='RadiantIntensityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadiantIntensityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='RadiantIntensityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='RadiantIntensityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='RadiantIntensityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RadiantIntensityMeasureExt


class ReciprocalAreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalAreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalAreaMeasure.subclass:
            return ReciprocalAreaMeasure.subclass(*args_, **kwargs_)
        else:
            return ReciprocalAreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalAreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalAreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalAreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalAreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalAreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalAreaMeasure


class ReciprocalAreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalAreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalAreaMeasureExt.subclass:
            return ReciprocalAreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ReciprocalAreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalAreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalAreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalAreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalAreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalAreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalAreaMeasureExt


class ReciprocalElectricPotentialDifferenceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalElectricPotentialDifferenceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalElectricPotentialDifferenceMeasure.subclass:
            return ReciprocalElectricPotentialDifferenceMeasure.subclass(*args_, **kwargs_)
        else:
            return ReciprocalElectricPotentialDifferenceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalElectricPotentialDifferenceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalElectricPotentialDifferenceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalElectricPotentialDifferenceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalElectricPotentialDifferenceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalElectricPotentialDifferenceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalElectricPotentialDifferenceMeasure


class ReciprocalElectricPotentialDifferenceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalElectricPotentialDifferenceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalElectricPotentialDifferenceMeasureExt.subclass:
            return ReciprocalElectricPotentialDifferenceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ReciprocalElectricPotentialDifferenceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalElectricPotentialDifferenceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalElectricPotentialDifferenceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalElectricPotentialDifferenceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalElectricPotentialDifferenceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalElectricPotentialDifferenceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalElectricPotentialDifferenceMeasureExt


class ReciprocalForceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalForceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalForceMeasure.subclass:
            return ReciprocalForceMeasure.subclass(*args_, **kwargs_)
        else:
            return ReciprocalForceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalForceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalForceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalForceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalForceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalForceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalForceMeasure


class ReciprocalForceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalForceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalForceMeasureExt.subclass:
            return ReciprocalForceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ReciprocalForceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalForceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalForceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalForceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalForceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalForceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalForceMeasureExt


class ReciprocalLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalLengthMeasure.subclass:
            return ReciprocalLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return ReciprocalLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalLengthMeasure


class ReciprocalLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalLengthMeasureExt.subclass:
            return ReciprocalLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ReciprocalLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalLengthMeasureExt


class ReciprocalMassMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalMassMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalMassMeasure.subclass:
            return ReciprocalMassMeasure.subclass(*args_, **kwargs_)
        else:
            return ReciprocalMassMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalMassMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalMassMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalMassMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalMassMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalMassMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalMassMeasure


class ReciprocalMassMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalMassMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalMassMeasureExt.subclass:
            return ReciprocalMassMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ReciprocalMassMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalMassMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalMassMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalMassMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalMassMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalMassMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalMassMeasureExt


class ReciprocalMassTimeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalMassTimeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalMassTimeMeasure.subclass:
            return ReciprocalMassTimeMeasure.subclass(*args_, **kwargs_)
        else:
            return ReciprocalMassTimeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalMassTimeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalMassTimeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalMassTimeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalMassTimeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalMassTimeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalMassTimeMeasure


class ReciprocalMassTimeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalMassTimeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalMassTimeMeasureExt.subclass:
            return ReciprocalMassTimeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ReciprocalMassTimeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalMassTimeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalMassTimeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalMassTimeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalMassTimeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalMassTimeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalMassTimeMeasureExt


class ReciprocalPressureMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalPressureMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalPressureMeasure.subclass:
            return ReciprocalPressureMeasure.subclass(*args_, **kwargs_)
        else:
            return ReciprocalPressureMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalPressureMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalPressureMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalPressureMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalPressureMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalPressureMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalPressureMeasure


class ReciprocalPressureMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalPressureMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalPressureMeasureExt.subclass:
            return ReciprocalPressureMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ReciprocalPressureMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalPressureMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalPressureMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalPressureMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalPressureMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalPressureMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalPressureMeasureExt


class ReciprocalTimeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalTimeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalTimeMeasure.subclass:
            return ReciprocalTimeMeasure.subclass(*args_, **kwargs_)
        else:
            return ReciprocalTimeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalTimeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalTimeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalTimeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalTimeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalTimeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalTimeMeasure


class ReciprocalTimeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalTimeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalTimeMeasureExt.subclass:
            return ReciprocalTimeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ReciprocalTimeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalTimeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalTimeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalTimeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalTimeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalTimeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalTimeMeasureExt


class ReciprocalVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalVolumeMeasure.subclass:
            return ReciprocalVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return ReciprocalVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalVolumeMeasure


class ReciprocalVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReciprocalVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReciprocalVolumeMeasureExt.subclass:
            return ReciprocalVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ReciprocalVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReciprocalVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReciprocalVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReciprocalVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReciprocalVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReciprocalVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReciprocalVolumeMeasureExt


class ReluctanceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReluctanceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReluctanceMeasure.subclass:
            return ReluctanceMeasure.subclass(*args_, **kwargs_)
        else:
            return ReluctanceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReluctanceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReluctanceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReluctanceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReluctanceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReluctanceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReluctanceMeasure


class ReluctanceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReluctanceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReluctanceMeasureExt.subclass:
            return ReluctanceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ReluctanceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReluctanceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReluctanceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReluctanceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReluctanceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReluctanceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReluctanceMeasureExt


class SecondMomentOfAreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SecondMomentOfAreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SecondMomentOfAreaMeasure.subclass:
            return SecondMomentOfAreaMeasure.subclass(*args_, **kwargs_)
        else:
            return SecondMomentOfAreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='SecondMomentOfAreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SecondMomentOfAreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='SecondMomentOfAreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='SecondMomentOfAreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='SecondMomentOfAreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SecondMomentOfAreaMeasure


class SecondMomentOfAreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SecondMomentOfAreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SecondMomentOfAreaMeasureExt.subclass:
            return SecondMomentOfAreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return SecondMomentOfAreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='SecondMomentOfAreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SecondMomentOfAreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='SecondMomentOfAreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='SecondMomentOfAreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='SecondMomentOfAreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SecondMomentOfAreaMeasureExt


class SignalingEventPerTimeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignalingEventPerTimeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignalingEventPerTimeMeasure.subclass:
            return SignalingEventPerTimeMeasure.subclass(*args_, **kwargs_)
        else:
            return SignalingEventPerTimeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='SignalingEventPerTimeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignalingEventPerTimeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='SignalingEventPerTimeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='SignalingEventPerTimeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='SignalingEventPerTimeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignalingEventPerTimeMeasure


class SignalingEventPerTimeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignalingEventPerTimeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignalingEventPerTimeMeasureExt.subclass:
            return SignalingEventPerTimeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return SignalingEventPerTimeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='SignalingEventPerTimeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignalingEventPerTimeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='SignalingEventPerTimeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='SignalingEventPerTimeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='SignalingEventPerTimeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignalingEventPerTimeMeasureExt


class SolidAngleMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SolidAngleMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SolidAngleMeasure.subclass:
            return SolidAngleMeasure.subclass(*args_, **kwargs_)
        else:
            return SolidAngleMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='SolidAngleMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SolidAngleMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='SolidAngleMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='SolidAngleMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='SolidAngleMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SolidAngleMeasure


class SolidAngleMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SolidAngleMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SolidAngleMeasureExt.subclass:
            return SolidAngleMeasureExt.subclass(*args_, **kwargs_)
        else:
            return SolidAngleMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='SolidAngleMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SolidAngleMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='SolidAngleMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='SolidAngleMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='SolidAngleMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SolidAngleMeasureExt


class SpecificHeatCapacityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpecificHeatCapacityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpecificHeatCapacityMeasure.subclass:
            return SpecificHeatCapacityMeasure.subclass(*args_, **kwargs_)
        else:
            return SpecificHeatCapacityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='SpecificHeatCapacityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpecificHeatCapacityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='SpecificHeatCapacityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='SpecificHeatCapacityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='SpecificHeatCapacityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SpecificHeatCapacityMeasure


class SpecificHeatCapacityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpecificHeatCapacityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpecificHeatCapacityMeasureExt.subclass:
            return SpecificHeatCapacityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return SpecificHeatCapacityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='SpecificHeatCapacityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpecificHeatCapacityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='SpecificHeatCapacityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='SpecificHeatCapacityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='SpecificHeatCapacityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SpecificHeatCapacityMeasureExt


class TemperatureIntervalMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemperatureIntervalMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemperatureIntervalMeasure.subclass:
            return TemperatureIntervalMeasure.subclass(*args_, **kwargs_)
        else:
            return TemperatureIntervalMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemperatureIntervalMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TemperatureIntervalMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TemperatureIntervalMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TemperatureIntervalMeasure


class TemperatureIntervalMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemperatureIntervalMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemperatureIntervalMeasureExt.subclass:
            return TemperatureIntervalMeasureExt.subclass(*args_, **kwargs_)
        else:
            return TemperatureIntervalMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemperatureIntervalMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TemperatureIntervalMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TemperatureIntervalMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TemperatureIntervalMeasureExt


class TemperatureIntervalPerLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemperatureIntervalPerLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemperatureIntervalPerLengthMeasure.subclass:
            return TemperatureIntervalPerLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return TemperatureIntervalPerLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalPerLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemperatureIntervalPerLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TemperatureIntervalPerLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TemperatureIntervalPerLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalPerLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TemperatureIntervalPerLengthMeasure


class TemperatureIntervalPerLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemperatureIntervalPerLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemperatureIntervalPerLengthMeasureExt.subclass:
            return TemperatureIntervalPerLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return TemperatureIntervalPerLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalPerLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemperatureIntervalPerLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TemperatureIntervalPerLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TemperatureIntervalPerLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalPerLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TemperatureIntervalPerLengthMeasureExt


class TemperatureIntervalPerPressureMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemperatureIntervalPerPressureMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemperatureIntervalPerPressureMeasure.subclass:
            return TemperatureIntervalPerPressureMeasure.subclass(*args_, **kwargs_)
        else:
            return TemperatureIntervalPerPressureMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalPerPressureMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemperatureIntervalPerPressureMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TemperatureIntervalPerPressureMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TemperatureIntervalPerPressureMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalPerPressureMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TemperatureIntervalPerPressureMeasure


class TemperatureIntervalPerPressureMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemperatureIntervalPerPressureMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemperatureIntervalPerPressureMeasureExt.subclass:
            return TemperatureIntervalPerPressureMeasureExt.subclass(*args_, **kwargs_)
        else:
            return TemperatureIntervalPerPressureMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalPerPressureMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemperatureIntervalPerPressureMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TemperatureIntervalPerPressureMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TemperatureIntervalPerPressureMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalPerPressureMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TemperatureIntervalPerPressureMeasureExt


class TemperatureIntervalPerTimeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemperatureIntervalPerTimeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemperatureIntervalPerTimeMeasure.subclass:
            return TemperatureIntervalPerTimeMeasure.subclass(*args_, **kwargs_)
        else:
            return TemperatureIntervalPerTimeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalPerTimeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemperatureIntervalPerTimeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TemperatureIntervalPerTimeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TemperatureIntervalPerTimeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalPerTimeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TemperatureIntervalPerTimeMeasure


class TemperatureIntervalPerTimeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemperatureIntervalPerTimeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemperatureIntervalPerTimeMeasureExt.subclass:
            return TemperatureIntervalPerTimeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return TemperatureIntervalPerTimeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalPerTimeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemperatureIntervalPerTimeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TemperatureIntervalPerTimeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TemperatureIntervalPerTimeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TemperatureIntervalPerTimeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TemperatureIntervalPerTimeMeasureExt


class ThermalConductanceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermalConductanceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermalConductanceMeasure.subclass:
            return ThermalConductanceMeasure.subclass(*args_, **kwargs_)
        else:
            return ThermalConductanceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ThermalConductanceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermalConductanceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ThermalConductanceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ThermalConductanceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ThermalConductanceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermalConductanceMeasure


class ThermalConductanceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermalConductanceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermalConductanceMeasureExt.subclass:
            return ThermalConductanceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ThermalConductanceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ThermalConductanceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermalConductanceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ThermalConductanceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ThermalConductanceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ThermalConductanceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermalConductanceMeasureExt


class ThermalConductivityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermalConductivityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermalConductivityMeasure.subclass:
            return ThermalConductivityMeasure.subclass(*args_, **kwargs_)
        else:
            return ThermalConductivityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ThermalConductivityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermalConductivityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ThermalConductivityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ThermalConductivityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ThermalConductivityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermalConductivityMeasure


class ThermalConductivityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermalConductivityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermalConductivityMeasureExt.subclass:
            return ThermalConductivityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ThermalConductivityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ThermalConductivityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermalConductivityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ThermalConductivityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ThermalConductivityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ThermalConductivityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermalConductivityMeasureExt


class ThermalDiffusivityMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermalDiffusivityMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermalDiffusivityMeasure.subclass:
            return ThermalDiffusivityMeasure.subclass(*args_, **kwargs_)
        else:
            return ThermalDiffusivityMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ThermalDiffusivityMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermalDiffusivityMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ThermalDiffusivityMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ThermalDiffusivityMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ThermalDiffusivityMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermalDiffusivityMeasure


class ThermalDiffusivityMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermalDiffusivityMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermalDiffusivityMeasureExt.subclass:
            return ThermalDiffusivityMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ThermalDiffusivityMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ThermalDiffusivityMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermalDiffusivityMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ThermalDiffusivityMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ThermalDiffusivityMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ThermalDiffusivityMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermalDiffusivityMeasureExt


class ThermalInsulanceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermalInsulanceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermalInsulanceMeasure.subclass:
            return ThermalInsulanceMeasure.subclass(*args_, **kwargs_)
        else:
            return ThermalInsulanceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ThermalInsulanceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermalInsulanceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ThermalInsulanceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ThermalInsulanceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ThermalInsulanceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermalInsulanceMeasure


class ThermalInsulanceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermalInsulanceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermalInsulanceMeasureExt.subclass:
            return ThermalInsulanceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ThermalInsulanceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ThermalInsulanceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermalInsulanceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ThermalInsulanceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ThermalInsulanceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ThermalInsulanceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermalInsulanceMeasureExt


class ThermalResistanceMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermalResistanceMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermalResistanceMeasure.subclass:
            return ThermalResistanceMeasure.subclass(*args_, **kwargs_)
        else:
            return ThermalResistanceMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ThermalResistanceMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermalResistanceMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ThermalResistanceMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ThermalResistanceMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ThermalResistanceMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermalResistanceMeasure


class ThermalResistanceMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermalResistanceMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermalResistanceMeasureExt.subclass:
            return ThermalResistanceMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ThermalResistanceMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ThermalResistanceMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermalResistanceMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ThermalResistanceMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ThermalResistanceMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ThermalResistanceMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermalResistanceMeasureExt


class ThermodynamicTemperatureMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermodynamicTemperatureMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermodynamicTemperatureMeasure.subclass:
            return ThermodynamicTemperatureMeasure.subclass(*args_, **kwargs_)
        else:
            return ThermodynamicTemperatureMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ThermodynamicTemperatureMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermodynamicTemperatureMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ThermodynamicTemperatureMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ThermodynamicTemperatureMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ThermodynamicTemperatureMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermodynamicTemperatureMeasure


class ThermodynamicTemperatureMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermodynamicTemperatureMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermodynamicTemperatureMeasureExt.subclass:
            return ThermodynamicTemperatureMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ThermodynamicTemperatureMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ThermodynamicTemperatureMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermodynamicTemperatureMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ThermodynamicTemperatureMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ThermodynamicTemperatureMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ThermodynamicTemperatureMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermodynamicTemperatureMeasureExt


class ThermodynamicTemperaturePerThermodynamicTemperatureMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermodynamicTemperaturePerThermodynamicTemperatureMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermodynamicTemperaturePerThermodynamicTemperatureMeasure.subclass:
            return ThermodynamicTemperaturePerThermodynamicTemperatureMeasure.subclass(*args_, **kwargs_)
        else:
            return ThermodynamicTemperaturePerThermodynamicTemperatureMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ThermodynamicTemperaturePerThermodynamicTemperatureMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermodynamicTemperaturePerThermodynamicTemperatureMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ThermodynamicTemperaturePerThermodynamicTemperatureMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ThermodynamicTemperaturePerThermodynamicTemperatureMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ThermodynamicTemperaturePerThermodynamicTemperatureMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermodynamicTemperaturePerThermodynamicTemperatureMeasure


class ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt.subclass:
            return ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt.subclass(*args_, **kwargs_)
        else:
            return ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt


class TimeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeMeasure.subclass:
            return TimeMeasure.subclass(*args_, **kwargs_)
        else:
            return TimeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimeMeasure


class TimeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeMeasureExt.subclass:
            return TimeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return TimeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimeMeasureExt


class TimePerLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimePerLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimePerLengthMeasure.subclass:
            return TimePerLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return TimePerLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimePerLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimePerLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimePerLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimePerLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimePerLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimePerLengthMeasure


class TimePerLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimePerLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimePerLengthMeasureExt.subclass:
            return TimePerLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return TimePerLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimePerLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimePerLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimePerLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimePerLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimePerLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimePerLengthMeasureExt


class TimePerMassMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimePerMassMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimePerMassMeasure.subclass:
            return TimePerMassMeasure.subclass(*args_, **kwargs_)
        else:
            return TimePerMassMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimePerMassMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimePerMassMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimePerMassMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimePerMassMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimePerMassMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimePerMassMeasure


class TimePerMassMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimePerMassMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimePerMassMeasureExt.subclass:
            return TimePerMassMeasureExt.subclass(*args_, **kwargs_)
        else:
            return TimePerMassMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimePerMassMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimePerMassMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimePerMassMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimePerMassMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimePerMassMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimePerMassMeasureExt


class TimePerTimeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimePerTimeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimePerTimeMeasure.subclass:
            return TimePerTimeMeasure.subclass(*args_, **kwargs_)
        else:
            return TimePerTimeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimePerTimeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimePerTimeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimePerTimeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimePerTimeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimePerTimeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimePerTimeMeasure


class TimePerTimeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimePerTimeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimePerTimeMeasureExt.subclass:
            return TimePerTimeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return TimePerTimeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimePerTimeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimePerTimeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimePerTimeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimePerTimeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimePerTimeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimePerTimeMeasureExt


class TimePerVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimePerVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimePerVolumeMeasure.subclass:
            return TimePerVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return TimePerVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimePerVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimePerVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimePerVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimePerVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimePerVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimePerVolumeMeasure


class TimePerVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimePerVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimePerVolumeMeasureExt.subclass:
            return TimePerVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return TimePerVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimePerVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimePerVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimePerVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimePerVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimePerVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimePerVolumeMeasureExt


class UnitlessMeasure(GeneratedsSuper):
    """A unitless measure is a measure which has no unit of measure symbol,
    but could be a real physical measurement. Examples would be pH,
    wire gauge (AWG and BWG) and shoe size. This is different from a
    dimensionless measure which represents a ratio whose units of
    measure have cancelled each other. DImensionless measures can
    have units of measure (like ppm or %) or may not have a
    displayable unit of measure symbol (in which case the units
    symbol Euc is used in a data transfer)."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitlessMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitlessMeasure.subclass:
            return UnitlessMeasure.subclass(*args_, **kwargs_)
        else:
            return UnitlessMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='UnitlessMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnitlessMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='UnitlessMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='UnitlessMeasure'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='UnitlessMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UnitlessMeasure


class VerticalCoordinateMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalCoordinateMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalCoordinateMeasure.subclass:
            return VerticalCoordinateMeasure.subclass(*args_, **kwargs_)
        else:
            return VerticalCoordinateMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VerticalCoordinateMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalCoordinateMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VerticalCoordinateMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VerticalCoordinateMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VerticalCoordinateMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VerticalCoordinateMeasure


class VerticalCoordinateMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalCoordinateMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalCoordinateMeasureExt.subclass:
            return VerticalCoordinateMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VerticalCoordinateMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VerticalCoordinateMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalCoordinateMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VerticalCoordinateMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VerticalCoordinateMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VerticalCoordinateMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VerticalCoordinateMeasureExt


class VolumeFlowRatePerVolumeFlowRateMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumeFlowRatePerVolumeFlowRateMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumeFlowRatePerVolumeFlowRateMeasure.subclass:
            return VolumeFlowRatePerVolumeFlowRateMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumeFlowRatePerVolumeFlowRateMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumeFlowRatePerVolumeFlowRateMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumeFlowRatePerVolumeFlowRateMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumeFlowRatePerVolumeFlowRateMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumeFlowRatePerVolumeFlowRateMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumeFlowRatePerVolumeFlowRateMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumeFlowRatePerVolumeFlowRateMeasure


class VolumeFlowRatePerVolumeFlowRateMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumeFlowRatePerVolumeFlowRateMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumeFlowRatePerVolumeFlowRateMeasureExt.subclass:
            return VolumeFlowRatePerVolumeFlowRateMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumeFlowRatePerVolumeFlowRateMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumeFlowRatePerVolumeFlowRateMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumeFlowRatePerVolumeFlowRateMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumeFlowRatePerVolumeFlowRateMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumeFlowRatePerVolumeFlowRateMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumeFlowRatePerVolumeFlowRateMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumeFlowRatePerVolumeFlowRateMeasureExt


class VolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumeMeasure.subclass:
            return VolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumeMeasure


class VolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumeMeasureExt.subclass:
            return VolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumeMeasureExt


class VolumePerAreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerAreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerAreaMeasure.subclass:
            return VolumePerAreaMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumePerAreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerAreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerAreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerAreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerAreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerAreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerAreaMeasure


class VolumePerAreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerAreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerAreaMeasureExt.subclass:
            return VolumePerAreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumePerAreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerAreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerAreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerAreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerAreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerAreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerAreaMeasureExt


class VolumePerLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerLengthMeasure.subclass:
            return VolumePerLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumePerLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerLengthMeasure


class VolumePerLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerLengthMeasureExt.subclass:
            return VolumePerLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumePerLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerLengthMeasureExt


class VolumePerMassMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerMassMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerMassMeasure.subclass:
            return VolumePerMassMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumePerMassMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerMassMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerMassMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerMassMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerMassMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerMassMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerMassMeasure


class VolumePerMassMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerMassMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerMassMeasureExt.subclass:
            return VolumePerMassMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumePerMassMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerMassMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerMassMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerMassMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerMassMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerMassMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerMassMeasureExt


class VolumePerPressureMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerPressureMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerPressureMeasure.subclass:
            return VolumePerPressureMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumePerPressureMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerPressureMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerPressureMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerPressureMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerPressureMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerPressureMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerPressureMeasure


class VolumePerPressureMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerPressureMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerPressureMeasureExt.subclass:
            return VolumePerPressureMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumePerPressureMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerPressureMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerPressureMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerPressureMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerPressureMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerPressureMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerPressureMeasureExt


class VolumePerRotationMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerRotationMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerRotationMeasure.subclass:
            return VolumePerRotationMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumePerRotationMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerRotationMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerRotationMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerRotationMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerRotationMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerRotationMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerRotationMeasure


class VolumePerRotationMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerRotationMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerRotationMeasureExt.subclass:
            return VolumePerRotationMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumePerRotationMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerRotationMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerRotationMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerRotationMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerRotationMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerRotationMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerRotationMeasureExt


class VolumePerTimeLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimeLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimeLengthMeasure.subclass:
            return VolumePerTimeLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimeLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimeLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimeLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimeLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimeLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimeLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimeLengthMeasure


class VolumePerTimeLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimeLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimeLengthMeasureExt.subclass:
            return VolumePerTimeLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimeLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimeLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimeLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimeLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimeLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimeLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimeLengthMeasureExt


class VolumePerTimeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimeMeasure.subclass:
            return VolumePerTimeMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimeMeasure


class VolumePerTimeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimeMeasureExt.subclass:
            return VolumePerTimeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimeMeasureExt


class VolumePerTimePerAreaMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimePerAreaMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimePerAreaMeasure.subclass:
            return VolumePerTimePerAreaMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimePerAreaMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerAreaMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimePerAreaMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimePerAreaMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimePerAreaMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerAreaMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimePerAreaMeasure


class VolumePerTimePerAreaMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimePerAreaMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimePerAreaMeasureExt.subclass:
            return VolumePerTimePerAreaMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimePerAreaMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerAreaMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimePerAreaMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimePerAreaMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimePerAreaMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerAreaMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimePerAreaMeasureExt


class VolumePerTimePerLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimePerLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimePerLengthMeasure.subclass:
            return VolumePerTimePerLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimePerLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimePerLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimePerLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimePerLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimePerLengthMeasure


class VolumePerTimePerLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimePerLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimePerLengthMeasureExt.subclass:
            return VolumePerTimePerLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimePerLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimePerLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimePerLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimePerLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimePerLengthMeasureExt


class VolumePerTimePerPressureLengthMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimePerPressureLengthMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimePerPressureLengthMeasure.subclass:
            return VolumePerTimePerPressureLengthMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimePerPressureLengthMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerPressureLengthMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimePerPressureLengthMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimePerPressureLengthMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimePerPressureLengthMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerPressureLengthMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimePerPressureLengthMeasure


class VolumePerTimePerPressureLengthMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimePerPressureLengthMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimePerPressureLengthMeasureExt.subclass:
            return VolumePerTimePerPressureLengthMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimePerPressureLengthMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerPressureLengthMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimePerPressureLengthMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimePerPressureLengthMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimePerPressureLengthMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerPressureLengthMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimePerPressureLengthMeasureExt


class VolumePerTimePerPressureMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimePerPressureMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimePerPressureMeasure.subclass:
            return VolumePerTimePerPressureMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimePerPressureMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerPressureMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimePerPressureMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimePerPressureMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimePerPressureMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerPressureMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimePerPressureMeasure


class VolumePerTimePerPressureMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimePerPressureMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimePerPressureMeasureExt.subclass:
            return VolumePerTimePerPressureMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimePerPressureMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerPressureMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimePerPressureMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimePerPressureMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimePerPressureMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerPressureMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimePerPressureMeasureExt


class VolumePerTimePerTimeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimePerTimeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimePerTimeMeasure.subclass:
            return VolumePerTimePerTimeMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimePerTimeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerTimeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimePerTimeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimePerTimeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimePerTimeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerTimeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimePerTimeMeasure


class VolumePerTimePerTimeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimePerTimeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimePerTimeMeasureExt.subclass:
            return VolumePerTimePerTimeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimePerTimeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerTimeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimePerTimeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimePerTimeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimePerTimeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerTimeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimePerTimeMeasureExt


class VolumePerTimePerVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimePerVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimePerVolumeMeasure.subclass:
            return VolumePerTimePerVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimePerVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimePerVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimePerVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimePerVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimePerVolumeMeasure


class VolumePerTimePerVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerTimePerVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerTimePerVolumeMeasureExt.subclass:
            return VolumePerTimePerVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumePerTimePerVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerTimePerVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerTimePerVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerTimePerVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerTimePerVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerTimePerVolumeMeasureExt


class VolumePerVolumeMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerVolumeMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerVolumeMeasure.subclass:
            return VolumePerVolumeMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumePerVolumeMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerVolumeMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerVolumeMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerVolumeMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerVolumeMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerVolumeMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerVolumeMeasure


class VolumePerVolumeMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumePerVolumeMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumePerVolumeMeasureExt.subclass:
            return VolumePerVolumeMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumePerVolumeMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumePerVolumeMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumePerVolumeMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumePerVolumeMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumePerVolumeMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumePerVolumeMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumePerVolumeMeasureExt


class VolumetricHeatTransferCoefficientMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumetricHeatTransferCoefficientMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumetricHeatTransferCoefficientMeasure.subclass:
            return VolumetricHeatTransferCoefficientMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumetricHeatTransferCoefficientMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumetricHeatTransferCoefficientMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumetricHeatTransferCoefficientMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumetricHeatTransferCoefficientMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumetricHeatTransferCoefficientMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumetricHeatTransferCoefficientMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumetricHeatTransferCoefficientMeasure


class VolumetricHeatTransferCoefficientMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumetricHeatTransferCoefficientMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumetricHeatTransferCoefficientMeasureExt.subclass:
            return VolumetricHeatTransferCoefficientMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumetricHeatTransferCoefficientMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumetricHeatTransferCoefficientMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumetricHeatTransferCoefficientMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumetricHeatTransferCoefficientMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumetricHeatTransferCoefficientMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumetricHeatTransferCoefficientMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumetricHeatTransferCoefficientMeasureExt


class VolumetricThermalExpansionMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumetricThermalExpansionMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumetricThermalExpansionMeasure.subclass:
            return VolumetricThermalExpansionMeasure.subclass(*args_, **kwargs_)
        else:
            return VolumetricThermalExpansionMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumetricThermalExpansionMeasure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumetricThermalExpansionMeasure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumetricThermalExpansionMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumetricThermalExpansionMeasure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumetricThermalExpansionMeasure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumetricThermalExpansionMeasure


class VolumetricThermalExpansionMeasureExt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumetricThermalExpansionMeasureExt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumetricThermalExpansionMeasureExt.subclass:
            return VolumetricThermalExpansionMeasureExt.subclass(*args_, **kwargs_)
        else:
            return VolumetricThermalExpansionMeasureExt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumetricThermalExpansionMeasureExt', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumetricThermalExpansionMeasureExt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumetricThermalExpansionMeasureExt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumetricThermalExpansionMeasureExt'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumetricThermalExpansionMeasureExt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumetricThermalExpansionMeasureExt


class DefinitionBaseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.description = description
        self.descriptionReference = descriptionReference
        self.identifier = identifier
        if name is None:
            self.name = []
        else:
            self.name = name
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DefinitionBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DefinitionBaseType.subclass:
            return DefinitionBaseType.subclass(*args_, **kwargs_)
        else:
            return DefinitionBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_descriptionReference(self): return self.descriptionReference
    def set_descriptionReference(self, descriptionReference): self.descriptionReference = descriptionReference
    descriptionReferenceProp = property(get_descriptionReference, set_descriptionReference)
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    identifierProp = property(get_identifier, set_identifier)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name_at(self, index, value): self.name.insert(index, value)
    def replace_name_at(self, index, value): self.name[index] = value
    nameProp = property(get_name, set_name)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    idProp = property(get_id, set_id)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.description is not None or
            self.descriptionReference is not None or
            self.identifier is not None or
            self.name
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DefinitionBaseType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefinitionBaseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DefinitionBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DefinitionBaseType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DefinitionBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            self.description.export(outfile, level, namespace_='gml:', name_='description', pretty_print=pretty_print)
        if self.descriptionReference is not None:
            self.descriptionReference.export(outfile, level, namespace_='gml:', name_='descriptionReference', pretty_print=pretty_print)
        if self.identifier is not None:
            self.identifier.export(outfile, level, namespace_='gml:', name_='identifier', pretty_print=pretty_print)
        for name_ in self.name:
            name_.export(outfile, level, namespace_='gml:', name_='name', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'descriptionReference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.descriptionReference = obj_
            obj_.original_tagname_ = 'descriptionReference'
        elif nodeName_ == 'identifier':
            obj_ = CodeWithAuthorityType.factory()
            obj_.build(child_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
# end class DefinitionBaseType


class AbstractGMLType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.description = description
        self.descriptionReference = descriptionReference
        self.identifier = identifier
        if name is None:
            self.name = []
        else:
            self.name = name
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractGMLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractGMLType.subclass:
            return AbstractGMLType.subclass(*args_, **kwargs_)
        else:
            return AbstractGMLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_descriptionReference(self): return self.descriptionReference
    def set_descriptionReference(self, descriptionReference): self.descriptionReference = descriptionReference
    descriptionReferenceProp = property(get_descriptionReference, set_descriptionReference)
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    identifierProp = property(get_identifier, set_identifier)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name_at(self, index, value): self.name.insert(index, value)
    def replace_name_at(self, index, value): self.name[index] = value
    nameProp = property(get_name, set_name)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    idProp = property(get_id, set_id)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.description is not None or
            self.descriptionReference is not None or
            self.identifier is not None or
            self.name
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractGMLType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGMLType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractGMLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractGMLType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractGMLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            self.description.export(outfile, level, namespace_='gml:', name_='description', pretty_print=pretty_print)
        if self.descriptionReference is not None:
            self.descriptionReference.export(outfile, level, namespace_='gml:', name_='descriptionReference', pretty_print=pretty_print)
        if self.identifier is not None:
            self.identifier.export(outfile, level, namespace_='gml:', name_='identifier', pretty_print=pretty_print)
        for name_ in self.name:
            name_.export(outfile, level, namespace_='gml:', name_='name', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'descriptionReference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.descriptionReference = obj_
            obj_.original_tagname_ = 'descriptionReference'
        elif nodeName_ == 'identifier':
            obj_ = CodeWithAuthorityType.factory()
            obj_.build(child_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
# end class AbstractGMLType


class StringOrRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, valueOf_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringOrRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringOrRefType.subclass:
            return StringOrRefType.subclass(*args_, **kwargs_)
        else:
            return StringOrRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='StringOrRefType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StringOrRefType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='StringOrRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='StringOrRefType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='StringOrRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StringOrRefType


class ReferenceType(GeneratedsSuper):
    """gml:ReferenceType is intended to be used in application schemas
    directly, if a property element shall use a "by-reference only"
    encoding."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None):
        self.original_tagname_ = None
        self.owns = _cast(None, owns)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    ownsProp = property(get_owns, set_owns)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReferenceType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReferenceType'):
        if self.owns != "false" and 'owns' not in already_processed:
            already_processed.add('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.add('owns')
            self.owns = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReferenceType


class CodeType(GeneratedsSuper):
    """gml:CodeType is a generalized type to be used for a term, keyword or
    name. It adds a XML attribute codeSpace to a term, where the
    value of the codeSpace attribute (if present) shall indicate a
    dictionary, thesaurus, classification scheme, authority, or
    pattern for the term."""
    subclass = None
    superclass = None
    def __init__(self, codeSpace=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.codeSpace = _cast(None, codeSpace)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeType.subclass:
            return CodeType.subclass(*args_, **kwargs_)
        else:
            return CodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeSpace(self): return self.codeSpace
    def set_codeSpace(self, codeSpace): self.codeSpace = codeSpace
    codeSpaceProp = property(get_codeSpace, set_codeSpace)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CodeType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CodeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CodeType'):
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.add('codeSpace')
            outfile.write(' codeSpace=%s' % (quote_attrib(self.codeSpace), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CodeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeSpace', node)
        if value is not None and 'codeSpace' not in already_processed:
            already_processed.add('codeSpace')
            self.codeSpace = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CodeType


class domainOfValidity(GeneratedsSuper):
    """The gml:domainOfValidity property implements an association role to
    an EX_Extent object as encoded in ISO/TS 19139, either
    referencing or containing the definition of that extent."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, EX_Extent=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.EX_Extent = EX_Extent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, domainOfValidity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if domainOfValidity.subclass:
            return domainOfValidity.subclass(*args_, **kwargs_)
        else:
            return domainOfValidity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EX_Extent(self): return self.EX_Extent
    def set_EX_Extent(self, EX_Extent): self.EX_Extent = EX_Extent
    EX_ExtentProp = property(get_EX_Extent, set_EX_Extent)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.EX_Extent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='domainOfValidity', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='domainOfValidity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='domainOfValidity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='domainOfValidity'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='domainOfValidity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EX_Extent is not None:
            self.EX_Extent.export(outfile, level, namespace_='gmd:', name_='EX_Extent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EX_Extent':
            obj_ = EX_Extent_Type.factory()
            obj_.build(child_)
            self.EX_Extent = obj_
            obj_.original_tagname_ = 'EX_Extent'
# end class domainOfValidity


class AbstractTimeObjectType(AbstractGMLType):
    subclass = None
    superclass = AbstractGMLType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, extensiontype_=None):
        self.original_tagname_ = None
        super(AbstractTimeObjectType, self).__init__(id, description, descriptionReference, identifier, name, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractTimeObjectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractTimeObjectType.subclass:
            return AbstractTimeObjectType.subclass(*args_, **kwargs_)
        else:
            return AbstractTimeObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(AbstractTimeObjectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractTimeObjectType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimeObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractTimeObjectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractTimeObjectType'):
        super(AbstractTimeObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimeObjectType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractTimeObjectType', fromsubclass_=False, pretty_print=True):
        super(AbstractTimeObjectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractTimeObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractTimeObjectType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractTimeObjectType


class TimePrimitivePropertyType(GeneratedsSuper):
    """gml:TimePrimitivePropertyType provides a standard content model for
    associations between an arbitrary member of the substitution
    group whose head is gml:AbstractTimePrimitive and another
    object."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, owns='false', AbstractTimePrimitive=None, extensiontype_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.owns = _cast(None, owns)
        self.AbstractTimePrimitive = AbstractTimePrimitive
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimePrimitivePropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimePrimitivePropertyType.subclass:
            return TimePrimitivePropertyType.subclass(*args_, **kwargs_)
        else:
            return TimePrimitivePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractTimePrimitive(self): return self.AbstractTimePrimitive
    def set_AbstractTimePrimitive(self, AbstractTimePrimitive): self.AbstractTimePrimitive = AbstractTimePrimitive
    AbstractTimePrimitiveProp = property(get_AbstractTimePrimitive, set_AbstractTimePrimitive)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    ownsProp = property(get_owns, set_owns)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.AbstractTimePrimitive is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimePrimitivePropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimePrimitivePropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimePrimitivePropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimePrimitivePropertyType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.owns != "false" and 'owns' not in already_processed:
            already_processed.add('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimePrimitivePropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AbstractTimePrimitive is not None:
            self.AbstractTimePrimitive.export(outfile, level, namespace_, name_='AbstractTimePrimitive', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.add('owns')
            self.owns = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractTimePrimitive':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractTimePrimitive> element')
            self.AbstractTimePrimitive = obj_
            obj_.original_tagname_ = 'AbstractTimePrimitive'
# end class TimePrimitivePropertyType


class EllipsoidalCSPropertyType(GeneratedsSuper):
    """gml:EllipsoidalCSPropertyType is a property type for association
    roles to an ellipsoidal coordinate system, either referencing or
    containing the definition of that coordinate system."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, EllipsoidalCS=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.EllipsoidalCS = EllipsoidalCS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EllipsoidalCSPropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EllipsoidalCSPropertyType.subclass:
            return EllipsoidalCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return EllipsoidalCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EllipsoidalCS(self): return self.EllipsoidalCS
    def set_EllipsoidalCS(self, EllipsoidalCS): self.EllipsoidalCS = EllipsoidalCS
    EllipsoidalCSProp = property(get_EllipsoidalCS, set_EllipsoidalCS)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.EllipsoidalCS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EllipsoidalCSPropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EllipsoidalCSPropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EllipsoidalCSPropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EllipsoidalCSPropertyType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EllipsoidalCSPropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EllipsoidalCS is not None:
            self.EllipsoidalCS.export(outfile, level, namespace_='gml:', name_='EllipsoidalCS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EllipsoidalCS':
            obj_ = EllipsoidalCSType.factory()
            obj_.build(child_)
            self.EllipsoidalCS = obj_
            obj_.original_tagname_ = 'EllipsoidalCS'
# end class EllipsoidalCSPropertyType


class CoordinateSystemAxisPropertyType(GeneratedsSuper):
    """gml:CoordinateSystemAxisPropertyType is a property type for
    association roles to a coordinate system axis, either
    referencing or containing the definition of that axis."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, CoordinateSystemAxis=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.CoordinateSystemAxis = CoordinateSystemAxis
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoordinateSystemAxisPropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordinateSystemAxisPropertyType.subclass:
            return CoordinateSystemAxisPropertyType.subclass(*args_, **kwargs_)
        else:
            return CoordinateSystemAxisPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CoordinateSystemAxis(self): return self.CoordinateSystemAxis
    def set_CoordinateSystemAxis(self, CoordinateSystemAxis): self.CoordinateSystemAxis = CoordinateSystemAxis
    CoordinateSystemAxisProp = property(get_CoordinateSystemAxis, set_CoordinateSystemAxis)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.CoordinateSystemAxis is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CoordinateSystemAxisPropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoordinateSystemAxisPropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CoordinateSystemAxisPropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CoordinateSystemAxisPropertyType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CoordinateSystemAxisPropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CoordinateSystemAxis is not None:
            self.CoordinateSystemAxis.export(outfile, level, namespace_='gml:', name_='CoordinateSystemAxis', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CoordinateSystemAxis':
            obj_ = CoordinateSystemAxisType.factory()
            obj_.build(child_)
            self.CoordinateSystemAxis = obj_
            obj_.original_tagname_ = 'CoordinateSystemAxis'
# end class CoordinateSystemAxisPropertyType


class CartesianCSPropertyType(GeneratedsSuper):
    """gml:CartesianCSPropertyType is a property type for association roles
    to a Cartesian coordinate system, either referencing or
    containing the definition of that coordinate system."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, CartesianCS=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.CartesianCS = CartesianCS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CartesianCSPropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CartesianCSPropertyType.subclass:
            return CartesianCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return CartesianCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CartesianCS(self): return self.CartesianCS
    def set_CartesianCS(self, CartesianCS): self.CartesianCS = CartesianCS
    CartesianCSProp = property(get_CartesianCS, set_CartesianCS)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.CartesianCS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CartesianCSPropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CartesianCSPropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CartesianCSPropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CartesianCSPropertyType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CartesianCSPropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CartesianCS is not None:
            self.CartesianCS.export(outfile, level, namespace_='gml:', name_='CartesianCS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CartesianCS':
            obj_ = CartesianCSType.factory()
            obj_.build(child_)
            self.CartesianCS = obj_
            obj_.original_tagname_ = 'CartesianCS'
# end class CartesianCSPropertyType


class SphericalCSPropertyType(GeneratedsSuper):
    """gml:SphericalCSPropertyType is property type for association roles
    to a spherical coordinate system, either referencing or
    containing the definition of that coordinate system."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, SphericalCS=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.SphericalCS = SphericalCS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SphericalCSPropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SphericalCSPropertyType.subclass:
            return SphericalCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return SphericalCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SphericalCS(self): return self.SphericalCS
    def set_SphericalCS(self, SphericalCS): self.SphericalCS = SphericalCS
    SphericalCSProp = property(get_SphericalCS, set_SphericalCS)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.SphericalCS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='SphericalCSPropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SphericalCSPropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='SphericalCSPropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='SphericalCSPropertyType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='SphericalCSPropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SphericalCS is not None:
            self.SphericalCS.export(outfile, level, namespace_='gml:', name_='SphericalCS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SphericalCS':
            obj_ = SphericalCSType.factory()
            obj_.build(child_)
            self.SphericalCS = obj_
            obj_.original_tagname_ = 'SphericalCS'
# end class SphericalCSPropertyType


class GeodeticDatumPropertyType(GeneratedsSuper):
    """gml:GeodeticDatumPropertyType is a property type for association
    roles to a geodetic datum, either referencing or containing the
    definition of that datum."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, GeodeticDatum=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.GeodeticDatum = GeodeticDatum
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeodeticDatumPropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeodeticDatumPropertyType.subclass:
            return GeodeticDatumPropertyType.subclass(*args_, **kwargs_)
        else:
            return GeodeticDatumPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GeodeticDatum(self): return self.GeodeticDatum
    def set_GeodeticDatum(self, GeodeticDatum): self.GeodeticDatum = GeodeticDatum
    GeodeticDatumProp = property(get_GeodeticDatum, set_GeodeticDatum)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.GeodeticDatum is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeodeticDatumPropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticDatumPropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeodeticDatumPropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeodeticDatumPropertyType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeodeticDatumPropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GeodeticDatum is not None:
            self.GeodeticDatum.export(outfile, level, namespace_='gml:', name_='GeodeticDatum', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GeodeticDatum':
            obj_ = GeodeticDatumType.factory()
            obj_.build(child_)
            self.GeodeticDatum = obj_
            obj_.original_tagname_ = 'GeodeticDatum'
# end class GeodeticDatumPropertyType


class PrimeMeridianPropertyType(GeneratedsSuper):
    """gml:PrimeMeridianPropertyType is a property type for association
    roles to a prime meridian, either referencing or containing the
    definition of that meridian."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, PrimeMeridian=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.PrimeMeridian = PrimeMeridian
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrimeMeridianPropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrimeMeridianPropertyType.subclass:
            return PrimeMeridianPropertyType.subclass(*args_, **kwargs_)
        else:
            return PrimeMeridianPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PrimeMeridian(self): return self.PrimeMeridian
    def set_PrimeMeridian(self, PrimeMeridian): self.PrimeMeridian = PrimeMeridian
    PrimeMeridianProp = property(get_PrimeMeridian, set_PrimeMeridian)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.PrimeMeridian is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PrimeMeridianPropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrimeMeridianPropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PrimeMeridianPropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PrimeMeridianPropertyType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PrimeMeridianPropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PrimeMeridian is not None:
            self.PrimeMeridian.export(outfile, level, namespace_='gml:', name_='PrimeMeridian', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PrimeMeridian':
            obj_ = PrimeMeridianType.factory()
            obj_.build(child_)
            self.PrimeMeridian = obj_
            obj_.original_tagname_ = 'PrimeMeridian'
# end class PrimeMeridianPropertyType


class MeasureType(GeneratedsSuper):
    """gml:MeasureType supports recording an amount encoded as a value of
    XML Schema double, together with a units of measure indicated by
    an attribute uom, short for "units Of measure". The value of the
    uom attribute identifies a reference system for the amount,
    usually a ratio or interval scale."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureType.subclass:
            return MeasureType.subclass(*args_, **kwargs_)
        else:
            return MeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MeasureType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MeasureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MeasureType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MeasureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MeasureType


class EllipsoidPropertyType(GeneratedsSuper):
    """gml:EllipsoidPropertyType is a property type for association roles
    to an ellipsoid, either referencing or containing the definition
    of that ellipsoid."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, Ellipsoid=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.Ellipsoid = Ellipsoid
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EllipsoidPropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EllipsoidPropertyType.subclass:
            return EllipsoidPropertyType.subclass(*args_, **kwargs_)
        else:
            return EllipsoidPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Ellipsoid(self): return self.Ellipsoid
    def set_Ellipsoid(self, Ellipsoid): self.Ellipsoid = Ellipsoid
    EllipsoidProp = property(get_Ellipsoid, set_Ellipsoid)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.Ellipsoid is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EllipsoidPropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EllipsoidPropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EllipsoidPropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EllipsoidPropertyType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EllipsoidPropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Ellipsoid is not None:
            self.Ellipsoid.export(outfile, level, namespace_='gml:', name_='Ellipsoid', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Ellipsoid':
            obj_ = EllipsoidType.factory()
            obj_.build(child_)
            self.Ellipsoid = obj_
            obj_.original_tagname_ = 'Ellipsoid'
# end class EllipsoidPropertyType


class secondDefiningParameter(GeneratedsSuper):
    """gml:secondDefiningParameter is a property containing the definition
    of the second parameter that defines the shape of an ellipsoid.
    An ellipsoid requires two defining parameters: semi-major axis
    and inverse flattening or semi-major axis and semi-minor axis.
    When the reference body is a sphere rather than an ellipsoid,
    only a single defining parameter is required, namely the radius
    of the sphere; in that case, the semi-major axis "degenerates"
    into the radius of the sphere. The inverseFlattening element
    contains the inverse flattening value of the ellipsoid. This
    value is a scale factor (or ratio). It uses gml:LengthType with
    the restriction that the unit of measure referenced by the uom
    attribute must be suitable for a scale factor, such as percent,
    permil, or parts-per-million. The semiMinorAxis element contains
    the length of the semi-minor axis of the ellipsoid. When the
    isSphere element is included, the ellipsoid is degenerate and is
    actually a sphere. The sphere is completely defined by the semi-
    major axis, which is the radius of the sphere."""
    subclass = None
    superclass = None
    def __init__(self, SecondDefiningParameter=None):
        self.original_tagname_ = None
        self.SecondDefiningParameter = SecondDefiningParameter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, secondDefiningParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if secondDefiningParameter.subclass:
            return secondDefiningParameter.subclass(*args_, **kwargs_)
        else:
            return secondDefiningParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SecondDefiningParameter(self): return self.SecondDefiningParameter
    def set_SecondDefiningParameter(self, SecondDefiningParameter): self.SecondDefiningParameter = SecondDefiningParameter
    SecondDefiningParameterProp = property(get_SecondDefiningParameter, set_SecondDefiningParameter)
    def hasContent_(self):
        if (
            self.SecondDefiningParameter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='secondDefiningParameter', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='secondDefiningParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='secondDefiningParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='secondDefiningParameter'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='secondDefiningParameter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SecondDefiningParameter is not None:
            self.SecondDefiningParameter.export(outfile, level, namespace_='gml:', name_='SecondDefiningParameter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SecondDefiningParameter':
            obj_ = SecondDefiningParameter.factory()
            obj_.build(child_)
            self.SecondDefiningParameter = obj_
            obj_.original_tagname_ = 'SecondDefiningParameter'
# end class secondDefiningParameter


class SecondDefiningParameter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, inverseFlattening=None, semiMinorAxis=None, isSphere='true'):
        self.original_tagname_ = None
        self.inverseFlattening = inverseFlattening
        self.semiMinorAxis = semiMinorAxis
        self.isSphere = isSphere
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SecondDefiningParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SecondDefiningParameter.subclass:
            return SecondDefiningParameter.subclass(*args_, **kwargs_)
        else:
            return SecondDefiningParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inverseFlattening(self): return self.inverseFlattening
    def set_inverseFlattening(self, inverseFlattening): self.inverseFlattening = inverseFlattening
    inverseFlatteningProp = property(get_inverseFlattening, set_inverseFlattening)
    def get_semiMinorAxis(self): return self.semiMinorAxis
    def set_semiMinorAxis(self, semiMinorAxis): self.semiMinorAxis = semiMinorAxis
    semiMinorAxisProp = property(get_semiMinorAxis, set_semiMinorAxis)
    def get_isSphere(self): return self.isSphere
    def set_isSphere(self, isSphere): self.isSphere = isSphere
    isSphereProp = property(get_isSphere, set_isSphere)
    def hasContent_(self):
        if (
            self.inverseFlattening is not None or
            self.semiMinorAxis is not None or
            self.isSphere != "true"
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='SecondDefiningParameter', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SecondDefiningParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='SecondDefiningParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='SecondDefiningParameter'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='SecondDefiningParameter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.inverseFlattening is not None:
            self.inverseFlattening.export(outfile, level, namespace_, name_='inverseFlattening', pretty_print=pretty_print)
        if self.semiMinorAxis is not None:
            self.semiMinorAxis.export(outfile, level, namespace_, name_='semiMinorAxis', pretty_print=pretty_print)
        if self.isSphere != "true":
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisSphere>%s</%sisSphere>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.isSphere), input_name='isSphere')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'inverseFlattening':
            class_obj_ = self.get_class_obj_(child_, MeasureType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.inverseFlattening = obj_
            obj_.original_tagname_ = 'inverseFlattening'
        elif nodeName_ == 'semiMinorAxis':
            obj_ = LengthType.factory()
            obj_.build(child_)
            self.semiMinorAxis = obj_
            obj_.original_tagname_ = 'semiMinorAxis'
        elif nodeName_ == 'isSphere':
            isSphere_ = child_.text
            isSphere_ = self.gds_validate_string(isSphere_, node, 'isSphere')
            self.isSphere = isSphere_
# end class SecondDefiningParameter


class LengthType(MeasureType):
    """This is a prototypical definition for a specific measure type
    defined as a vacuous extension (i.e. aliases) of
    gml:MeasureType. In this case, the content model supports the
    description of a length (or distance) quantity, with its units.
    The unit of measure referenced by uom shall be suitable for a
    length, such as metres or feet."""
    subclass = None
    superclass = MeasureType
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(LengthType, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthType.subclass:
            return LengthType.subclass(*args_, **kwargs_)
        else:
            return LengthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_ or
            super(LengthType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='LengthType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='LengthType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='LengthType'):
        super(LengthType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LengthType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='LengthType', fromsubclass_=False, pretty_print=True):
        super(LengthType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LengthType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthType


class GeneralConversionPropertyType(GeneratedsSuper):
    """gml:GeneralConversionPropertyType is a property type for association
    roles to a general conversion, either referencing or containing
    the definition of that conversion."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, AbstractGeneralConversion=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.AbstractGeneralConversion = AbstractGeneralConversion
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralConversionPropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralConversionPropertyType.subclass:
            return GeneralConversionPropertyType.subclass(*args_, **kwargs_)
        else:
            return GeneralConversionPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractGeneralConversion(self): return self.AbstractGeneralConversion
    def set_AbstractGeneralConversion(self, AbstractGeneralConversion): self.AbstractGeneralConversion = AbstractGeneralConversion
    AbstractGeneralConversionProp = property(get_AbstractGeneralConversion, set_AbstractGeneralConversion)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.AbstractGeneralConversion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeneralConversionPropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeneralConversionPropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeneralConversionPropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeneralConversionPropertyType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeneralConversionPropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AbstractGeneralConversion is not None:
            self.AbstractGeneralConversion.export(outfile, level, namespace_, name_='AbstractGeneralConversion', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractGeneralConversion':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeneralConversion> element')
            self.AbstractGeneralConversion = obj_
            obj_.original_tagname_ = 'AbstractGeneralConversion'
# end class GeneralConversionPropertyType


class AbstractGeneralConversionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, coordinateOperationAccuracy=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.description = description
        self.descriptionReference = descriptionReference
        self.identifier = identifier
        if name is None:
            self.name = []
        else:
            self.name = name
        self.remarks = remarks
        self.domainOfValidity = domainOfValidity
        if scope is None:
            self.scope = []
        else:
            self.scope = scope
        if coordinateOperationAccuracy is None:
            self.coordinateOperationAccuracy = []
        else:
            self.coordinateOperationAccuracy = coordinateOperationAccuracy
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractGeneralConversionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractGeneralConversionType.subclass:
            return AbstractGeneralConversionType.subclass(*args_, **kwargs_)
        else:
            return AbstractGeneralConversionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_descriptionReference(self): return self.descriptionReference
    def set_descriptionReference(self, descriptionReference): self.descriptionReference = descriptionReference
    descriptionReferenceProp = property(get_descriptionReference, set_descriptionReference)
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    identifierProp = property(get_identifier, set_identifier)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name_at(self, index, value): self.name.insert(index, value)
    def replace_name_at(self, index, value): self.name[index] = value
    nameProp = property(get_name, set_name)
    def get_remarks(self): return self.remarks
    def set_remarks(self, remarks): self.remarks = remarks
    remarksProp = property(get_remarks, set_remarks)
    def get_domainOfValidity(self): return self.domainOfValidity
    def set_domainOfValidity(self, domainOfValidity): self.domainOfValidity = domainOfValidity
    domainOfValidityProp = property(get_domainOfValidity, set_domainOfValidity)
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def add_scope(self, value): self.scope.append(value)
    def insert_scope_at(self, index, value): self.scope.insert(index, value)
    def replace_scope_at(self, index, value): self.scope[index] = value
    scopeProp = property(get_scope, set_scope)
    def get_coordinateOperationAccuracy(self): return self.coordinateOperationAccuracy
    def set_coordinateOperationAccuracy(self, coordinateOperationAccuracy): self.coordinateOperationAccuracy = coordinateOperationAccuracy
    def add_coordinateOperationAccuracy(self, value): self.coordinateOperationAccuracy.append(value)
    def insert_coordinateOperationAccuracy_at(self, index, value): self.coordinateOperationAccuracy.insert(index, value)
    def replace_coordinateOperationAccuracy_at(self, index, value): self.coordinateOperationAccuracy[index] = value
    coordinateOperationAccuracyProp = property(get_coordinateOperationAccuracy, set_coordinateOperationAccuracy)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    idProp = property(get_id, set_id)
    def hasContent_(self):
        if (
            self.description is not None or
            self.descriptionReference is not None or
            self.identifier is not None or
            self.name or
            self.remarks is not None or
            self.domainOfValidity is not None or
            self.scope or
            self.coordinateOperationAccuracy
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractGeneralConversionType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeneralConversionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractGeneralConversionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractGeneralConversionType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractGeneralConversionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            self.description.export(outfile, level, namespace_='gml:', name_='description', pretty_print=pretty_print)
        if self.descriptionReference is not None:
            self.descriptionReference.export(outfile, level, namespace_='gml:', name_='descriptionReference', pretty_print=pretty_print)
        if self.identifier is not None:
            self.identifier.export(outfile, level, namespace_='gml:', name_='identifier', pretty_print=pretty_print)
        for name_ in self.name:
            name_.export(outfile, level, namespace_='gml:', name_='name', pretty_print=pretty_print)
        if self.remarks is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sremarks>%s</%sremarks>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.remarks), input_name='remarks')), namespace_, eol_))
        if self.domainOfValidity is not None:
            self.domainOfValidity.export(outfile, level, namespace_='gml:', name_='domainOfValidity', pretty_print=pretty_print)
        for scope_ in self.scope:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscope>%s</%sscope>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(scope_), input_name='scope')), namespace_, eol_))
        for coordinateOperationAccuracy_ in self.coordinateOperationAccuracy:
            coordinateOperationAccuracy_.export(outfile, level, namespace_='gml:', name_='coordinateOperationAccuracy', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'descriptionReference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.descriptionReference = obj_
            obj_.original_tagname_ = 'descriptionReference'
        elif nodeName_ == 'identifier':
            obj_ = CodeWithAuthorityType.factory()
            obj_.build(child_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'remarks':
            remarks_ = child_.text
            remarks_ = self.gds_validate_string(remarks_, node, 'remarks')
            self.remarks = remarks_
        elif nodeName_ == 'domainOfValidity':
            obj_ = domainOfValidity.factory()
            obj_.build(child_)
            self.domainOfValidity = obj_
            obj_.original_tagname_ = 'domainOfValidity'
        elif nodeName_ == 'scope':
            scope_ = child_.text
            scope_ = self.gds_validate_string(scope_, node, 'scope')
            self.scope.append(scope_)
        elif nodeName_ == 'coordinateOperationAccuracy':
            obj_ = coordinateOperationAccuracy.factory()
            obj_.build(child_)
            self.coordinateOperationAccuracy.append(obj_)
            obj_.original_tagname_ = 'coordinateOperationAccuracy'
# end class AbstractGeneralConversionType


class coordinateOperationAccuracy(GeneratedsSuper):
    """gml:coordinateOperationAccuracy is an association role to a
    DQ_PositionalAccuracy object as encoded in ISO/TS 19139, either
    referencing or containing the definition of that positional
    accuracy. That object contains an estimate of the impact of this
    coordinate operation on point accuracy. That is, it gives
    position error estimates for the target coordinates of this
    coordinate operation, assuming no errors in the source
    coordinates."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, AbstractDQ_PositionalAccuracy=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.AbstractDQ_PositionalAccuracy = AbstractDQ_PositionalAccuracy
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, coordinateOperationAccuracy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if coordinateOperationAccuracy.subclass:
            return coordinateOperationAccuracy.subclass(*args_, **kwargs_)
        else:
            return coordinateOperationAccuracy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractDQ_PositionalAccuracy(self): return self.AbstractDQ_PositionalAccuracy
    def set_AbstractDQ_PositionalAccuracy(self, AbstractDQ_PositionalAccuracy): self.AbstractDQ_PositionalAccuracy = AbstractDQ_PositionalAccuracy
    AbstractDQ_PositionalAccuracyProp = property(get_AbstractDQ_PositionalAccuracy, set_AbstractDQ_PositionalAccuracy)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.AbstractDQ_PositionalAccuracy is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='coordinateOperationAccuracy', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='coordinateOperationAccuracy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='coordinateOperationAccuracy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='coordinateOperationAccuracy'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='coordinateOperationAccuracy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AbstractDQ_PositionalAccuracy is not None:
            self.AbstractDQ_PositionalAccuracy.export(outfile, level, namespace_, name_='AbstractDQ_PositionalAccuracy', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractDQ_PositionalAccuracy':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractDQ_PositionalAccuracy> element')
            self.AbstractDQ_PositionalAccuracy = obj_
            obj_.original_tagname_ = 'AbstractDQ_PositionalAccuracy'
# end class coordinateOperationAccuracy


class CRSPropertyType(GeneratedsSuper):
    """gml:CRSPropertyType is a property type for association roles to a
    CRS abstract coordinate reference system, either referencing or
    containing the definition of that CRS."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, AbstractCRS=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.AbstractCRS = AbstractCRS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CRSPropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CRSPropertyType.subclass:
            return CRSPropertyType.subclass(*args_, **kwargs_)
        else:
            return CRSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractCRS(self): return self.AbstractCRS
    def set_AbstractCRS(self, AbstractCRS): self.AbstractCRS = AbstractCRS
    AbstractCRSProp = property(get_AbstractCRS, set_AbstractCRS)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.AbstractCRS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CRSPropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CRSPropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CRSPropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CRSPropertyType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CRSPropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AbstractCRS is not None:
            self.AbstractCRS.export(outfile, level, namespace_, name_='AbstractCRS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractCRS':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractCRS> element')
            self.AbstractCRS = obj_
            obj_.original_tagname_ = 'AbstractCRS'
        elif nodeName_ == 'AbstractSingleCRS':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractSingleCRS> element')
            self.AbstractCRS = obj_
            obj_.original_tagname_ = 'AbstractSingleCRS'
        elif nodeName_ == 'GeodeticCRS':
            obj_ = GeodeticCRSType.factory()
            obj_.build(child_)
            self.AbstractSingleCRS = obj_
            obj_.original_tagname_ = 'GeodeticCRS'
        elif nodeName_ == 'AbstractGeneralDerivedCRS':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeneralDerivedCRS> element')
            self.AbstractSingleCRS = obj_
            obj_.original_tagname_ = 'AbstractGeneralDerivedCRS'
        elif nodeName_ == 'VerticalCRS':
            obj_ = VerticalCRSType.factory()
            obj_.build(child_)
            self.AbstractSingleCRS = obj_
            obj_.original_tagname_ = 'VerticalCRS'
        elif nodeName_ == 'ProjectedCRS':
            obj_ = ProjectedCRSType.factory()
            obj_.build(child_)
            self.AbstractGeneralDerivedCRS = obj_
            obj_.original_tagname_ = 'ProjectedCRS'
# end class CRSPropertyType


class GeodeticCRSPropertyType(GeneratedsSuper):
    """gml:GeodeticCRSPropertyType is a property type for association roles
    to a geodetic coordinate reference system, either referencing or
    containing the definition of that reference system."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, GeodeticCRS=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.GeodeticCRS = GeodeticCRS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeodeticCRSPropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeodeticCRSPropertyType.subclass:
            return GeodeticCRSPropertyType.subclass(*args_, **kwargs_)
        else:
            return GeodeticCRSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GeodeticCRS(self): return self.GeodeticCRS
    def set_GeodeticCRS(self, GeodeticCRS): self.GeodeticCRS = GeodeticCRS
    GeodeticCRSProp = property(get_GeodeticCRS, set_GeodeticCRS)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.GeodeticCRS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeodeticCRSPropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticCRSPropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeodeticCRSPropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeodeticCRSPropertyType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeodeticCRSPropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GeodeticCRS is not None:
            self.GeodeticCRS.export(outfile, level, namespace_='gml:', name_='GeodeticCRS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GeodeticCRS':
            obj_ = GeodeticCRSType.factory()
            obj_.build(child_)
            self.GeodeticCRS = obj_
            obj_.original_tagname_ = 'GeodeticCRS'
# end class GeodeticCRSPropertyType


class VerticalCSPropertyType(GeneratedsSuper):
    """gml:VerticalCSPropertyType is a property type for association roles
    to a vertical coordinate system, either referencing or
    containing the definition of that coordinate system."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, VerticalCS=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.VerticalCS = VerticalCS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalCSPropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalCSPropertyType.subclass:
            return VerticalCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return VerticalCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VerticalCS(self): return self.VerticalCS
    def set_VerticalCS(self, VerticalCS): self.VerticalCS = VerticalCS
    VerticalCSProp = property(get_VerticalCS, set_VerticalCS)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.VerticalCS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VerticalCSPropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalCSPropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VerticalCSPropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VerticalCSPropertyType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VerticalCSPropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VerticalCS is not None:
            self.VerticalCS.export(outfile, level, namespace_='gml:', name_='VerticalCS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VerticalCS':
            obj_ = VerticalCSType.factory()
            obj_.build(child_)
            self.VerticalCS = obj_
            obj_.original_tagname_ = 'VerticalCS'
# end class VerticalCSPropertyType


class VerticalDatumPropertyType(GeneratedsSuper):
    """gml:VerticalDatumPropertyType is property type for association roles
    to a vertical datum, either referencing or containing the
    definition of that datum."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, VerticalDatum=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.nilReason = _cast(None, nilReason)
        self.VerticalDatum = VerticalDatum
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalDatumPropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalDatumPropertyType.subclass:
            return VerticalDatumPropertyType.subclass(*args_, **kwargs_)
        else:
            return VerticalDatumPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VerticalDatum(self): return self.VerticalDatum
    def set_VerticalDatum(self, VerticalDatum): self.VerticalDatum = VerticalDatum
    VerticalDatumProp = property(get_VerticalDatum, set_VerticalDatum)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.VerticalDatum is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VerticalDatumPropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalDatumPropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VerticalDatumPropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VerticalDatumPropertyType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VerticalDatumPropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VerticalDatum is not None:
            self.VerticalDatum.export(outfile, level, namespace_='gml:', name_='VerticalDatum', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VerticalDatum':
            obj_ = VerticalDatumType.factory()
            obj_.build(child_)
            self.VerticalDatum = obj_
            obj_.original_tagname_ = 'VerticalDatum'
# end class VerticalDatumPropertyType


class EX_GeographicExtent_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, uuidref=None, AbstractEX_GeographicExtent=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.uuidref = _cast(None, uuidref)
        self.AbstractEX_GeographicExtent = AbstractEX_GeographicExtent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EX_GeographicExtent_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EX_GeographicExtent_PropertyType.subclass:
            return EX_GeographicExtent_PropertyType.subclass(*args_, **kwargs_)
        else:
            return EX_GeographicExtent_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractEX_GeographicExtent(self): return self.AbstractEX_GeographicExtent
    def set_AbstractEX_GeographicExtent(self, AbstractEX_GeographicExtent): self.AbstractEX_GeographicExtent = AbstractEX_GeographicExtent
    AbstractEX_GeographicExtentProp = property(get_AbstractEX_GeographicExtent, set_AbstractEX_GeographicExtent)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_uuidref(self): return self.uuidref
    def set_uuidref(self, uuidref): self.uuidref = uuidref
    uuidrefProp = property(get_uuidref, set_uuidref)
    def hasContent_(self):
        if (
            self.AbstractEX_GeographicExtent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EX_GeographicExtent_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_GeographicExtent_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EX_GeographicExtent_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EX_GeographicExtent_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.uuidref is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            outfile.write(' uuidref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuidref), input_name='uuidref')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EX_GeographicExtent_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AbstractEX_GeographicExtent is not None:
            self.AbstractEX_GeographicExtent.export(outfile, level, namespace_, name_='AbstractEX_GeographicExtent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('uuidref', node)
        if value is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            self.uuidref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractEX_GeographicExtent':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractEX_GeographicExtent> element')
            self.AbstractEX_GeographicExtent = obj_
            obj_.original_tagname_ = 'AbstractEX_GeographicExtent'
# end class EX_GeographicExtent_PropertyType


class EX_TemporalExtent_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, uuidref=None, EX_TemporalExtent=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.uuidref = _cast(None, uuidref)
        self.EX_TemporalExtent = EX_TemporalExtent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EX_TemporalExtent_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EX_TemporalExtent_PropertyType.subclass:
            return EX_TemporalExtent_PropertyType.subclass(*args_, **kwargs_)
        else:
            return EX_TemporalExtent_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EX_TemporalExtent(self): return self.EX_TemporalExtent
    def set_EX_TemporalExtent(self, EX_TemporalExtent): self.EX_TemporalExtent = EX_TemporalExtent
    EX_TemporalExtentProp = property(get_EX_TemporalExtent, set_EX_TemporalExtent)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_uuidref(self): return self.uuidref
    def set_uuidref(self, uuidref): self.uuidref = uuidref
    uuidrefProp = property(get_uuidref, set_uuidref)
    def hasContent_(self):
        if (
            self.EX_TemporalExtent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EX_TemporalExtent_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_TemporalExtent_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EX_TemporalExtent_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EX_TemporalExtent_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.uuidref is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            outfile.write(' uuidref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuidref), input_name='uuidref')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EX_TemporalExtent_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EX_TemporalExtent is not None:
            self.EX_TemporalExtent.export(outfile, level, namespace_='gmd:', name_='EX_TemporalExtent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('uuidref', node)
        if value is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            self.uuidref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EX_TemporalExtent':
            obj_ = EX_TemporalExtent_Type.factory()
            obj_.build(child_)
            self.EX_TemporalExtent = obj_
            obj_.original_tagname_ = 'EX_TemporalExtent'
# end class EX_TemporalExtent_PropertyType


class EX_VerticalExtent_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, uuidref=None, EX_VerticalExtent=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.uuidref = _cast(None, uuidref)
        self.EX_VerticalExtent = EX_VerticalExtent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EX_VerticalExtent_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EX_VerticalExtent_PropertyType.subclass:
            return EX_VerticalExtent_PropertyType.subclass(*args_, **kwargs_)
        else:
            return EX_VerticalExtent_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EX_VerticalExtent(self): return self.EX_VerticalExtent
    def set_EX_VerticalExtent(self, EX_VerticalExtent): self.EX_VerticalExtent = EX_VerticalExtent
    EX_VerticalExtentProp = property(get_EX_VerticalExtent, set_EX_VerticalExtent)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_uuidref(self): return self.uuidref
    def set_uuidref(self, uuidref): self.uuidref = uuidref
    uuidrefProp = property(get_uuidref, set_uuidref)
    def hasContent_(self):
        if (
            self.EX_VerticalExtent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EX_VerticalExtent_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_VerticalExtent_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EX_VerticalExtent_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EX_VerticalExtent_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.uuidref is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            outfile.write(' uuidref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuidref), input_name='uuidref')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EX_VerticalExtent_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EX_VerticalExtent is not None:
            self.EX_VerticalExtent.export(outfile, level, namespace_='gmd:', name_='EX_VerticalExtent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('uuidref', node)
        if value is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            self.uuidref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EX_VerticalExtent':
            obj_ = EX_VerticalExtent_Type.factory()
            obj_.build(child_)
            self.EX_VerticalExtent = obj_
            obj_.original_tagname_ = 'EX_VerticalExtent'
# end class EX_VerticalExtent_PropertyType


class MD_Identifier_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, uuidref=None, MD_Identifier=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.uuidref = _cast(None, uuidref)
        self.MD_Identifier = MD_Identifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MD_Identifier_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MD_Identifier_PropertyType.subclass:
            return MD_Identifier_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Identifier_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_Identifier(self): return self.MD_Identifier
    def set_MD_Identifier(self, MD_Identifier): self.MD_Identifier = MD_Identifier
    MD_IdentifierProp = property(get_MD_Identifier, set_MD_Identifier)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_uuidref(self): return self.uuidref
    def set_uuidref(self, uuidref): self.uuidref = uuidref
    uuidrefProp = property(get_uuidref, set_uuidref)
    def hasContent_(self):
        if (
            self.MD_Identifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MD_Identifier_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Identifier_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MD_Identifier_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MD_Identifier_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.uuidref is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            outfile.write(' uuidref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuidref), input_name='uuidref')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MD_Identifier_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MD_Identifier is not None:
            self.MD_Identifier.export(outfile, level, namespace_='gmd:', name_='MD_Identifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('uuidref', node)
        if value is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            self.uuidref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_Identifier':
            obj_ = MD_Identifier_Type.factory()
            obj_.build(child_)
            self.MD_Identifier = obj_
            obj_.original_tagname_ = 'MD_Identifier'
# end class MD_Identifier_PropertyType


class CI_Citation_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, uuidref=None, CI_Citation=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.uuidref = _cast(None, uuidref)
        self.CI_Citation = CI_Citation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_Citation_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_Citation_PropertyType.subclass:
            return CI_Citation_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_Citation_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_Citation(self): return self.CI_Citation
    def set_CI_Citation(self, CI_Citation): self.CI_Citation = CI_Citation
    CI_CitationProp = property(get_CI_Citation, set_CI_Citation)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_uuidref(self): return self.uuidref
    def set_uuidref(self, uuidref): self.uuidref = uuidref
    uuidrefProp = property(get_uuidref, set_uuidref)
    def hasContent_(self):
        if (
            self.CI_Citation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_Citation_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Citation_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_Citation_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_Citation_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.uuidref is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            outfile.write(' uuidref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuidref), input_name='uuidref')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_Citation_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CI_Citation is not None:
            self.CI_Citation.export(outfile, level, namespace_='gmd:', name_='CI_Citation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('uuidref', node)
        if value is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            self.uuidref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_Citation':
            obj_ = CI_Citation_Type.factory()
            obj_.build(child_)
            self.CI_Citation = obj_
            obj_.original_tagname_ = 'CI_Citation'
# end class CI_Citation_PropertyType


class CI_Date_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, uuidref=None, CI_Date=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.uuidref = _cast(None, uuidref)
        self.CI_Date = CI_Date
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_Date_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_Date_PropertyType.subclass:
            return CI_Date_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_Date_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_Date(self): return self.CI_Date
    def set_CI_Date(self, CI_Date): self.CI_Date = CI_Date
    CI_DateProp = property(get_CI_Date, set_CI_Date)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_uuidref(self): return self.uuidref
    def set_uuidref(self, uuidref): self.uuidref = uuidref
    uuidrefProp = property(get_uuidref, set_uuidref)
    def hasContent_(self):
        if (
            self.CI_Date is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_Date_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Date_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_Date_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_Date_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.uuidref is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            outfile.write(' uuidref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuidref), input_name='uuidref')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_Date_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CI_Date is not None:
            self.CI_Date.export(outfile, level, namespace_='gmd:', name_='CI_Date', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('uuidref', node)
        if value is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            self.uuidref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_Date':
            obj_ = CI_Date_Type.factory()
            obj_.build(child_)
            self.CI_Date = obj_
            obj_.original_tagname_ = 'CI_Date'
# end class CI_Date_PropertyType


class CI_DateTypeCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_DateTypeCode=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.CI_DateTypeCode = CI_DateTypeCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_DateTypeCode_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_DateTypeCode_PropertyType.subclass:
            return CI_DateTypeCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_DateTypeCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_DateTypeCode(self): return self.CI_DateTypeCode
    def set_CI_DateTypeCode(self, CI_DateTypeCode): self.CI_DateTypeCode = CI_DateTypeCode
    CI_DateTypeCodeProp = property(get_CI_DateTypeCode, set_CI_DateTypeCode)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.CI_DateTypeCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_DateTypeCode_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_DateTypeCode_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_DateTypeCode_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_DateTypeCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_DateTypeCode_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CI_DateTypeCode is not None:
            self.CI_DateTypeCode.export(outfile, level, namespace_='gmd:', name_='CI_DateTypeCode', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_DateTypeCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.CI_DateTypeCode = obj_
            obj_.original_tagname_ = 'CI_DateTypeCode'
# end class CI_DateTypeCode_PropertyType


class CI_ResponsibleParty_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, uuidref=None, CI_ResponsibleParty=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.uuidref = _cast(None, uuidref)
        self.CI_ResponsibleParty = CI_ResponsibleParty
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_ResponsibleParty_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_ResponsibleParty_PropertyType.subclass:
            return CI_ResponsibleParty_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_ResponsibleParty_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_ResponsibleParty(self): return self.CI_ResponsibleParty
    def set_CI_ResponsibleParty(self, CI_ResponsibleParty): self.CI_ResponsibleParty = CI_ResponsibleParty
    CI_ResponsiblePartyProp = property(get_CI_ResponsibleParty, set_CI_ResponsibleParty)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_uuidref(self): return self.uuidref
    def set_uuidref(self, uuidref): self.uuidref = uuidref
    uuidrefProp = property(get_uuidref, set_uuidref)
    def hasContent_(self):
        if (
            self.CI_ResponsibleParty is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_ResponsibleParty_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_ResponsibleParty_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_ResponsibleParty_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_ResponsibleParty_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.uuidref is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            outfile.write(' uuidref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuidref), input_name='uuidref')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_ResponsibleParty_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CI_ResponsibleParty is not None:
            self.CI_ResponsibleParty.export(outfile, level, namespace_='gmd:', name_='CI_ResponsibleParty', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('uuidref', node)
        if value is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            self.uuidref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_ResponsibleParty':
            obj_ = CI_ResponsibleParty_Type.factory()
            obj_.build(child_)
            self.CI_ResponsibleParty = obj_
            obj_.original_tagname_ = 'CI_ResponsibleParty'
# end class CI_ResponsibleParty_PropertyType


class CI_Contact_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, uuidref=None, CI_Contact=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.uuidref = _cast(None, uuidref)
        self.CI_Contact = CI_Contact
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_Contact_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_Contact_PropertyType.subclass:
            return CI_Contact_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_Contact_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_Contact(self): return self.CI_Contact
    def set_CI_Contact(self, CI_Contact): self.CI_Contact = CI_Contact
    CI_ContactProp = property(get_CI_Contact, set_CI_Contact)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_uuidref(self): return self.uuidref
    def set_uuidref(self, uuidref): self.uuidref = uuidref
    uuidrefProp = property(get_uuidref, set_uuidref)
    def hasContent_(self):
        if (
            self.CI_Contact is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_Contact_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Contact_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_Contact_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_Contact_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.uuidref is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            outfile.write(' uuidref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuidref), input_name='uuidref')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_Contact_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CI_Contact is not None:
            self.CI_Contact.export(outfile, level, namespace_='gmd:', name_='CI_Contact', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('uuidref', node)
        if value is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            self.uuidref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_Contact':
            obj_ = CI_Contact_Type.factory()
            obj_.build(child_)
            self.CI_Contact = obj_
            obj_.original_tagname_ = 'CI_Contact'
# end class CI_Contact_PropertyType


class CI_Telephone_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, uuidref=None, CI_Telephone=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.uuidref = _cast(None, uuidref)
        self.CI_Telephone = CI_Telephone
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_Telephone_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_Telephone_PropertyType.subclass:
            return CI_Telephone_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_Telephone_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_Telephone(self): return self.CI_Telephone
    def set_CI_Telephone(self, CI_Telephone): self.CI_Telephone = CI_Telephone
    CI_TelephoneProp = property(get_CI_Telephone, set_CI_Telephone)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_uuidref(self): return self.uuidref
    def set_uuidref(self, uuidref): self.uuidref = uuidref
    uuidrefProp = property(get_uuidref, set_uuidref)
    def hasContent_(self):
        if (
            self.CI_Telephone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_Telephone_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Telephone_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_Telephone_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_Telephone_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.uuidref is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            outfile.write(' uuidref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuidref), input_name='uuidref')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_Telephone_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CI_Telephone is not None:
            self.CI_Telephone.export(outfile, level, namespace_='gmd:', name_='CI_Telephone', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('uuidref', node)
        if value is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            self.uuidref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_Telephone':
            obj_ = CI_Telephone_Type.factory()
            obj_.build(child_)
            self.CI_Telephone = obj_
            obj_.original_tagname_ = 'CI_Telephone'
# end class CI_Telephone_PropertyType


class CI_Address_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, uuidref=None, CI_Address=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.uuidref = _cast(None, uuidref)
        self.CI_Address = CI_Address
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_Address_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_Address_PropertyType.subclass:
            return CI_Address_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_Address_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_Address(self): return self.CI_Address
    def set_CI_Address(self, CI_Address): self.CI_Address = CI_Address
    CI_AddressProp = property(get_CI_Address, set_CI_Address)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_uuidref(self): return self.uuidref
    def set_uuidref(self, uuidref): self.uuidref = uuidref
    uuidrefProp = property(get_uuidref, set_uuidref)
    def hasContent_(self):
        if (
            self.CI_Address is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_Address_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Address_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_Address_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_Address_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.uuidref is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            outfile.write(' uuidref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuidref), input_name='uuidref')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_Address_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CI_Address is not None:
            self.CI_Address.export(outfile, level, namespace_='gmd:', name_='CI_Address', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('uuidref', node)
        if value is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            self.uuidref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_Address':
            obj_ = CI_Address_Type.factory()
            obj_.build(child_)
            self.CI_Address = obj_
            obj_.original_tagname_ = 'CI_Address'
# end class CI_Address_PropertyType


class CI_OnlineResource_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, uuidref=None, CI_OnlineResource=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.uuidref = _cast(None, uuidref)
        self.CI_OnlineResource = CI_OnlineResource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_OnlineResource_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_OnlineResource_PropertyType.subclass:
            return CI_OnlineResource_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_OnlineResource_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_OnlineResource(self): return self.CI_OnlineResource
    def set_CI_OnlineResource(self, CI_OnlineResource): self.CI_OnlineResource = CI_OnlineResource
    CI_OnlineResourceProp = property(get_CI_OnlineResource, set_CI_OnlineResource)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_uuidref(self): return self.uuidref
    def set_uuidref(self, uuidref): self.uuidref = uuidref
    uuidrefProp = property(get_uuidref, set_uuidref)
    def hasContent_(self):
        if (
            self.CI_OnlineResource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_OnlineResource_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_OnlineResource_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_OnlineResource_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_OnlineResource_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.uuidref is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            outfile.write(' uuidref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuidref), input_name='uuidref')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_OnlineResource_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CI_OnlineResource is not None:
            self.CI_OnlineResource.export(outfile, level, namespace_='gmd:', name_='CI_OnlineResource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('uuidref', node)
        if value is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            self.uuidref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_OnlineResource':
            obj_ = CI_OnlineResource_Type.factory()
            obj_.build(child_)
            self.CI_OnlineResource = obj_
            obj_.original_tagname_ = 'CI_OnlineResource'
# end class CI_OnlineResource_PropertyType


class URL_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, URL=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.URL = URL
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, URL_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if URL_PropertyType.subclass:
            return URL_PropertyType.subclass(*args_, **kwargs_)
        else:
            return URL_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    URLProp = property(get_URL, set_URL)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.URL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='URL_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URL_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='URL_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='URL_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='URL_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.URL), input_name='URL')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
# end class URL_PropertyType


class CI_OnLineFunctionCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_OnLineFunctionCode=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.CI_OnLineFunctionCode = CI_OnLineFunctionCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_OnLineFunctionCode_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_OnLineFunctionCode_PropertyType.subclass:
            return CI_OnLineFunctionCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_OnLineFunctionCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_OnLineFunctionCode(self): return self.CI_OnLineFunctionCode
    def set_CI_OnLineFunctionCode(self, CI_OnLineFunctionCode): self.CI_OnLineFunctionCode = CI_OnLineFunctionCode
    CI_OnLineFunctionCodeProp = property(get_CI_OnLineFunctionCode, set_CI_OnLineFunctionCode)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.CI_OnLineFunctionCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_OnLineFunctionCode_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_OnLineFunctionCode_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_OnLineFunctionCode_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_OnLineFunctionCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_OnLineFunctionCode_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CI_OnLineFunctionCode is not None:
            self.CI_OnLineFunctionCode.export(outfile, level, namespace_='gmd:', name_='CI_OnLineFunctionCode', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_OnLineFunctionCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.CI_OnLineFunctionCode = obj_
            obj_.original_tagname_ = 'CI_OnLineFunctionCode'
# end class CI_OnLineFunctionCode_PropertyType


class CI_RoleCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_RoleCode=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.CI_RoleCode = CI_RoleCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_RoleCode_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_RoleCode_PropertyType.subclass:
            return CI_RoleCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_RoleCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_RoleCode(self): return self.CI_RoleCode
    def set_CI_RoleCode(self, CI_RoleCode): self.CI_RoleCode = CI_RoleCode
    CI_RoleCodeProp = property(get_CI_RoleCode, set_CI_RoleCode)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.CI_RoleCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_RoleCode_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_RoleCode_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_RoleCode_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_RoleCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_RoleCode_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CI_RoleCode is not None:
            self.CI_RoleCode.export(outfile, level, namespace_='gmd:', name_='CI_RoleCode', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_RoleCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.CI_RoleCode = obj_
            obj_.original_tagname_ = 'CI_RoleCode'
# end class CI_RoleCode_PropertyType


class CI_PresentationFormCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_PresentationFormCode=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.CI_PresentationFormCode = CI_PresentationFormCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_PresentationFormCode_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_PresentationFormCode_PropertyType.subclass:
            return CI_PresentationFormCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_PresentationFormCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_PresentationFormCode(self): return self.CI_PresentationFormCode
    def set_CI_PresentationFormCode(self, CI_PresentationFormCode): self.CI_PresentationFormCode = CI_PresentationFormCode
    CI_PresentationFormCodeProp = property(get_CI_PresentationFormCode, set_CI_PresentationFormCode)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.CI_PresentationFormCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_PresentationFormCode_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_PresentationFormCode_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_PresentationFormCode_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_PresentationFormCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_PresentationFormCode_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CI_PresentationFormCode is not None:
            self.CI_PresentationFormCode.export(outfile, level, namespace_='gmd:', name_='CI_PresentationFormCode', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_PresentationFormCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.CI_PresentationFormCode = obj_
            obj_.original_tagname_ = 'CI_PresentationFormCode'
# end class CI_PresentationFormCode_PropertyType


class CI_Series_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, uuidref=None, CI_Series=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.uuidref = _cast(None, uuidref)
        self.CI_Series = CI_Series
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_Series_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_Series_PropertyType.subclass:
            return CI_Series_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_Series_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_Series(self): return self.CI_Series
    def set_CI_Series(self, CI_Series): self.CI_Series = CI_Series
    CI_SeriesProp = property(get_CI_Series, set_CI_Series)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_uuidref(self): return self.uuidref
    def set_uuidref(self, uuidref): self.uuidref = uuidref
    uuidrefProp = property(get_uuidref, set_uuidref)
    def hasContent_(self):
        if (
            self.CI_Series is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_Series_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Series_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_Series_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_Series_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.uuidref is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            outfile.write(' uuidref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuidref), input_name='uuidref')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_Series_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CI_Series is not None:
            self.CI_Series.export(outfile, level, namespace_='gmd:', name_='CI_Series', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('uuidref', node)
        if value is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            self.uuidref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_Series':
            obj_ = CI_Series_Type.factory()
            obj_.build(child_)
            self.CI_Series = obj_
            obj_.original_tagname_ = 'CI_Series'
# end class CI_Series_PropertyType


class DQ_EvaluationMethodTypeCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_EvaluationMethodTypeCode=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.DQ_EvaluationMethodTypeCode = DQ_EvaluationMethodTypeCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DQ_EvaluationMethodTypeCode_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DQ_EvaluationMethodTypeCode_PropertyType.subclass:
            return DQ_EvaluationMethodTypeCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_EvaluationMethodTypeCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_EvaluationMethodTypeCode(self): return self.DQ_EvaluationMethodTypeCode
    def set_DQ_EvaluationMethodTypeCode(self, DQ_EvaluationMethodTypeCode): self.DQ_EvaluationMethodTypeCode = DQ_EvaluationMethodTypeCode
    DQ_EvaluationMethodTypeCodeProp = property(get_DQ_EvaluationMethodTypeCode, set_DQ_EvaluationMethodTypeCode)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.DQ_EvaluationMethodTypeCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DQ_EvaluationMethodTypeCode_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_EvaluationMethodTypeCode_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DQ_EvaluationMethodTypeCode_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DQ_EvaluationMethodTypeCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DQ_EvaluationMethodTypeCode_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DQ_EvaluationMethodTypeCode is not None:
            self.DQ_EvaluationMethodTypeCode.export(outfile, level, namespace_='gmd:', name_='DQ_EvaluationMethodTypeCode', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_EvaluationMethodTypeCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.DQ_EvaluationMethodTypeCode = obj_
            obj_.original_tagname_ = 'DQ_EvaluationMethodTypeCode'
# end class DQ_EvaluationMethodTypeCode_PropertyType


class DQ_Result_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, uuidref=None, AbstractDQ_Result=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.uuidref = _cast(None, uuidref)
        self.AbstractDQ_Result = AbstractDQ_Result
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DQ_Result_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DQ_Result_PropertyType.subclass:
            return DQ_Result_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_Result_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractDQ_Result(self): return self.AbstractDQ_Result
    def set_AbstractDQ_Result(self, AbstractDQ_Result): self.AbstractDQ_Result = AbstractDQ_Result
    AbstractDQ_ResultProp = property(get_AbstractDQ_Result, set_AbstractDQ_Result)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_uuidref(self): return self.uuidref
    def set_uuidref(self, uuidref): self.uuidref = uuidref
    uuidrefProp = property(get_uuidref, set_uuidref)
    def hasContent_(self):
        if (
            self.AbstractDQ_Result is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DQ_Result_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_Result_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DQ_Result_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DQ_Result_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.uuidref is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            outfile.write(' uuidref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuidref), input_name='uuidref')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DQ_Result_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AbstractDQ_Result is not None:
            self.AbstractDQ_Result.export(outfile, level, namespace_, name_='AbstractDQ_Result', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('uuidref', node)
        if value is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            self.uuidref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractDQ_Result':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractDQ_Result> element')
            self.AbstractDQ_Result = obj_
            obj_.original_tagname_ = 'AbstractDQ_Result'
# end class DQ_Result_PropertyType


class TM_Primitive_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, uuidref=None, AbstractTimePrimitive=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.uuidref = _cast(None, uuidref)
        self.AbstractTimePrimitive = AbstractTimePrimitive
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TM_Primitive_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TM_Primitive_PropertyType.subclass:
            return TM_Primitive_PropertyType.subclass(*args_, **kwargs_)
        else:
            return TM_Primitive_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractTimePrimitive(self): return self.AbstractTimePrimitive
    def set_AbstractTimePrimitive(self, AbstractTimePrimitive): self.AbstractTimePrimitive = AbstractTimePrimitive
    AbstractTimePrimitiveProp = property(get_AbstractTimePrimitive, set_AbstractTimePrimitive)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_uuidref(self): return self.uuidref
    def set_uuidref(self, uuidref): self.uuidref = uuidref
    uuidrefProp = property(get_uuidref, set_uuidref)
    def hasContent_(self):
        if (
            self.AbstractTimePrimitive is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TM_Primitive_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TM_Primitive_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TM_Primitive_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TM_Primitive_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.uuidref is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            outfile.write(' uuidref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuidref), input_name='uuidref')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TM_Primitive_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AbstractTimePrimitive is not None:
            self.AbstractTimePrimitive.export(outfile, level, namespace_, name_='AbstractTimePrimitive', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('uuidref', node)
        if value is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            self.uuidref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractTimePrimitive':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractTimePrimitive> element')
            self.AbstractTimePrimitive = obj_
            obj_.original_tagname_ = 'AbstractTimePrimitive'
# end class TM_Primitive_PropertyType


class AbstractObject_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, uuid=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.uuid = _cast(None, uuid)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractObject_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractObject_Type.subclass:
            return AbstractObject_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractObject_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    idProp = property(get_id, set_id)
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    uuidProp = property(get_uuid, set_uuid)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractObject_Type', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractObject_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractObject_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractObject_Type'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.uuid is not None and 'uuid' not in already_processed:
            already_processed.add('uuid')
            outfile.write(' uuid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuid), input_name='uuid')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractObject_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('uuid', node)
        if value is not None and 'uuid' not in already_processed:
            already_processed.add('uuid')
            self.uuid = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractObject_Type


class CharacterString_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CharacterString=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.CharacterString = CharacterString
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CharacterString_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CharacterString_PropertyType.subclass:
            return CharacterString_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CharacterString_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CharacterString(self): return self.CharacterString
    def set_CharacterString(self, CharacterString): self.CharacterString = CharacterString
    CharacterStringProp = property(get_CharacterString, set_CharacterString)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.CharacterString is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CharacterString_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CharacterString_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CharacterString_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CharacterString_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CharacterString_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CharacterString is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCharacterString>%s</%sCharacterString>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CharacterString), input_name='CharacterString')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CharacterString':
            CharacterString_ = child_.text
            CharacterString_ = self.gds_validate_string(CharacterString_, node, 'CharacterString')
            self.CharacterString = CharacterString_
        elif nodeName_ == 'CI_DateTypeCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.CharacterString = obj_
            obj_.original_tagname_ = 'CI_DateTypeCode'
        elif nodeName_ == 'CI_OnLineFunctionCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.CharacterString = obj_
            obj_.original_tagname_ = 'CI_OnLineFunctionCode'
        elif nodeName_ == 'CI_RoleCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.CharacterString = obj_
            obj_.original_tagname_ = 'CI_RoleCode'
        elif nodeName_ == 'CI_PresentationFormCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.CharacterString = obj_
            obj_.original_tagname_ = 'CI_PresentationFormCode'
        elif nodeName_ == 'DQ_EvaluationMethodTypeCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.CharacterString = obj_
            obj_.original_tagname_ = 'DQ_EvaluationMethodTypeCode'
# end class CharacterString_PropertyType


class Boolean_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Boolean=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.Boolean = Boolean
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Boolean_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Boolean_PropertyType.subclass:
            return Boolean_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Boolean_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Boolean(self): return self.Boolean
    def set_Boolean(self, Boolean): self.Boolean = Boolean
    BooleanProp = property(get_Boolean, set_Boolean)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.Boolean is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='Boolean_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Boolean_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='Boolean_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='Boolean_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='Boolean_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Boolean is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBoolean>%s</%sBoolean>%s' % (namespace_, self.gds_format_boolean(self.Boolean, input_name='Boolean'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Boolean':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Boolean')
            self.Boolean = ival_
# end class Boolean_PropertyType


class Real_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Real=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.Real = Real
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Real_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Real_PropertyType.subclass:
            return Real_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Real_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Real(self): return self.Real
    def set_Real(self, Real): self.Real = Real
    RealProp = property(get_Real, set_Real)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.Real is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='Real_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Real_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='Real_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='Real_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='Real_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Real is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReal>%s</%sReal>%s' % (namespace_, self.gds_format_double(self.Real, input_name='Real'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Real':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Real')
            self.Real = fval_
# end class Real_PropertyType


class Date_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Date=None, DateTime=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.Date = Date
        if isinstance(DateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DateTime
        self.DateTime = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Date_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Date_PropertyType.subclass:
            return Date_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Date_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    DateProp = property(get_Date, set_Date)
    def get_DateTime(self): return self.DateTime
    def set_DateTime(self, DateTime): self.DateTime = DateTime
    DateTimeProp = property(get_DateTime, set_DateTime)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.Date is not None or
            self.DateTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='Date_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Date_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='Date_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='Date_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='Date_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDate>%s</%sDate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Date), input_name='Date')), namespace_, eol_))
        if self.DateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateTime>%s</%sDateTime>%s' % (namespace_, self.gds_format_datetime(self.DateTime, input_name='DateTime'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Date':
            Date_ = child_.text
            Date_ = self.gds_validate_string(Date_, node, 'Date')
            self.Date = Date_
        elif nodeName_ == 'DateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DateTime = dval_
# end class Date_PropertyType


class CodeListValue_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, codeList=None, codeListValue=None, codeSpace=None, valueOf_=None):
        self.original_tagname_ = None
        self.codeList = _cast(None, codeList)
        self.codeListValue = _cast(None, codeListValue)
        self.codeSpace = _cast(None, codeSpace)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeListValue_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeListValue_Type.subclass:
            return CodeListValue_Type.subclass(*args_, **kwargs_)
        else:
            return CodeListValue_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeList(self): return self.codeList
    def set_codeList(self, codeList): self.codeList = codeList
    codeListProp = property(get_codeList, set_codeList)
    def get_codeListValue(self): return self.codeListValue
    def set_codeListValue(self, codeListValue): self.codeListValue = codeListValue
    codeListValueProp = property(get_codeListValue, set_codeListValue)
    def get_codeSpace(self): return self.codeSpace
    def set_codeSpace(self, codeSpace): self.codeSpace = codeSpace
    codeSpaceProp = property(get_codeSpace, set_codeSpace)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CodeListValue_Type', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeListValue_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CodeListValue_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CodeListValue_Type'):
        if self.codeList is not None and 'codeList' not in already_processed:
            already_processed.add('codeList')
            outfile.write(' codeList=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeList), input_name='codeList')), ))
        if self.codeListValue is not None and 'codeListValue' not in already_processed:
            already_processed.add('codeListValue')
            outfile.write(' codeListValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeListValue), input_name='codeListValue')), ))
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.add('codeSpace')
            outfile.write(' codeSpace=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSpace), input_name='codeSpace')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CodeListValue_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeList', node)
        if value is not None and 'codeList' not in already_processed:
            already_processed.add('codeList')
            self.codeList = value
        value = find_attr_value_('codeListValue', node)
        if value is not None and 'codeListValue' not in already_processed:
            already_processed.add('codeListValue')
            self.codeListValue = value
        value = find_attr_value_('codeSpace', node)
        if value is not None and 'codeSpace' not in already_processed:
            already_processed.add('codeSpace')
            self.codeSpace = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CodeListValue_Type


class DateTime_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DateTime=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        if isinstance(DateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DateTime
        self.DateTime = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateTime_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateTime_PropertyType.subclass:
            return DateTime_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DateTime_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DateTime(self): return self.DateTime
    def set_DateTime(self, DateTime): self.DateTime = DateTime
    DateTimeProp = property(get_DateTime, set_DateTime)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def hasContent_(self):
        if (
            self.DateTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DateTime_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateTime_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DateTime_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DateTime_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DateTime_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateTime>%s</%sDateTime>%s' % (namespace_, self.gds_format_datetime(self.DateTime, input_name='DateTime'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DateTime = dval_
# end class DateTime_PropertyType


class SC_CRS_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, uuidref=None, AbstractCRS=None):
        self.original_tagname_ = None
        self.nilReason = _cast(None, nilReason)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.uuidref = _cast(None, uuidref)
        self.AbstractCRS = AbstractCRS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SC_CRS_PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SC_CRS_PropertyType.subclass:
            return SC_CRS_PropertyType.subclass(*args_, **kwargs_)
        else:
            return SC_CRS_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractCRS(self): return self.AbstractCRS
    def set_AbstractCRS(self, AbstractCRS): self.AbstractCRS = AbstractCRS
    AbstractCRSProp = property(get_AbstractCRS, set_AbstractCRS)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    nilReasonProp = property(get_nilReason, set_nilReason)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    hrefProp = property(get_href, set_href)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    arcroleProp = property(get_arcrole, set_arcrole)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    showProp = property(get_show, set_show)
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    actuateProp = property(get_actuate, set_actuate)
    def get_uuidref(self): return self.uuidref
    def set_uuidref(self, uuidref): self.uuidref = uuidref
    uuidrefProp = property(get_uuidref, set_uuidref)
    def hasContent_(self):
        if (
            self.AbstractCRS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='SC_CRS_PropertyType', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SC_CRS_PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='SC_CRS_PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='SC_CRS_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.uuidref is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            outfile.write(' uuidref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuidref), input_name='uuidref')), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='SC_CRS_PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AbstractCRS is not None:
            self.AbstractCRS.export(outfile, level, namespace_, name_='AbstractCRS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.add('nilReason')
            self.nilReason = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('uuidref', node)
        if value is not None and 'uuidref' not in already_processed:
            already_processed.add('uuidref')
            self.uuidref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractCRS':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractCRS> element')
            self.AbstractCRS = obj_
            obj_.original_tagname_ = 'AbstractCRS'
        elif nodeName_ == 'AbstractSingleCRS':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractSingleCRS> element')
            self.AbstractCRS = obj_
            obj_.original_tagname_ = 'AbstractSingleCRS'
        elif nodeName_ == 'GeodeticCRS':
            obj_ = GeodeticCRSType.factory()
            obj_.build(child_)
            self.AbstractSingleCRS = obj_
            obj_.original_tagname_ = 'GeodeticCRS'
        elif nodeName_ == 'AbstractGeneralDerivedCRS':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeneralDerivedCRS> element')
            self.AbstractSingleCRS = obj_
            obj_.original_tagname_ = 'AbstractGeneralDerivedCRS'
        elif nodeName_ == 'VerticalCRS':
            obj_ = VerticalCRSType.factory()
            obj_.build(child_)
            self.AbstractSingleCRS = obj_
            obj_.original_tagname_ = 'VerticalCRS'
        elif nodeName_ == 'ProjectedCRS':
            obj_ = ProjectedCRSType.factory()
            obj_.build(child_)
            self.AbstractGeneralDerivedCRS = obj_
            obj_.original_tagname_ = 'ProjectedCRS'
# end class SC_CRS_PropertyType


class DataObjectReference(GeneratedsSuper):
    """It only applies for Energistics data object."""
    subclass = None
    superclass = None
    def __init__(self, ContentType=None, Title=None, Uuid=None, UuidAuthority=None, Uri=None, VersionString=None):
        self.original_tagname_ = None
        self.ContentType = ContentType
        self.validate_String2000(self.ContentType)
        self.Title = Title
        self.validate_String2000(self.Title)
        self.Uuid = Uuid
        self.validate_UuidString(self.Uuid)
        self.UuidAuthority = UuidAuthority
        self.validate_String64(self.UuidAuthority)
        self.Uri = Uri
        self.VersionString = VersionString
        self.validate_String64(self.VersionString)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataObjectReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataObjectReference.subclass:
            return DataObjectReference.subclass(*args_, **kwargs_)
        else:
            return DataObjectReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContentType(self): return self.ContentType
    def set_ContentType(self, ContentType): self.ContentType = ContentType
    ContentTypeProp = property(get_ContentType, set_ContentType)
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    TitleProp = property(get_Title, set_Title)
    def get_Uuid(self): return self.Uuid
    def set_Uuid(self, Uuid): self.Uuid = Uuid
    UuidProp = property(get_Uuid, set_Uuid)
    def get_UuidAuthority(self): return self.UuidAuthority
    def set_UuidAuthority(self, UuidAuthority): self.UuidAuthority = UuidAuthority
    UuidAuthorityProp = property(get_UuidAuthority, set_UuidAuthority)
    def get_Uri(self): return self.Uri
    def set_Uri(self, Uri): self.Uri = Uri
    UriProp = property(get_Uri, set_Uri)
    def get_VersionString(self): return self.VersionString
    def set_VersionString(self, VersionString): self.VersionString = VersionString
    VersionStringProp = property(get_VersionString, set_VersionString)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def validate_UuidString(self, value):
        # Validate type UuidString, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_UuidString_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_UuidString_patterns_, ))
    validate_UuidString_patterns_ = [['^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$']]
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.ContentType is not None or
            self.Title is not None or
            self.Uuid is not None or
            self.UuidAuthority is not None or
            self.Uri is not None or
            self.VersionString is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DataObjectReference', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataObjectReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DataObjectReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DataObjectReference'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DataObjectReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContentType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContentType>%s</%sContentType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ContentType), input_name='ContentType')), namespace_, eol_))
        if self.Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Title), input_name='Title')), namespace_, eol_))
        if self.Uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUuid>%s</%sUuid>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Uuid), input_name='Uuid')), namespace_, eol_))
        if self.UuidAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUuidAuthority>%s</%sUuidAuthority>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UuidAuthority), input_name='UuidAuthority')), namespace_, eol_))
        if self.Uri is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUri>%s</%sUri>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Uri), input_name='Uri')), namespace_, eol_))
        if self.VersionString is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersionString>%s</%sVersionString>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.VersionString), input_name='VersionString')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContentType':
            ContentType_ = child_.text
            ContentType_ = self.gds_validate_string(ContentType_, node, 'ContentType')
            self.ContentType = ContentType_
            # validate type String2000
            self.validate_String2000(self.ContentType)
        elif nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
            # validate type String2000
            self.validate_String2000(self.Title)
        elif nodeName_ == 'Uuid':
            Uuid_ = child_.text
            Uuid_ = self.gds_validate_string(Uuid_, node, 'Uuid')
            self.Uuid = Uuid_
            # validate type UuidString
            self.validate_UuidString(self.Uuid)
        elif nodeName_ == 'UuidAuthority':
            UuidAuthority_ = child_.text
            UuidAuthority_ = self.gds_validate_string(UuidAuthority_, node, 'UuidAuthority')
            self.UuidAuthority = UuidAuthority_
            # validate type String64
            self.validate_String64(self.UuidAuthority)
        elif nodeName_ == 'Uri':
            Uri_ = child_.text
            Uri_ = self.gds_validate_string(Uri_, node, 'Uri')
            self.Uri = Uri_
        elif nodeName_ == 'VersionString':
            VersionString_ = child_.text
            VersionString_ = self.gds_validate_string(VersionString_, node, 'VersionString')
            self.VersionString = VersionString_
            # validate type String64
            self.validate_String64(self.VersionString)
# end class DataObjectReference


class EpcExternalPartReference(AbstractObject):
    """It defines a proxy for external part of the EPC package. It must be
    used at least for external HDF parts. Each
    EpcExternalPartReference represents a single operating system
    file"""
    subclass = None
    superclass = AbstractObject
    def __init__(self, Filename=None, MimeType=None):
        self.original_tagname_ = None
        super(EpcExternalPartReference, self).__init__()
        self.Filename = Filename
        self.validate_String2000(self.Filename)
        self.MimeType = MimeType
        self.validate_String2000(self.MimeType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EpcExternalPartReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EpcExternalPartReference.subclass:
            return EpcExternalPartReference.subclass(*args_, **kwargs_)
        else:
            return EpcExternalPartReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Filename(self): return self.Filename
    def set_Filename(self, Filename): self.Filename = Filename
    FilenameProp = property(get_Filename, set_Filename)
    def get_MimeType(self): return self.MimeType
    def set_MimeType(self, MimeType): self.MimeType = MimeType
    MimeTypeProp = property(get_MimeType, set_MimeType)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Filename is not None or
            self.MimeType is not None or
            super(EpcExternalPartReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EpcExternalPartReference', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EpcExternalPartReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EpcExternalPartReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EpcExternalPartReference'):
        super(EpcExternalPartReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EpcExternalPartReference')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EpcExternalPartReference', fromsubclass_=False, pretty_print=True):
        super(EpcExternalPartReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Filename is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFilename>%s</%sFilename>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Filename), input_name='Filename')), namespace_, eol_))
        if self.MimeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMimeType>%s</%sMimeType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MimeType), input_name='MimeType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EpcExternalPartReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Filename':
            Filename_ = child_.text
            Filename_ = self.gds_validate_string(Filename_, node, 'Filename')
            self.Filename = Filename_
            # validate type String2000
            self.validate_String2000(self.Filename)
        elif nodeName_ == 'MimeType':
            MimeType_ = child_.text
            MimeType_ = self.gds_validate_string(MimeType_, node, 'MimeType')
            self.MimeType = MimeType_
            # validate type String2000
            self.validate_String2000(self.MimeType)
        super(EpcExternalPartReference, self).buildChildren(child_, node, nodeName_, True)
# end class EpcExternalPartReference


class ExternalDataset(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ExternalFileProxy=None):
        self.original_tagname_ = None
        if ExternalFileProxy is None:
            self.ExternalFileProxy = []
        else:
            self.ExternalFileProxy = ExternalFileProxy
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalDataset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalDataset.subclass:
            return ExternalDataset.subclass(*args_, **kwargs_)
        else:
            return ExternalDataset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalFileProxy(self): return self.ExternalFileProxy
    def set_ExternalFileProxy(self, ExternalFileProxy): self.ExternalFileProxy = ExternalFileProxy
    def add_ExternalFileProxy(self, value): self.ExternalFileProxy.append(value)
    def insert_ExternalFileProxy_at(self, index, value): self.ExternalFileProxy.insert(index, value)
    def replace_ExternalFileProxy_at(self, index, value): self.ExternalFileProxy[index] = value
    ExternalFileProxyProp = property(get_ExternalFileProxy, set_ExternalFileProxy)
    def hasContent_(self):
        if (
            self.ExternalFileProxy
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ExternalDataset', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExternalDataset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ExternalDataset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ExternalDataset'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ExternalDataset', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ExternalFileProxy_ in self.ExternalFileProxy:
            ExternalFileProxy_.export(outfile, level, namespace_, name_='ExternalFileProxy', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalFileProxy':
            class_obj_ = self.get_class_obj_(child_, ExternalDatasetPart)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ExternalFileProxy.append(obj_)
            obj_.original_tagname_ = 'ExternalFileProxy'
# end class ExternalDataset


class ExternalDatasetPart(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Count=None, PathInExternalFile=None, StartIndex=None, EpcExternalPartReference=None, extensiontype_=None):
        self.original_tagname_ = None
        self.Count = Count
        self.validate_PositiveLong(self.Count)
        self.PathInExternalFile = PathInExternalFile
        self.validate_String2000(self.PathInExternalFile)
        self.StartIndex = StartIndex
        self.validate_NonNegativeLong(self.StartIndex)
        self.EpcExternalPartReference = EpcExternalPartReference
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalDatasetPart)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalDatasetPart.subclass:
            return ExternalDatasetPart.subclass(*args_, **kwargs_)
        else:
            return ExternalDatasetPart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Count(self): return self.Count
    def set_Count(self, Count): self.Count = Count
    CountProp = property(get_Count, set_Count)
    def get_PathInExternalFile(self): return self.PathInExternalFile
    def set_PathInExternalFile(self, PathInExternalFile): self.PathInExternalFile = PathInExternalFile
    PathInExternalFileProp = property(get_PathInExternalFile, set_PathInExternalFile)
    def get_StartIndex(self): return self.StartIndex
    def set_StartIndex(self, StartIndex): self.StartIndex = StartIndex
    StartIndexProp = property(get_StartIndex, set_StartIndex)
    def get_EpcExternalPartReference(self): return self.EpcExternalPartReference
    def set_EpcExternalPartReference(self, EpcExternalPartReference): self.EpcExternalPartReference = EpcExternalPartReference
    EpcExternalPartReferenceProp = property(get_EpcExternalPartReference, set_EpcExternalPartReference)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_PositiveLong(self, value):
        # Validate type PositiveLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveLong' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def validate_NonNegativeLong(self, value):
        # Validate type NonNegativeLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeLong' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Count is not None or
            self.PathInExternalFile is not None or
            self.StartIndex is not None or
            self.EpcExternalPartReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ExternalDatasetPart', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExternalDatasetPart')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ExternalDatasetPart', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ExternalDatasetPart'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ExternalDatasetPart', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCount>%s</%sCount>%s' % (namespace_, self.gds_format_integer(self.Count, input_name='Count'), namespace_, eol_))
        if self.PathInExternalFile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPathInExternalFile>%s</%sPathInExternalFile>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PathInExternalFile), input_name='PathInExternalFile')), namespace_, eol_))
        if self.StartIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartIndex>%s</%sStartIndex>%s' % (namespace_, self.gds_format_integer(self.StartIndex, input_name='StartIndex'), namespace_, eol_))
        if self.EpcExternalPartReference is not None:
            self.EpcExternalPartReference.export(outfile, level, namespace_, name_='EpcExternalPartReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Count')
            self.Count = ival_
            # validate type PositiveLong
            self.validate_PositiveLong(self.Count)
        elif nodeName_ == 'PathInExternalFile':
            PathInExternalFile_ = child_.text
            PathInExternalFile_ = self.gds_validate_string(PathInExternalFile_, node, 'PathInExternalFile')
            self.PathInExternalFile = PathInExternalFile_
            # validate type String2000
            self.validate_String2000(self.PathInExternalFile)
        elif nodeName_ == 'StartIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StartIndex')
            self.StartIndex = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.StartIndex)
        elif nodeName_ == 'EpcExternalPartReference':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.EpcExternalPartReference = obj_
            obj_.original_tagname_ = 'EpcExternalPartReference'
# end class ExternalDatasetPart


class AbstractActivityParameter(GeneratedsSuper):
    """General parameter value used in one instance of activity"""
    subclass = None
    superclass = None
    def __init__(self, Title=None, Index=None, Selection=None, Key=None, extensiontype_=None):
        self.original_tagname_ = None
        self.Title = Title
        self.validate_String2000(self.Title)
        self.Index = Index
        self.Selection = Selection
        self.validate_String2000(self.Selection)
        if Key is None:
            self.Key = []
        else:
            self.Key = Key
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractActivityParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractActivityParameter.subclass:
            return AbstractActivityParameter.subclass(*args_, **kwargs_)
        else:
            return AbstractActivityParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    TitleProp = property(get_Title, set_Title)
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    IndexProp = property(get_Index, set_Index)
    def get_Selection(self): return self.Selection
    def set_Selection(self, Selection): self.Selection = Selection
    SelectionProp = property(get_Selection, set_Selection)
    def get_Key(self): return self.Key
    def set_Key(self, Key): self.Key = Key
    def add_Key(self, value): self.Key.append(value)
    def insert_Key_at(self, index, value): self.Key.insert(index, value)
    def replace_Key_at(self, index, value): self.Key[index] = value
    KeyProp = property(get_Key, set_Key)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Title is not None or
            self.Index is not None or
            self.Selection is not None or
            self.Key
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractActivityParameter', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractActivityParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractActivityParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractActivityParameter'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractActivityParameter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Title), input_name='Title')), namespace_, eol_))
        if self.Index is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndex>%s</%sIndex>%s' % (namespace_, self.gds_format_integer(self.Index, input_name='Index'), namespace_, eol_))
        if self.Selection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSelection>%s</%sSelection>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Selection), input_name='Selection')), namespace_, eol_))
        for Key_ in self.Key:
            Key_.export(outfile, level, namespace_, name_='Key', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
            # validate type String2000
            self.validate_String2000(self.Title)
        elif nodeName_ == 'Index':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Index')
            self.Index = ival_
        elif nodeName_ == 'Selection':
            Selection_ = child_.text
            Selection_ = self.gds_validate_string(Selection_, node, 'Selection')
            self.Selection = Selection_
            # validate type String2000
            self.validate_String2000(self.Selection)
        elif nodeName_ == 'Key':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Key> element')
            self.Key.append(obj_)
            obj_.original_tagname_ = 'Key'
# end class AbstractActivityParameter


class AbstractParameterKey(GeneratedsSuper):
    """Abstract class describing a key used to identify a parameter value.
    When multiple values are provided for a given parameter,
    provides a way to identify the parameter through its association
    with an object, a time index..."""
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractParameterKey)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractParameterKey.subclass:
            return AbstractParameterKey.subclass(*args_, **kwargs_)
        else:
            return AbstractParameterKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractParameterKey', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractParameterKey')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractParameterKey', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractParameterKey'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractParameterKey', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractParameterKey


class Activity(AbstractObject):
    """Instance of a given activity"""
    subclass = None
    superclass = AbstractObject
    def __init__(self, ActivityDescriptor=None, Parent=None, Parameter=None):
        self.original_tagname_ = None
        super(Activity, self).__init__()
        self.ActivityDescriptor = ActivityDescriptor
        self.Parent = Parent
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Activity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Activity.subclass:
            return Activity.subclass(*args_, **kwargs_)
        else:
            return Activity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActivityDescriptor(self): return self.ActivityDescriptor
    def set_ActivityDescriptor(self, ActivityDescriptor): self.ActivityDescriptor = ActivityDescriptor
    ActivityDescriptorProp = property(get_ActivityDescriptor, set_ActivityDescriptor)
    def get_Parent(self): return self.Parent
    def set_Parent(self, Parent): self.Parent = Parent
    ParentProp = property(get_Parent, set_Parent)
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    def add_Parameter(self, value): self.Parameter.append(value)
    def insert_Parameter_at(self, index, value): self.Parameter.insert(index, value)
    def replace_Parameter_at(self, index, value): self.Parameter[index] = value
    ParameterProp = property(get_Parameter, set_Parameter)
    def hasContent_(self):
        if (
            self.ActivityDescriptor is not None or
            self.Parent is not None or
            self.Parameter or
            super(Activity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='Activity', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Activity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='Activity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='Activity'):
        super(Activity, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Activity')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='Activity', fromsubclass_=False, pretty_print=True):
        super(Activity, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActivityDescriptor is not None:
            self.ActivityDescriptor.export(outfile, level, namespace_, name_='ActivityDescriptor', pretty_print=pretty_print)
        if self.Parent is not None:
            self.Parent.export(outfile, level, namespace_, name_='Parent', pretty_print=pretty_print)
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, namespace_, name_='Parameter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Activity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActivityDescriptor':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.ActivityDescriptor = obj_
            obj_.original_tagname_ = 'ActivityDescriptor'
        elif nodeName_ == 'Parent':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.Parent = obj_
            obj_.original_tagname_ = 'Parent'
        elif nodeName_ == 'Parameter':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Parameter> element')
            self.Parameter.append(obj_)
            obj_.original_tagname_ = 'Parameter'
        super(Activity, self).buildChildren(child_, node, nodeName_, True)
# end class Activity


class ActivityTemplate(AbstractObject):
    """Description of one type of activity."""
    subclass = None
    superclass = AbstractObject
    def __init__(self, Parameter=None):
        self.original_tagname_ = None
        super(ActivityTemplate, self).__init__()
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActivityTemplate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActivityTemplate.subclass:
            return ActivityTemplate.subclass(*args_, **kwargs_)
        else:
            return ActivityTemplate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    def add_Parameter(self, value): self.Parameter.append(value)
    def insert_Parameter_at(self, index, value): self.Parameter.insert(index, value)
    def replace_Parameter_at(self, index, value): self.Parameter[index] = value
    ParameterProp = property(get_Parameter, set_Parameter)
    def hasContent_(self):
        if (
            self.Parameter or
            super(ActivityTemplate, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ActivityTemplate', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActivityTemplate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ActivityTemplate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ActivityTemplate'):
        super(ActivityTemplate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActivityTemplate')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ActivityTemplate', fromsubclass_=False, pretty_print=True):
        super(ActivityTemplate, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, namespace_, name_='Parameter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ActivityTemplate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Parameter':
            obj_ = ParameterTemplate.factory()
            obj_.build(child_)
            self.Parameter.append(obj_)
            obj_.original_tagname_ = 'Parameter'
        super(ActivityTemplate, self).buildChildren(child_, node, nodeName_, True)
# end class ActivityTemplate


class DataObjectParameter(AbstractActivityParameter):
    """Parameter referencing to a top level object."""
    subclass = None
    superclass = AbstractActivityParameter
    def __init__(self, Title=None, Index=None, Selection=None, Key=None, DataObject=None):
        self.original_tagname_ = None
        super(DataObjectParameter, self).__init__(Title, Index, Selection, Key, )
        self.DataObject = DataObject
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataObjectParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataObjectParameter.subclass:
            return DataObjectParameter.subclass(*args_, **kwargs_)
        else:
            return DataObjectParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataObject(self): return self.DataObject
    def set_DataObject(self, DataObject): self.DataObject = DataObject
    DataObjectProp = property(get_DataObject, set_DataObject)
    def hasContent_(self):
        if (
            self.DataObject is not None or
            super(DataObjectParameter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DataObjectParameter', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataObjectParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DataObjectParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DataObjectParameter'):
        super(DataObjectParameter, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DataObjectParameter')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DataObjectParameter', fromsubclass_=False, pretty_print=True):
        super(DataObjectParameter, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DataObject is not None:
            self.DataObject.export(outfile, level, namespace_, name_='DataObject', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DataObjectParameter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataObject':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.DataObject = obj_
            obj_.original_tagname_ = 'DataObject'
        super(DataObjectParameter, self).buildChildren(child_, node, nodeName_, True)
# end class DataObjectParameter


class DoubleQuantityParameter(AbstractActivityParameter):
    """Parameter containing a double value."""
    subclass = None
    superclass = AbstractActivityParameter
    def __init__(self, Title=None, Index=None, Selection=None, Key=None, Value=None, Uom=None, CustomUnitDictionary=None):
        self.original_tagname_ = None
        super(DoubleQuantityParameter, self).__init__(Title, Index, Selection, Key, )
        self.Value = Value
        self.Uom = Uom
        self.validate_UnitOfMeasureExt(self.Uom)
        self.CustomUnitDictionary = CustomUnitDictionary
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DoubleQuantityParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DoubleQuantityParameter.subclass:
            return DoubleQuantityParameter.subclass(*args_, **kwargs_)
        else:
            return DoubleQuantityParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    ValueProp = property(get_Value, set_Value)
    def get_Uom(self): return self.Uom
    def set_Uom(self, Uom): self.Uom = Uom
    UomProp = property(get_Uom, set_Uom)
    def get_CustomUnitDictionary(self): return self.CustomUnitDictionary
    def set_CustomUnitDictionary(self, CustomUnitDictionary): self.CustomUnitDictionary = CustomUnitDictionary
    CustomUnitDictionaryProp = property(get_CustomUnitDictionary, set_CustomUnitDictionary)
    def validate_UnitOfMeasureExt(self, value):
        # Validate type UnitOfMeasureExt, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Value is not None or
            self.Uom is not None or
            self.CustomUnitDictionary is not None or
            super(DoubleQuantityParameter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DoubleQuantityParameter', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DoubleQuantityParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DoubleQuantityParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DoubleQuantityParameter'):
        super(DoubleQuantityParameter, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DoubleQuantityParameter')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DoubleQuantityParameter', fromsubclass_=False, pretty_print=True):
        super(DoubleQuantityParameter, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_double(self.Value, input_name='Value'), namespace_, eol_))
        if self.Uom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUom>%s</%sUom>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Uom), input_name='Uom')), namespace_, eol_))
        if self.CustomUnitDictionary is not None:
            self.CustomUnitDictionary.export(outfile, level, namespace_, name_='CustomUnitDictionary', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DoubleQuantityParameter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Value')
            self.Value = fval_
        elif nodeName_ == 'Uom':
            Uom_ = child_.text
            Uom_ = self.gds_validate_string(Uom_, node, 'Uom')
            self.Uom = Uom_
            # validate type UnitOfMeasureExt
            self.validate_UnitOfMeasureExt(self.Uom)
        elif nodeName_ == 'CustomUnitDictionary':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.CustomUnitDictionary = obj_
            obj_.original_tagname_ = 'CustomUnitDictionary'
        super(DoubleQuantityParameter, self).buildChildren(child_, node, nodeName_, True)
# end class DoubleQuantityParameter


class IntegerQuantityParameter(AbstractActivityParameter):
    """Parameter containing an integer value."""
    subclass = None
    superclass = AbstractActivityParameter
    def __init__(self, Title=None, Index=None, Selection=None, Key=None, Value=None):
        self.original_tagname_ = None
        super(IntegerQuantityParameter, self).__init__(Title, Index, Selection, Key, )
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntegerQuantityParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntegerQuantityParameter.subclass:
            return IntegerQuantityParameter.subclass(*args_, **kwargs_)
        else:
            return IntegerQuantityParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    ValueProp = property(get_Value, set_Value)
    def hasContent_(self):
        if (
            self.Value is not None or
            super(IntegerQuantityParameter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='IntegerQuantityParameter', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerQuantityParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='IntegerQuantityParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='IntegerQuantityParameter'):
        super(IntegerQuantityParameter, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerQuantityParameter')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='IntegerQuantityParameter', fromsubclass_=False, pretty_print=True):
        super(IntegerQuantityParameter, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_integer(self.Value, input_name='Value'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IntegerQuantityParameter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Value')
            self.Value = ival_
        super(IntegerQuantityParameter, self).buildChildren(child_, node, nodeName_, True)
# end class IntegerQuantityParameter


class ObjectParameterKey(AbstractParameterKey):
    subclass = None
    superclass = AbstractParameterKey
    def __init__(self, DataObject=None):
        self.original_tagname_ = None
        super(ObjectParameterKey, self).__init__()
        self.DataObject = DataObject
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObjectParameterKey)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObjectParameterKey.subclass:
            return ObjectParameterKey.subclass(*args_, **kwargs_)
        else:
            return ObjectParameterKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataObject(self): return self.DataObject
    def set_DataObject(self, DataObject): self.DataObject = DataObject
    DataObjectProp = property(get_DataObject, set_DataObject)
    def hasContent_(self):
        if (
            self.DataObject is not None or
            super(ObjectParameterKey, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ObjectParameterKey', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectParameterKey')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ObjectParameterKey', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ObjectParameterKey'):
        super(ObjectParameterKey, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectParameterKey')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ObjectParameterKey', fromsubclass_=False, pretty_print=True):
        super(ObjectParameterKey, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DataObject is not None:
            self.DataObject.export(outfile, level, namespace_, name_='DataObject', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ObjectParameterKey, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataObject':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.DataObject = obj_
            obj_.original_tagname_ = 'DataObject'
        super(ObjectParameterKey, self).buildChildren(child_, node, nodeName_, True)
# end class ObjectParameterKey


class ParameterTemplate(GeneratedsSuper):
    """Description of one parameter that participate in one type of
    activity."""
    subclass = None
    superclass = None
    def __init__(self, AllowedKind=None, IsInput=None, KeyConstraint=None, IsOutput=None, Title=None, DataObjectContentType=None, MaxOccurs=None, MinOccurs=None, Constraint=None, DefaultValue=None):
        self.original_tagname_ = None
        if AllowedKind is None:
            self.AllowedKind = []
        else:
            self.AllowedKind = AllowedKind
        self.IsInput = IsInput
        if KeyConstraint is None:
            self.KeyConstraint = []
        else:
            self.KeyConstraint = KeyConstraint
        self.IsOutput = IsOutput
        self.Title = Title
        self.validate_String2000(self.Title)
        self.DataObjectContentType = DataObjectContentType
        self.validate_String2000(self.DataObjectContentType)
        self.MaxOccurs = MaxOccurs
        self.MinOccurs = MinOccurs
        self.Constraint = Constraint
        self.validate_String2000(self.Constraint)
        if DefaultValue is None:
            self.DefaultValue = []
        else:
            self.DefaultValue = DefaultValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterTemplate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterTemplate.subclass:
            return ParameterTemplate.subclass(*args_, **kwargs_)
        else:
            return ParameterTemplate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AllowedKind(self): return self.AllowedKind
    def set_AllowedKind(self, AllowedKind): self.AllowedKind = AllowedKind
    def add_AllowedKind(self, value): self.AllowedKind.append(value)
    def insert_AllowedKind_at(self, index, value): self.AllowedKind.insert(index, value)
    def replace_AllowedKind_at(self, index, value): self.AllowedKind[index] = value
    AllowedKindProp = property(get_AllowedKind, set_AllowedKind)
    def get_IsInput(self): return self.IsInput
    def set_IsInput(self, IsInput): self.IsInput = IsInput
    IsInputProp = property(get_IsInput, set_IsInput)
    def get_KeyConstraint(self): return self.KeyConstraint
    def set_KeyConstraint(self, KeyConstraint): self.KeyConstraint = KeyConstraint
    def add_KeyConstraint(self, value): self.KeyConstraint.append(value)
    def insert_KeyConstraint_at(self, index, value): self.KeyConstraint.insert(index, value)
    def replace_KeyConstraint_at(self, index, value): self.KeyConstraint[index] = value
    KeyConstraintProp = property(get_KeyConstraint, set_KeyConstraint)
    def get_IsOutput(self): return self.IsOutput
    def set_IsOutput(self, IsOutput): self.IsOutput = IsOutput
    IsOutputProp = property(get_IsOutput, set_IsOutput)
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    TitleProp = property(get_Title, set_Title)
    def get_DataObjectContentType(self): return self.DataObjectContentType
    def set_DataObjectContentType(self, DataObjectContentType): self.DataObjectContentType = DataObjectContentType
    DataObjectContentTypeProp = property(get_DataObjectContentType, set_DataObjectContentType)
    def get_MaxOccurs(self): return self.MaxOccurs
    def set_MaxOccurs(self, MaxOccurs): self.MaxOccurs = MaxOccurs
    MaxOccursProp = property(get_MaxOccurs, set_MaxOccurs)
    def get_MinOccurs(self): return self.MinOccurs
    def set_MinOccurs(self, MinOccurs): self.MinOccurs = MinOccurs
    MinOccursProp = property(get_MinOccurs, set_MinOccurs)
    def get_Constraint(self): return self.Constraint
    def set_Constraint(self, Constraint): self.Constraint = Constraint
    ConstraintProp = property(get_Constraint, set_Constraint)
    def get_DefaultValue(self): return self.DefaultValue
    def set_DefaultValue(self, DefaultValue): self.DefaultValue = DefaultValue
    def add_DefaultValue(self, value): self.DefaultValue.append(value)
    def insert_DefaultValue_at(self, index, value): self.DefaultValue.insert(index, value)
    def replace_DefaultValue_at(self, index, value): self.DefaultValue[index] = value
    DefaultValueProp = property(get_DefaultValue, set_DefaultValue)
    def validate_ParameterKind(self, value):
        # Validate type ParameterKind, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['dataObject', 'double', 'integer', 'string', 'timestamp', 'subActivity']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ParameterKind' % {"value" : value.encode("utf-8")} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.AllowedKind or
            self.IsInput is not None or
            self.KeyConstraint or
            self.IsOutput is not None or
            self.Title is not None or
            self.DataObjectContentType is not None or
            self.MaxOccurs is not None or
            self.MinOccurs is not None or
            self.Constraint is not None or
            self.DefaultValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ParameterTemplate', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterTemplate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ParameterTemplate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ParameterTemplate'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ParameterTemplate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AllowedKind_ in self.AllowedKind:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllowedKind>%s</%sAllowedKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(AllowedKind_), input_name='AllowedKind')), namespace_, eol_))
        if self.IsInput is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsInput>%s</%sIsInput>%s' % (namespace_, self.gds_format_boolean(self.IsInput, input_name='IsInput'), namespace_, eol_))
        for KeyConstraint_ in self.KeyConstraint:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyConstraint>%s</%sKeyConstraint>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(KeyConstraint_), input_name='KeyConstraint')), namespace_, eol_))
        if self.IsOutput is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsOutput>%s</%sIsOutput>%s' % (namespace_, self.gds_format_boolean(self.IsOutput, input_name='IsOutput'), namespace_, eol_))
        if self.Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Title), input_name='Title')), namespace_, eol_))
        if self.DataObjectContentType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataObjectContentType>%s</%sDataObjectContentType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DataObjectContentType), input_name='DataObjectContentType')), namespace_, eol_))
        if self.MaxOccurs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxOccurs>%s</%sMaxOccurs>%s' % (namespace_, self.gds_format_integer(self.MaxOccurs, input_name='MaxOccurs'), namespace_, eol_))
        if self.MinOccurs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMinOccurs>%s</%sMinOccurs>%s' % (namespace_, self.gds_format_integer(self.MinOccurs, input_name='MinOccurs'), namespace_, eol_))
        if self.Constraint is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConstraint>%s</%sConstraint>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Constraint), input_name='Constraint')), namespace_, eol_))
        for DefaultValue_ in self.DefaultValue:
            DefaultValue_.export(outfile, level, namespace_, name_='DefaultValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AllowedKind':
            AllowedKind_ = child_.text
            AllowedKind_ = self.gds_validate_string(AllowedKind_, node, 'AllowedKind')
            self.AllowedKind.append(AllowedKind_)
            # validate type ParameterKind
            self.validate_ParameterKind(self.AllowedKind[-1])
        elif nodeName_ == 'IsInput':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsInput')
            self.IsInput = ival_
        elif nodeName_ == 'KeyConstraint':
            KeyConstraint_ = child_.text
            KeyConstraint_ = self.gds_validate_string(KeyConstraint_, node, 'KeyConstraint')
            self.KeyConstraint.append(KeyConstraint_)
            # validate type String2000
            self.validate_String2000(self.KeyConstraint[-1])
        elif nodeName_ == 'IsOutput':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsOutput')
            self.IsOutput = ival_
        elif nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
            # validate type String2000
            self.validate_String2000(self.Title)
        elif nodeName_ == 'DataObjectContentType':
            DataObjectContentType_ = child_.text
            DataObjectContentType_ = self.gds_validate_string(DataObjectContentType_, node, 'DataObjectContentType')
            self.DataObjectContentType = DataObjectContentType_
            # validate type String2000
            self.validate_String2000(self.DataObjectContentType)
        elif nodeName_ == 'MaxOccurs':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaxOccurs')
            self.MaxOccurs = ival_
        elif nodeName_ == 'MinOccurs':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MinOccurs')
            self.MinOccurs = ival_
        elif nodeName_ == 'Constraint':
            Constraint_ = child_.text
            Constraint_ = self.gds_validate_string(Constraint_, node, 'Constraint')
            self.Constraint = Constraint_
            # validate type String2000
            self.validate_String2000(self.Constraint)
        elif nodeName_ == 'DefaultValue':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <DefaultValue> element')
            self.DefaultValue.append(obj_)
            obj_.original_tagname_ = 'DefaultValue'
# end class ParameterTemplate


class StringParameter(AbstractActivityParameter):
    """Parameter containing a string value."""
    subclass = None
    superclass = AbstractActivityParameter
    def __init__(self, Title=None, Index=None, Selection=None, Key=None, Value=None):
        self.original_tagname_ = None
        super(StringParameter, self).__init__(Title, Index, Selection, Key, )
        self.Value = Value
        self.validate_String2000(self.Value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringParameter.subclass:
            return StringParameter.subclass(*args_, **kwargs_)
        else:
            return StringParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    ValueProp = property(get_Value, set_Value)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Value is not None or
            super(StringParameter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='StringParameter', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StringParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='StringParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='StringParameter'):
        super(StringParameter, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StringParameter')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='StringParameter', fromsubclass_=False, pretty_print=True):
        super(StringParameter, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StringParameter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
            # validate type String2000
            self.validate_String2000(self.Value)
        super(StringParameter, self).buildChildren(child_, node, nodeName_, True)
# end class StringParameter


class TimeIndexParameter(AbstractActivityParameter):
    """Parameter containing a time index value."""
    subclass = None
    superclass = AbstractActivityParameter
    def __init__(self, Title=None, Index=None, Selection=None, Key=None, TimeIndex=None):
        self.original_tagname_ = None
        super(TimeIndexParameter, self).__init__(Title, Index, Selection, Key, )
        self.TimeIndex = TimeIndex
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeIndexParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeIndexParameter.subclass:
            return TimeIndexParameter.subclass(*args_, **kwargs_)
        else:
            return TimeIndexParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeIndex(self): return self.TimeIndex
    def set_TimeIndex(self, TimeIndex): self.TimeIndex = TimeIndex
    TimeIndexProp = property(get_TimeIndex, set_TimeIndex)
    def hasContent_(self):
        if (
            self.TimeIndex is not None or
            super(TimeIndexParameter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimeIndexParameter', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeIndexParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimeIndexParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimeIndexParameter'):
        super(TimeIndexParameter, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeIndexParameter')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimeIndexParameter', fromsubclass_=False, pretty_print=True):
        super(TimeIndexParameter, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TimeIndex is not None:
            self.TimeIndex.export(outfile, level, namespace_, name_='TimeIndex', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeIndexParameter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeIndex':
            obj_ = TimeIndex.factory()
            obj_.build(child_)
            self.TimeIndex = obj_
            obj_.original_tagname_ = 'TimeIndex'
        super(TimeIndexParameter, self).buildChildren(child_, node, nodeName_, True)
# end class TimeIndexParameter


class TimeIndexParameterKey(AbstractParameterKey):
    subclass = None
    superclass = AbstractParameterKey
    def __init__(self, TimeIndex=None):
        self.original_tagname_ = None
        super(TimeIndexParameterKey, self).__init__()
        self.TimeIndex = TimeIndex
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeIndexParameterKey)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeIndexParameterKey.subclass:
            return TimeIndexParameterKey.subclass(*args_, **kwargs_)
        else:
            return TimeIndexParameterKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeIndex(self): return self.TimeIndex
    def set_TimeIndex(self, TimeIndex): self.TimeIndex = TimeIndex
    TimeIndexProp = property(get_TimeIndex, set_TimeIndex)
    def hasContent_(self):
        if (
            self.TimeIndex is not None or
            super(TimeIndexParameterKey, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimeIndexParameterKey', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeIndexParameterKey')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimeIndexParameterKey', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimeIndexParameterKey'):
        super(TimeIndexParameterKey, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeIndexParameterKey')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimeIndexParameterKey', fromsubclass_=False, pretty_print=True):
        super(TimeIndexParameterKey, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TimeIndex is not None:
            self.TimeIndex.export(outfile, level, namespace_, name_='TimeIndex', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeIndexParameterKey, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeIndex':
            obj_ = TimeIndex.factory()
            obj_.build(child_)
            self.TimeIndex = obj_
            obj_.original_tagname_ = 'TimeIndex'
        super(TimeIndexParameterKey, self).buildChildren(child_, node, nodeName_, True)
# end class TimeIndexParameterKey


class GeologicTime(GeneratedsSuper):
    """This class is used to represent a time at several scales: - A
    mandatory and precise DateTime used to characterize a TimeStep
    in a TimeSeries - An optional Age Offset (corresponding to a
    geological event occurrence) in years. This age offset must be
    positive when it represents a GeologicalEvent occurrence in the
    past. This Age Offset is not required to be positive, to allow
    for the case of simulating future geological events. When
    geological time is used to represent a geological event
    cccurrence, the DateTime must be set by the software writer at a
    date no earlier than 01/01/1950. Any DateTime (even the creation
    DateTime of the instance) can be set in this attribute field."""
    subclass = None
    superclass = None
    def __init__(self, AgeOffsetAttribute=None, DateTime=None):
        self.original_tagname_ = None
        self.AgeOffsetAttribute = AgeOffsetAttribute
        if isinstance(DateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DateTime
        self.DateTime = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeologicTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeologicTime.subclass:
            return GeologicTime.subclass(*args_, **kwargs_)
        else:
            return GeologicTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AgeOffsetAttribute(self): return self.AgeOffsetAttribute
    def set_AgeOffsetAttribute(self, AgeOffsetAttribute): self.AgeOffsetAttribute = AgeOffsetAttribute
    AgeOffsetAttributeProp = property(get_AgeOffsetAttribute, set_AgeOffsetAttribute)
    def get_DateTime(self): return self.DateTime
    def set_DateTime(self, DateTime): self.DateTime = DateTime
    DateTimeProp = property(get_DateTime, set_DateTime)
    def hasContent_(self):
        if (
            self.AgeOffsetAttribute is not None or
            self.DateTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeologicTime', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeologicTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeologicTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeologicTime'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeologicTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AgeOffsetAttribute is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgeOffsetAttribute>%s</%sAgeOffsetAttribute>%s' % (namespace_, self.gds_format_integer(self.AgeOffsetAttribute, input_name='AgeOffsetAttribute'), namespace_, eol_))
        if self.DateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateTime>%s</%sDateTime>%s' % (namespace_, self.gds_format_datetime(self.DateTime, input_name='DateTime'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AgeOffsetAttribute':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AgeOffsetAttribute')
            self.AgeOffsetAttribute = ival_
        elif nodeName_ == 'DateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DateTime = dval_
# end class GeologicTime


class PropertyKind(AbstractObject):
    """Property kinds carry the semantics of property values. They are used
    to identify if the values are, for example, representing
    porosity, length, stress tensor, etc. Energistics provides a
    list of standard property kind that represent the basis for the
    commonly used properties in the E&P subsurface workflow."""
    subclass = None
    superclass = AbstractObject
    def __init__(self, IsAbstract=None, DeprecationDate=None, QuantityClass=None, Parent=None):
        self.original_tagname_ = None
        super(PropertyKind, self).__init__()
        self.IsAbstract = IsAbstract
        self.DeprecationDate = DeprecationDate
        self.validate_TimeStamp(self.DeprecationDate)
        self.QuantityClass = QuantityClass
        self.validate_QuantityClassKindExt(self.QuantityClass)
        self.Parent = Parent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PropertyKind)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PropertyKind.subclass:
            return PropertyKind.subclass(*args_, **kwargs_)
        else:
            return PropertyKind(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsAbstract(self): return self.IsAbstract
    def set_IsAbstract(self, IsAbstract): self.IsAbstract = IsAbstract
    IsAbstractProp = property(get_IsAbstract, set_IsAbstract)
    def get_DeprecationDate(self): return self.DeprecationDate
    def set_DeprecationDate(self, DeprecationDate): self.DeprecationDate = DeprecationDate
    DeprecationDateProp = property(get_DeprecationDate, set_DeprecationDate)
    def get_QuantityClass(self): return self.QuantityClass
    def set_QuantityClass(self, QuantityClass): self.QuantityClass = QuantityClass
    QuantityClassProp = property(get_QuantityClass, set_QuantityClass)
    def get_Parent(self): return self.Parent
    def set_Parent(self, Parent): self.Parent = Parent
    ParentProp = property(get_Parent, set_Parent)
    def validate_TimeStamp(self, value):
        # Validate type TimeStamp, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TimeStamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TimeStamp_patterns_, ))
    validate_TimeStamp_patterns_ = [['^.+T.+[Z+\\-].*$']]
    def validate_QuantityClassKindExt(self, value):
        # Validate type QuantityClassKindExt, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.IsAbstract is not None or
            self.DeprecationDate is not None or
            self.QuantityClass is not None or
            self.Parent is not None or
            super(PropertyKind, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PropertyKind', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyKind')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PropertyKind', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PropertyKind'):
        super(PropertyKind, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyKind')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PropertyKind', fromsubclass_=False, pretty_print=True):
        super(PropertyKind, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsAbstract is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsAbstract>%s</%sIsAbstract>%s' % (namespace_, self.gds_format_boolean(self.IsAbstract, input_name='IsAbstract'), namespace_, eol_))
        if self.DeprecationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeprecationDate>%s</%sDeprecationDate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DeprecationDate), input_name='DeprecationDate')), namespace_, eol_))
        if self.QuantityClass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQuantityClass>%s</%sQuantityClass>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.QuantityClass), input_name='QuantityClass')), namespace_, eol_))
        if self.Parent is not None:
            self.Parent.export(outfile, level, namespace_, name_='Parent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PropertyKind, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsAbstract':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsAbstract')
            self.IsAbstract = ival_
        elif nodeName_ == 'DeprecationDate':
            DeprecationDate_ = child_.text
            DeprecationDate_ = self.gds_validate_string(DeprecationDate_, node, 'DeprecationDate')
            self.DeprecationDate = DeprecationDate_
            # validate type TimeStamp
            self.validate_TimeStamp(self.DeprecationDate)
        elif nodeName_ == 'QuantityClass':
            QuantityClass_ = child_.text
            QuantityClass_ = self.gds_validate_string(QuantityClass_, node, 'QuantityClass')
            self.QuantityClass = QuantityClass_
            # validate type QuantityClassKindExt
            self.validate_QuantityClassKindExt(self.QuantityClass)
        elif nodeName_ == 'Parent':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.Parent = obj_
            obj_.original_tagname_ = 'Parent'
        super(PropertyKind, self).buildChildren(child_, node, nodeName_, True)
# end class PropertyKind


class PropertyKindDictionary(AbstractObject):
    """This dictionary defines property kind which is intended to handle
    the requirements of the upstream oil and gas industry."""
    subclass = None
    superclass = AbstractObject
    def __init__(self, PropertyKind=None):
        self.original_tagname_ = None
        super(PropertyKindDictionary, self).__init__()
        if PropertyKind is None:
            self.PropertyKind = []
        else:
            self.PropertyKind = PropertyKind
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PropertyKindDictionary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PropertyKindDictionary.subclass:
            return PropertyKindDictionary.subclass(*args_, **kwargs_)
        else:
            return PropertyKindDictionary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PropertyKind(self): return self.PropertyKind
    def set_PropertyKind(self, PropertyKind): self.PropertyKind = PropertyKind
    def add_PropertyKind(self, value): self.PropertyKind.append(value)
    def insert_PropertyKind_at(self, index, value): self.PropertyKind.insert(index, value)
    def replace_PropertyKind_at(self, index, value): self.PropertyKind[index] = value
    PropertyKindProp = property(get_PropertyKind, set_PropertyKind)
    def hasContent_(self):
        if (
            self.PropertyKind or
            super(PropertyKindDictionary, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PropertyKindDictionary', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyKindDictionary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PropertyKindDictionary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PropertyKindDictionary'):
        super(PropertyKindDictionary, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyKindDictionary')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PropertyKindDictionary', fromsubclass_=False, pretty_print=True):
        super(PropertyKindDictionary, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PropertyKind_ in self.PropertyKind:
            PropertyKind_.export(outfile, level, namespace_, name_='PropertyKind', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PropertyKindDictionary, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PropertyKind':
            obj_ = PropertyKind.factory()
            obj_.build(child_)
            self.PropertyKind.append(obj_)
            obj_.original_tagname_ = 'PropertyKind'
        super(PropertyKindDictionary, self).buildChildren(child_, node, nodeName_, True)
# end class PropertyKindDictionary


class TimeIndex(GeneratedsSuper):
    """Index into a time series. Used to specify time. (Not to be confused
    with time step.)"""
    subclass = None
    superclass = None
    def __init__(self, Index=None, TimeSeries=None):
        self.original_tagname_ = None
        self.Index = Index
        self.validate_NonNegativeLong(self.Index)
        self.TimeSeries = TimeSeries
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeIndex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeIndex.subclass:
            return TimeIndex.subclass(*args_, **kwargs_)
        else:
            return TimeIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    IndexProp = property(get_Index, set_Index)
    def get_TimeSeries(self): return self.TimeSeries
    def set_TimeSeries(self, TimeSeries): self.TimeSeries = TimeSeries
    TimeSeriesProp = property(get_TimeSeries, set_TimeSeries)
    def validate_NonNegativeLong(self, value):
        # Validate type NonNegativeLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeLong' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Index is not None or
            self.TimeSeries is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimeIndex', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeIndex')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimeIndex', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimeIndex'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimeIndex', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Index is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndex>%s</%sIndex>%s' % (namespace_, self.gds_format_integer(self.Index, input_name='Index'), namespace_, eol_))
        if self.TimeSeries is not None:
            self.TimeSeries.export(outfile, level, namespace_, name_='TimeSeries', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Index':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Index')
            self.Index = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.Index)
        elif nodeName_ == 'TimeSeries':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.TimeSeries = obj_
            obj_.original_tagname_ = 'TimeSeries'
# end class TimeIndex


class TimeIndices(GeneratedsSuper):
    """Indices into a time series. Used to specify time. (Not to be
    confused with time step.)"""
    subclass = None
    superclass = None
    def __init__(self, TimeIndexCount=None, TimeIndexStart=None, SimulatorTimeStep=None, UseInterval=None, TimeSeries=None):
        self.original_tagname_ = None
        self.TimeIndexCount = TimeIndexCount
        self.validate_PositiveLong(self.TimeIndexCount)
        self.TimeIndexStart = TimeIndexStart
        self.validate_NonNegativeLong(self.TimeIndexStart)
        self.SimulatorTimeStep = SimulatorTimeStep
        self.UseInterval = UseInterval
        self.TimeSeries = TimeSeries
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeIndices)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeIndices.subclass:
            return TimeIndices.subclass(*args_, **kwargs_)
        else:
            return TimeIndices(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeIndexCount(self): return self.TimeIndexCount
    def set_TimeIndexCount(self, TimeIndexCount): self.TimeIndexCount = TimeIndexCount
    TimeIndexCountProp = property(get_TimeIndexCount, set_TimeIndexCount)
    def get_TimeIndexStart(self): return self.TimeIndexStart
    def set_TimeIndexStart(self, TimeIndexStart): self.TimeIndexStart = TimeIndexStart
    TimeIndexStartProp = property(get_TimeIndexStart, set_TimeIndexStart)
    def get_SimulatorTimeStep(self): return self.SimulatorTimeStep
    def set_SimulatorTimeStep(self, SimulatorTimeStep): self.SimulatorTimeStep = SimulatorTimeStep
    SimulatorTimeStepProp = property(get_SimulatorTimeStep, set_SimulatorTimeStep)
    def get_UseInterval(self): return self.UseInterval
    def set_UseInterval(self, UseInterval): self.UseInterval = UseInterval
    UseIntervalProp = property(get_UseInterval, set_UseInterval)
    def get_TimeSeries(self): return self.TimeSeries
    def set_TimeSeries(self, TimeSeries): self.TimeSeries = TimeSeries
    TimeSeriesProp = property(get_TimeSeries, set_TimeSeries)
    def validate_PositiveLong(self, value):
        # Validate type PositiveLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveLong' % {"value" : value} )
    def validate_NonNegativeLong(self, value):
        # Validate type NonNegativeLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeLong' % {"value" : value} )
    def hasContent_(self):
        if (
            self.TimeIndexCount is not None or
            self.TimeIndexStart is not None or
            self.SimulatorTimeStep is not None or
            self.UseInterval is not None or
            self.TimeSeries is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimeIndices', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeIndices')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimeIndices', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimeIndices'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimeIndices', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TimeIndexCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeIndexCount>%s</%sTimeIndexCount>%s' % (namespace_, self.gds_format_integer(self.TimeIndexCount, input_name='TimeIndexCount'), namespace_, eol_))
        if self.TimeIndexStart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeIndexStart>%s</%sTimeIndexStart>%s' % (namespace_, self.gds_format_integer(self.TimeIndexStart, input_name='TimeIndexStart'), namespace_, eol_))
        if self.SimulatorTimeStep is not None:
            self.SimulatorTimeStep.export(outfile, level, namespace_, name_='SimulatorTimeStep', pretty_print=pretty_print)
        if self.UseInterval is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUseInterval>%s</%sUseInterval>%s' % (namespace_, self.gds_format_boolean(self.UseInterval, input_name='UseInterval'), namespace_, eol_))
        if self.TimeSeries is not None:
            self.TimeSeries.export(outfile, level, namespace_, name_='TimeSeries', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeIndexCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TimeIndexCount')
            self.TimeIndexCount = ival_
            # validate type PositiveLong
            self.validate_PositiveLong(self.TimeIndexCount)
        elif nodeName_ == 'TimeIndexStart':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TimeIndexStart')
            self.TimeIndexStart = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.TimeIndexStart)
        elif nodeName_ == 'SimulatorTimeStep':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <SimulatorTimeStep> element')
            self.SimulatorTimeStep = obj_
            obj_.original_tagname_ = 'SimulatorTimeStep'
        elif nodeName_ == 'UseInterval':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'UseInterval')
            self.UseInterval = ival_
        elif nodeName_ == 'TimeSeries':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.TimeSeries = obj_
            obj_.original_tagname_ = 'TimeSeries'
# end class TimeIndices


class TimeSeries(AbstractObject):
    """Stores an ordered list of times, for example, for time-dependent
    properties, geometries, or representations. It is used in
    conjunction with the time index to specify times for RESQML."""
    subclass = None
    superclass = AbstractObject
    def __init__(self, Time=None, TimeSeriesParentage=None):
        self.original_tagname_ = None
        super(TimeSeries, self).__init__()
        if Time is None:
            self.Time = []
        else:
            self.Time = Time
        self.TimeSeriesParentage = TimeSeriesParentage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeSeries)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeSeries.subclass:
            return TimeSeries.subclass(*args_, **kwargs_)
        else:
            return TimeSeries(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def add_Time(self, value): self.Time.append(value)
    def insert_Time_at(self, index, value): self.Time.insert(index, value)
    def replace_Time_at(self, index, value): self.Time[index] = value
    TimeProp = property(get_Time, set_Time)
    def get_TimeSeriesParentage(self): return self.TimeSeriesParentage
    def set_TimeSeriesParentage(self, TimeSeriesParentage): self.TimeSeriesParentage = TimeSeriesParentage
    TimeSeriesParentageProp = property(get_TimeSeriesParentage, set_TimeSeriesParentage)
    def hasContent_(self):
        if (
            self.Time or
            self.TimeSeriesParentage is not None or
            super(TimeSeries, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimeSeries', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeSeries')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimeSeries', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimeSeries'):
        super(TimeSeries, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeSeries')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimeSeries', fromsubclass_=False, pretty_print=True):
        super(TimeSeries, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Time_ in self.Time:
            Time_.export(outfile, level, namespace_, name_='Time', pretty_print=pretty_print)
        if self.TimeSeriesParentage is not None:
            self.TimeSeriesParentage.export(outfile, level, namespace_, name_='TimeSeriesParentage', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeSeries, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Time':
            obj_ = GeologicTime.factory()
            obj_.build(child_)
            self.Time.append(obj_)
            obj_.original_tagname_ = 'Time'
        elif nodeName_ == 'TimeSeriesParentage':
            obj_ = TimeSeriesParentage.factory()
            obj_.build(child_)
            self.TimeSeriesParentage = obj_
            obj_.original_tagname_ = 'TimeSeriesParentage'
        super(TimeSeries, self).buildChildren(child_, node, nodeName_, True)
# end class TimeSeries


class TimeSeriesParentage(GeneratedsSuper):
    """Indicates that a time series has the associated time series as a
    parent, i.e., that the series continues from the parent time
    series."""
    subclass = None
    superclass = None
    def __init__(self, HasOverlap=None, ParentTimeIndex=None):
        self.original_tagname_ = None
        self.HasOverlap = HasOverlap
        self.ParentTimeIndex = ParentTimeIndex
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeSeriesParentage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeSeriesParentage.subclass:
            return TimeSeriesParentage.subclass(*args_, **kwargs_)
        else:
            return TimeSeriesParentage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HasOverlap(self): return self.HasOverlap
    def set_HasOverlap(self, HasOverlap): self.HasOverlap = HasOverlap
    HasOverlapProp = property(get_HasOverlap, set_HasOverlap)
    def get_ParentTimeIndex(self): return self.ParentTimeIndex
    def set_ParentTimeIndex(self, ParentTimeIndex): self.ParentTimeIndex = ParentTimeIndex
    ParentTimeIndexProp = property(get_ParentTimeIndex, set_ParentTimeIndex)
    def hasContent_(self):
        if (
            self.HasOverlap is not None or
            self.ParentTimeIndex is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TimeSeriesParentage', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeSeriesParentage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TimeSeriesParentage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TimeSeriesParentage'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TimeSeriesParentage', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HasOverlap is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHasOverlap>%s</%sHasOverlap>%s' % (namespace_, self.gds_format_boolean(self.HasOverlap, input_name='HasOverlap'), namespace_, eol_))
        if self.ParentTimeIndex is not None:
            self.ParentTimeIndex.export(outfile, level, namespace_, name_='ParentTimeIndex', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HasOverlap':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'HasOverlap')
            self.HasOverlap = ival_
        elif nodeName_ == 'ParentTimeIndex':
            obj_ = TimeIndex.factory()
            obj_.build(child_)
            self.ParentTimeIndex = obj_
            obj_.original_tagname_ = 'ParentTimeIndex'
# end class TimeSeriesParentage


class AbstractPressureValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractPressureValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractPressureValue.subclass:
            return AbstractPressureValue.subclass(*args_, **kwargs_)
        else:
            return AbstractPressureValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractPressureValue', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractPressureValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractPressureValue', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractPressureValue'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractPressureValue', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractPressureValue


class AbstractTemperaturePressure(GeneratedsSuper):
    """The Abstract base type of standard pressure and temperature"""
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractTemperaturePressure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractTemperaturePressure.subclass:
            return AbstractTemperaturePressure.subclass(*args_, **kwargs_)
        else:
            return AbstractTemperaturePressure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractTemperaturePressure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTemperaturePressure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractTemperaturePressure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractTemperaturePressure'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractTemperaturePressure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractTemperaturePressure


class DensityValue(GeneratedsSuper):
    """A possibly temperature and pressure corrected desity value."""
    subclass = None
    superclass = None
    def __init__(self, Density=None, MeasurementPressureTemperature=None):
        self.original_tagname_ = None
        self.Density = Density
        self.MeasurementPressureTemperature = MeasurementPressureTemperature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DensityValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DensityValue.subclass:
            return DensityValue.subclass(*args_, **kwargs_)
        else:
            return DensityValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Density(self): return self.Density
    def set_Density(self, Density): self.Density = Density
    DensityProp = property(get_Density, set_Density)
    def get_MeasurementPressureTemperature(self): return self.MeasurementPressureTemperature
    def set_MeasurementPressureTemperature(self, MeasurementPressureTemperature): self.MeasurementPressureTemperature = MeasurementPressureTemperature
    MeasurementPressureTemperatureProp = property(get_MeasurementPressureTemperature, set_MeasurementPressureTemperature)
    def hasContent_(self):
        if (
            self.Density is not None or
            self.MeasurementPressureTemperature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DensityValue', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DensityValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DensityValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DensityValue'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DensityValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Density is not None:
            self.Density.export(outfile, level, namespace_, name_='Density', pretty_print=pretty_print)
        if self.MeasurementPressureTemperature is not None:
            self.MeasurementPressureTemperature.export(outfile, level, namespace_, name_='MeasurementPressureTemperature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Density':
            obj_ = MassPerVolumeMeasureExt.factory()
            obj_.build(child_)
            self.Density = obj_
            obj_.original_tagname_ = 'Density'
        elif nodeName_ == 'MeasurementPressureTemperature':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <MeasurementPressureTemperature> element')
            self.MeasurementPressureTemperature = obj_
            obj_.original_tagname_ = 'MeasurementPressureTemperature'
# end class DensityValue


class FlowRateValue(GeneratedsSuper):
    """A possibly temperature and pressure corrected flow rate value."""
    subclass = None
    superclass = None
    def __init__(self, FlowRate=None, MeasurementPressureTemperature=None):
        self.original_tagname_ = None
        self.FlowRate = FlowRate
        self.MeasurementPressureTemperature = MeasurementPressureTemperature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlowRateValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlowRateValue.subclass:
            return FlowRateValue.subclass(*args_, **kwargs_)
        else:
            return FlowRateValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FlowRate(self): return self.FlowRate
    def set_FlowRate(self, FlowRate): self.FlowRate = FlowRate
    FlowRateProp = property(get_FlowRate, set_FlowRate)
    def get_MeasurementPressureTemperature(self): return self.MeasurementPressureTemperature
    def set_MeasurementPressureTemperature(self, MeasurementPressureTemperature): self.MeasurementPressureTemperature = MeasurementPressureTemperature
    MeasurementPressureTemperatureProp = property(get_MeasurementPressureTemperature, set_MeasurementPressureTemperature)
    def hasContent_(self):
        if (
            self.FlowRate is not None or
            self.MeasurementPressureTemperature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FlowRateValue', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlowRateValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FlowRateValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FlowRateValue'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FlowRateValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FlowRate is not None:
            self.FlowRate.export(outfile, level, namespace_, name_='FlowRate', pretty_print=pretty_print)
        if self.MeasurementPressureTemperature is not None:
            self.MeasurementPressureTemperature.export(outfile, level, namespace_, name_='MeasurementPressureTemperature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FlowRate':
            obj_ = VolumePerTimeMeasureExt.factory()
            obj_.build(child_)
            self.FlowRate = obj_
            obj_.original_tagname_ = 'FlowRate'
        elif nodeName_ == 'MeasurementPressureTemperature':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <MeasurementPressureTemperature> element')
            self.MeasurementPressureTemperature = obj_
            obj_.original_tagname_ = 'MeasurementPressureTemperature'
# end class FlowRateValue


class GaugePressure(AbstractPressureValue):
    subclass = None
    superclass = AbstractPressureValue
    def __init__(self, GaugePressure_member=None, ReferencePressure=None):
        self.original_tagname_ = None
        super(GaugePressure, self).__init__()
        self.GaugePressure = GaugePressure_member
        self.ReferencePressure = ReferencePressure
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GaugePressure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GaugePressure.subclass:
            return GaugePressure.subclass(*args_, **kwargs_)
        else:
            return GaugePressure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GaugePressure(self): return self.GaugePressure
    def set_GaugePressure(self, GaugePressure): self.GaugePressure = GaugePressure
    GaugePressureProp = property(get_GaugePressure, set_GaugePressure)
    def get_ReferencePressure(self): return self.ReferencePressure
    def set_ReferencePressure(self, ReferencePressure): self.ReferencePressure = ReferencePressure
    ReferencePressureProp = property(get_ReferencePressure, set_ReferencePressure)
    def hasContent_(self):
        if (
            self.GaugePressure is not None or
            self.ReferencePressure is not None or
            super(GaugePressure, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GaugePressure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GaugePressure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GaugePressure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GaugePressure'):
        super(GaugePressure, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GaugePressure')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GaugePressure', fromsubclass_=False, pretty_print=True):
        super(GaugePressure, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GaugePressure is not None:
            self.GaugePressure.export(outfile, level, namespace_, name_='GaugePressure', pretty_print=pretty_print)
        if self.ReferencePressure is not None:
            self.ReferencePressure.export(outfile, level, namespace_, name_='ReferencePressure', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GaugePressure, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GaugePressure':
            obj_ = PressureMeasureExt.factory()
            obj_.build(child_)
            self.GaugePressure = obj_
            obj_.original_tagname_ = 'GaugePressure'
        elif nodeName_ == 'ReferencePressure':
            obj_ = ReferencePressure.factory()
            obj_.build(child_)
            self.ReferencePressure = obj_
            obj_.original_tagname_ = 'ReferencePressure'
        super(GaugePressure, self).buildChildren(child_, node, nodeName_, True)
# end class GaugePressure


class PressureValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbstractPressureValue=None):
        self.original_tagname_ = None
        self.AbstractPressureValue = AbstractPressureValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressureValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressureValue.subclass:
            return PressureValue.subclass(*args_, **kwargs_)
        else:
            return PressureValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractPressureValue(self): return self.AbstractPressureValue
    def set_AbstractPressureValue(self, AbstractPressureValue): self.AbstractPressureValue = AbstractPressureValue
    AbstractPressureValueProp = property(get_AbstractPressureValue, set_AbstractPressureValue)
    def hasContent_(self):
        if (
            self.AbstractPressureValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PressureValue', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PressureValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PressureValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PressureValue'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PressureValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AbstractPressureValue is not None:
            self.AbstractPressureValue.export(outfile, level, namespace_, name_='AbstractPressureValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractPressureValue':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractPressureValue> element')
            self.AbstractPressureValue = obj_
            obj_.original_tagname_ = 'AbstractPressureValue'
# end class PressureValue


class ReferencePressure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, referencePressureKind=None, valueOf_=None):
        self.original_tagname_ = None
        self.uom = _cast(None, uom)
        self.referencePressureKind = _cast(None, referencePressureKind)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferencePressure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferencePressure.subclass:
            return ReferencePressure.subclass(*args_, **kwargs_)
        else:
            return ReferencePressure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def get_referencePressureKind(self): return self.referencePressureKind
    def set_referencePressureKind(self, referencePressureKind): self.referencePressureKind = referencePressureKind
    referencePressureKindProp = property(get_referencePressureKind, set_referencePressureKind)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReferencePressure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferencePressure')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReferencePressure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReferencePressure'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
        if self.referencePressureKind is not None and 'referencePressureKind' not in already_processed:
            already_processed.add('referencePressureKind')
            outfile.write(' referencePressureKind=%s' % (quote_attrib(self.referencePressureKind), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReferencePressure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
        value = find_attr_value_('referencePressureKind', node)
        if value is not None and 'referencePressureKind' not in already_processed:
            already_processed.add('referencePressureKind')
            self.referencePressureKind = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReferencePressure


class ReferenceTemperaturePressure(AbstractTemperaturePressure):
    """StdTempPress"""
    subclass = None
    superclass = AbstractTemperaturePressure
    def __init__(self, ReferenceTempPres=None):
        self.original_tagname_ = None
        super(ReferenceTemperaturePressure, self).__init__()
        self.ReferenceTempPres = ReferenceTempPres
        self.validate_ReferenceConditionExt(self.ReferenceTempPres)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceTemperaturePressure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceTemperaturePressure.subclass:
            return ReferenceTemperaturePressure.subclass(*args_, **kwargs_)
        else:
            return ReferenceTemperaturePressure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReferenceTempPres(self): return self.ReferenceTempPres
    def set_ReferenceTempPres(self, ReferenceTempPres): self.ReferenceTempPres = ReferenceTempPres
    ReferenceTempPresProp = property(get_ReferenceTempPres, set_ReferenceTempPres)
    def validate_ReferenceConditionExt(self, value):
        # Validate type ReferenceConditionExt, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.ReferenceTempPres is not None or
            super(ReferenceTemperaturePressure, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ReferenceTemperaturePressure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceTemperaturePressure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ReferenceTemperaturePressure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ReferenceTemperaturePressure'):
        super(ReferenceTemperaturePressure, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceTemperaturePressure')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ReferenceTemperaturePressure', fromsubclass_=False, pretty_print=True):
        super(ReferenceTemperaturePressure, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReferenceTempPres is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReferenceTempPres>%s</%sReferenceTempPres>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ReferenceTempPres), input_name='ReferenceTempPres')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReferenceTemperaturePressure, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReferenceTempPres':
            ReferenceTempPres_ = child_.text
            ReferenceTempPres_ = self.gds_validate_string(ReferenceTempPres_, node, 'ReferenceTempPres')
            self.ReferenceTempPres = ReferenceTempPres_
            # validate type ReferenceConditionExt
            self.validate_ReferenceConditionExt(self.ReferenceTempPres)
        super(ReferenceTemperaturePressure, self).buildChildren(child_, node, nodeName_, True)
# end class ReferenceTemperaturePressure


class RelativePressure(AbstractPressureValue):
    subclass = None
    superclass = AbstractPressureValue
    def __init__(self, RelativePressure_member=None, ReferencePressure=None):
        self.original_tagname_ = None
        super(RelativePressure, self).__init__()
        self.RelativePressure = RelativePressure_member
        self.ReferencePressure = ReferencePressure
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelativePressure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelativePressure.subclass:
            return RelativePressure.subclass(*args_, **kwargs_)
        else:
            return RelativePressure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RelativePressure(self): return self.RelativePressure
    def set_RelativePressure(self, RelativePressure): self.RelativePressure = RelativePressure
    RelativePressureProp = property(get_RelativePressure, set_RelativePressure)
    def get_ReferencePressure(self): return self.ReferencePressure
    def set_ReferencePressure(self, ReferencePressure): self.ReferencePressure = ReferencePressure
    ReferencePressureProp = property(get_ReferencePressure, set_ReferencePressure)
    def hasContent_(self):
        if (
            self.RelativePressure is not None or
            self.ReferencePressure is not None or
            super(RelativePressure, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='RelativePressure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelativePressure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='RelativePressure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='RelativePressure'):
        super(RelativePressure, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RelativePressure')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='RelativePressure', fromsubclass_=False, pretty_print=True):
        super(RelativePressure, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RelativePressure is not None:
            self.RelativePressure.export(outfile, level, namespace_, name_='RelativePressure', pretty_print=pretty_print)
        if self.ReferencePressure is not None:
            self.ReferencePressure.export(outfile, level, namespace_, name_='ReferencePressure', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RelativePressure, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RelativePressure':
            obj_ = PressureMeasure.factory()
            obj_.build(child_)
            self.RelativePressure = obj_
            obj_.original_tagname_ = 'RelativePressure'
        elif nodeName_ == 'ReferencePressure':
            obj_ = ReferencePressure.factory()
            obj_.build(child_)
            self.ReferencePressure = obj_
            obj_.original_tagname_ = 'ReferencePressure'
        super(RelativePressure, self).buildChildren(child_, node, nodeName_, True)
# end class RelativePressure


class TemperaturePressure(AbstractTemperaturePressure):
    """temperature and pressure"""
    subclass = None
    superclass = AbstractTemperaturePressure
    def __init__(self, Temperature=None, Pressure=None):
        self.original_tagname_ = None
        super(TemperaturePressure, self).__init__()
        self.Temperature = Temperature
        self.Pressure = Pressure
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemperaturePressure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemperaturePressure.subclass:
            return TemperaturePressure.subclass(*args_, **kwargs_)
        else:
            return TemperaturePressure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Temperature(self): return self.Temperature
    def set_Temperature(self, Temperature): self.Temperature = Temperature
    TemperatureProp = property(get_Temperature, set_Temperature)
    def get_Pressure(self): return self.Pressure
    def set_Pressure(self, Pressure): self.Pressure = Pressure
    PressureProp = property(get_Pressure, set_Pressure)
    def hasContent_(self):
        if (
            self.Temperature is not None or
            self.Pressure is not None or
            super(TemperaturePressure, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='TemperaturePressure', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemperaturePressure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='TemperaturePressure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='TemperaturePressure'):
        super(TemperaturePressure, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TemperaturePressure')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='TemperaturePressure', fromsubclass_=False, pretty_print=True):
        super(TemperaturePressure, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Temperature is not None:
            self.Temperature.export(outfile, level, namespace_, name_='Temperature', pretty_print=pretty_print)
        if self.Pressure is not None:
            self.Pressure.export(outfile, level, namespace_, name_='Pressure', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TemperaturePressure, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Temperature':
            obj_ = ThermodynamicTemperatureMeasure.factory()
            obj_.build(child_)
            self.Temperature = obj_
            obj_.original_tagname_ = 'Temperature'
        elif nodeName_ == 'Pressure':
            obj_ = PressureMeasure.factory()
            obj_.build(child_)
            self.Pressure = obj_
            obj_.original_tagname_ = 'Pressure'
        super(TemperaturePressure, self).buildChildren(child_, node, nodeName_, True)
# end class TemperaturePressure


class VolumeValue(GeneratedsSuper):
    """A possibly temperature and pressure corrected volume value."""
    subclass = None
    superclass = None
    def __init__(self, Volume=None, MeasurementPressureTemperature=None):
        self.original_tagname_ = None
        self.Volume = Volume
        self.MeasurementPressureTemperature = MeasurementPressureTemperature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumeValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumeValue.subclass:
            return VolumeValue.subclass(*args_, **kwargs_)
        else:
            return VolumeValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Volume(self): return self.Volume
    def set_Volume(self, Volume): self.Volume = Volume
    VolumeProp = property(get_Volume, set_Volume)
    def get_MeasurementPressureTemperature(self): return self.MeasurementPressureTemperature
    def set_MeasurementPressureTemperature(self, MeasurementPressureTemperature): self.MeasurementPressureTemperature = MeasurementPressureTemperature
    MeasurementPressureTemperatureProp = property(get_MeasurementPressureTemperature, set_MeasurementPressureTemperature)
    def hasContent_(self):
        if (
            self.Volume is not None or
            self.MeasurementPressureTemperature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VolumeValue', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumeValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VolumeValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VolumeValue'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VolumeValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Volume is not None:
            self.Volume.export(outfile, level, namespace_, name_='Volume', pretty_print=pretty_print)
        if self.MeasurementPressureTemperature is not None:
            self.MeasurementPressureTemperature.export(outfile, level, namespace_, name_='MeasurementPressureTemperature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Volume':
            obj_ = VolumeMeasureExt.factory()
            obj_.build(child_)
            self.Volume = obj_
            obj_.original_tagname_ = 'Volume'
        elif nodeName_ == 'MeasurementPressureTemperature':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <MeasurementPressureTemperature> element')
            self.MeasurementPressureTemperature = obj_
            obj_.original_tagname_ = 'MeasurementPressureTemperature'
# end class VolumeValue


class AbstractGeodeticCrs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractGeodeticCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractGeodeticCrs.subclass:
            return AbstractGeodeticCrs.subclass(*args_, **kwargs_)
        else:
            return AbstractGeodeticCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractGeodeticCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeodeticCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractGeodeticCrs', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractGeodeticCrs'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractGeodeticCrs', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractGeodeticCrs


class AbstractProjectedCrs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractProjectedCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractProjectedCrs.subclass:
            return AbstractProjectedCrs.subclass(*args_, **kwargs_)
        else:
            return AbstractProjectedCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractProjectedCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractProjectedCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractProjectedCrs', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractProjectedCrs'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractProjectedCrs', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractProjectedCrs


class AbstractVerticalCrs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractVerticalCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractVerticalCrs.subclass:
            return AbstractVerticalCrs.subclass(*args_, **kwargs_)
        else:
            return AbstractVerticalCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractVerticalCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractVerticalCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractVerticalCrs', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractVerticalCrs'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractVerticalCrs', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractVerticalCrs


class GeodeticCrs(AbstractObject):
    subclass = None
    superclass = AbstractObject
    def __init__(self, AbstractGeodeticCrs=None):
        self.original_tagname_ = None
        super(GeodeticCrs, self).__init__()
        self.AbstractGeodeticCrs = AbstractGeodeticCrs
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeodeticCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeodeticCrs.subclass:
            return GeodeticCrs.subclass(*args_, **kwargs_)
        else:
            return GeodeticCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractGeodeticCrs(self): return self.AbstractGeodeticCrs
    def set_AbstractGeodeticCrs(self, AbstractGeodeticCrs): self.AbstractGeodeticCrs = AbstractGeodeticCrs
    AbstractGeodeticCrsProp = property(get_AbstractGeodeticCrs, set_AbstractGeodeticCrs)
    def hasContent_(self):
        if (
            self.AbstractGeodeticCrs is not None or
            super(GeodeticCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeodeticCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeodeticCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeodeticCrs'):
        super(GeodeticCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeodeticCrs', fromsubclass_=False, pretty_print=True):
        super(GeodeticCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AbstractGeodeticCrs is not None:
            self.AbstractGeodeticCrs.export(outfile, level, namespace_, name_='AbstractGeodeticCrs', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GeodeticCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractGeodeticCrs':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeodeticCrs> element')
            self.AbstractGeodeticCrs = obj_
            obj_.original_tagname_ = 'AbstractGeodeticCrs'
        super(GeodeticCrs, self).buildChildren(child_, node, nodeName_, True)
# end class GeodeticCrs


class GeodeticEpsgCrs(AbstractGeodeticCrs):
    """This class contains the EPSG code for a geodetic CRS."""
    subclass = None
    superclass = AbstractGeodeticCrs
    def __init__(self, EpsgCode=None):
        self.original_tagname_ = None
        super(GeodeticEpsgCrs, self).__init__()
        self.EpsgCode = EpsgCode
        self.validate_PositiveLong(self.EpsgCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeodeticEpsgCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeodeticEpsgCrs.subclass:
            return GeodeticEpsgCrs.subclass(*args_, **kwargs_)
        else:
            return GeodeticEpsgCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EpsgCode(self): return self.EpsgCode
    def set_EpsgCode(self, EpsgCode): self.EpsgCode = EpsgCode
    EpsgCodeProp = property(get_EpsgCode, set_EpsgCode)
    def validate_PositiveLong(self, value):
        # Validate type PositiveLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveLong' % {"value" : value} )
    def hasContent_(self):
        if (
            self.EpsgCode is not None or
            super(GeodeticEpsgCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeodeticEpsgCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticEpsgCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeodeticEpsgCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeodeticEpsgCrs'):
        super(GeodeticEpsgCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticEpsgCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeodeticEpsgCrs', fromsubclass_=False, pretty_print=True):
        super(GeodeticEpsgCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EpsgCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEpsgCode>%s</%sEpsgCode>%s' % (namespace_, self.gds_format_integer(self.EpsgCode, input_name='EpsgCode'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GeodeticEpsgCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EpsgCode':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'EpsgCode')
            self.EpsgCode = ival_
            # validate type PositiveLong
            self.validate_PositiveLong(self.EpsgCode)
        super(GeodeticEpsgCrs, self).buildChildren(child_, node, nodeName_, True)
# end class GeodeticEpsgCrs


class GeodeticGmlCrs(AbstractGeodeticCrs):
    """This is the Energistics encapsulation of the GeodeticCrs type from
    GML."""
    subclass = None
    superclass = AbstractGeodeticCrs
    def __init__(self, GmlProjectedCrsDefinition=None):
        self.original_tagname_ = None
        super(GeodeticGmlCrs, self).__init__()
        self.GmlProjectedCrsDefinition = GmlProjectedCrsDefinition
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeodeticGmlCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeodeticGmlCrs.subclass:
            return GeodeticGmlCrs.subclass(*args_, **kwargs_)
        else:
            return GeodeticGmlCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GmlProjectedCrsDefinition(self): return self.GmlProjectedCrsDefinition
    def set_GmlProjectedCrsDefinition(self, GmlProjectedCrsDefinition): self.GmlProjectedCrsDefinition = GmlProjectedCrsDefinition
    GmlProjectedCrsDefinitionProp = property(get_GmlProjectedCrsDefinition, set_GmlProjectedCrsDefinition)
    def hasContent_(self):
        if (
            self.GmlProjectedCrsDefinition is not None or
            super(GeodeticGmlCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeodeticGmlCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticGmlCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeodeticGmlCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeodeticGmlCrs'):
        super(GeodeticGmlCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticGmlCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeodeticGmlCrs', fromsubclass_=False, pretty_print=True):
        super(GeodeticGmlCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GmlProjectedCrsDefinition is not None:
            self.GmlProjectedCrsDefinition.export(outfile, level, namespace_, name_='GmlProjectedCrsDefinition', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GeodeticGmlCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GmlProjectedCrsDefinition':
            obj_ = GeodeticCRSType.factory()
            obj_.build(child_)
            self.GmlProjectedCrsDefinition = obj_
            obj_.original_tagname_ = 'GmlProjectedCrsDefinition'
        super(GeodeticGmlCrs, self).buildChildren(child_, node, nodeName_, True)
# end class GeodeticGmlCrs


class GeodeticLocalAuthorityCrs(AbstractGeodeticCrs):
    """This class contains a code for a geodetic CRS according to a local
    authority. This would be used in a case where a company or
    regulatory regime has chosen not to use EPSG codes."""
    subclass = None
    superclass = AbstractGeodeticCrs
    def __init__(self, LocalAuthorityCrsName=None):
        self.original_tagname_ = None
        super(GeodeticLocalAuthorityCrs, self).__init__()
        self.LocalAuthorityCrsName = LocalAuthorityCrsName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeodeticLocalAuthorityCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeodeticLocalAuthorityCrs.subclass:
            return GeodeticLocalAuthorityCrs.subclass(*args_, **kwargs_)
        else:
            return GeodeticLocalAuthorityCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocalAuthorityCrsName(self): return self.LocalAuthorityCrsName
    def set_LocalAuthorityCrsName(self, LocalAuthorityCrsName): self.LocalAuthorityCrsName = LocalAuthorityCrsName
    LocalAuthorityCrsNameProp = property(get_LocalAuthorityCrsName, set_LocalAuthorityCrsName)
    def hasContent_(self):
        if (
            self.LocalAuthorityCrsName is not None or
            super(GeodeticLocalAuthorityCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeodeticLocalAuthorityCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticLocalAuthorityCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeodeticLocalAuthorityCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeodeticLocalAuthorityCrs'):
        super(GeodeticLocalAuthorityCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticLocalAuthorityCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeodeticLocalAuthorityCrs', fromsubclass_=False, pretty_print=True):
        super(GeodeticLocalAuthorityCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LocalAuthorityCrsName is not None:
            self.LocalAuthorityCrsName.export(outfile, level, namespace_, name_='LocalAuthorityCrsName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GeodeticLocalAuthorityCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LocalAuthorityCrsName':
            obj_ = AuthorityQualifiedName.factory()
            obj_.build(child_)
            self.LocalAuthorityCrsName = obj_
            obj_.original_tagname_ = 'LocalAuthorityCrsName'
        super(GeodeticLocalAuthorityCrs, self).buildChildren(child_, node, nodeName_, True)
# end class GeodeticLocalAuthorityCrs


class GeodeticUnknownCrs(AbstractGeodeticCrs):
    """This class is used in a case where the coordinate reference system
    is either unknown or is intentionally not being transferred."""
    subclass = None
    superclass = AbstractGeodeticCrs
    def __init__(self, Unknown=None):
        self.original_tagname_ = None
        super(GeodeticUnknownCrs, self).__init__()
        self.Unknown = Unknown
        self.validate_String2000(self.Unknown)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeodeticUnknownCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeodeticUnknownCrs.subclass:
            return GeodeticUnknownCrs.subclass(*args_, **kwargs_)
        else:
            return GeodeticUnknownCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Unknown(self): return self.Unknown
    def set_Unknown(self, Unknown): self.Unknown = Unknown
    UnknownProp = property(get_Unknown, set_Unknown)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Unknown is not None or
            super(GeodeticUnknownCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeodeticUnknownCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticUnknownCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeodeticUnknownCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeodeticUnknownCrs'):
        super(GeodeticUnknownCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticUnknownCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeodeticUnknownCrs', fromsubclass_=False, pretty_print=True):
        super(GeodeticUnknownCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GeodeticUnknownCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
            # validate type String2000
            self.validate_String2000(self.Unknown)
        super(GeodeticUnknownCrs, self).buildChildren(child_, node, nodeName_, True)
# end class GeodeticUnknownCrs


class GeodeticWktCrs(AbstractGeodeticCrs):
    """ISO 19162-compliant well-known text for the Geodetic CRS."""
    subclass = None
    superclass = AbstractGeodeticCrs
    def __init__(self, WellKnownText=None):
        self.original_tagname_ = None
        super(GeodeticWktCrs, self).__init__()
        self.WellKnownText = WellKnownText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeodeticWktCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeodeticWktCrs.subclass:
            return GeodeticWktCrs.subclass(*args_, **kwargs_)
        else:
            return GeodeticWktCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WellKnownText(self): return self.WellKnownText
    def set_WellKnownText(self, WellKnownText): self.WellKnownText = WellKnownText
    WellKnownTextProp = property(get_WellKnownText, set_WellKnownText)
    def hasContent_(self):
        if (
            self.WellKnownText is not None or
            super(GeodeticWktCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeodeticWktCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticWktCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeodeticWktCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeodeticWktCrs'):
        super(GeodeticWktCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticWktCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeodeticWktCrs', fromsubclass_=False, pretty_print=True):
        super(GeodeticWktCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WellKnownText is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWellKnownText>%s</%sWellKnownText>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WellKnownText), input_name='WellKnownText')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GeodeticWktCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WellKnownText':
            WellKnownText_ = child_.text
            WellKnownText_ = self.gds_validate_string(WellKnownText_, node, 'WellKnownText')
            self.WellKnownText = WellKnownText_
        super(GeodeticWktCrs, self).buildChildren(child_, node, nodeName_, True)
# end class GeodeticWktCrs


class ProjectedCrs(AbstractObject):
    """This is the Energistics encapsulation of the ProjectedCrs type from
    GML."""
    subclass = None
    superclass = AbstractObject
    def __init__(self, uom=None, AxisOrder=None, AbstractProjectedCrs=None):
        self.original_tagname_ = None
        super(ProjectedCrs, self).__init__()
        self.uom = _cast(None, uom)
        self.AxisOrder = AxisOrder
        self.validate_AxisOrder2d(self.AxisOrder)
        self.AbstractProjectedCrs = AbstractProjectedCrs
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProjectedCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProjectedCrs.subclass:
            return ProjectedCrs.subclass(*args_, **kwargs_)
        else:
            return ProjectedCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AxisOrder(self): return self.AxisOrder
    def set_AxisOrder(self, AxisOrder): self.AxisOrder = AxisOrder
    AxisOrderProp = property(get_AxisOrder, set_AxisOrder)
    def get_AbstractProjectedCrs(self): return self.AbstractProjectedCrs
    def set_AbstractProjectedCrs(self, AbstractProjectedCrs): self.AbstractProjectedCrs = AbstractProjectedCrs
    AbstractProjectedCrsProp = property(get_AbstractProjectedCrs, set_AbstractProjectedCrs)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def validate_AxisOrder2d(self, value):
        # Validate type AxisOrder2d, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['easting northing', 'northing easting', 'westing southing', 'southing westing', 'northing westing', 'westing northing']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AxisOrder2d' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.AxisOrder is not None or
            self.AbstractProjectedCrs is not None or
            super(ProjectedCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProjectedCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProjectedCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProjectedCrs'):
        super(ProjectedCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedCrs')
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProjectedCrs', fromsubclass_=False, pretty_print=True):
        super(ProjectedCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AxisOrder is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAxisOrder>%s</%sAxisOrder>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AxisOrder), input_name='AxisOrder')), namespace_, eol_))
        if self.AbstractProjectedCrs is not None:
            self.AbstractProjectedCrs.export(outfile, level, namespace_, name_='AbstractProjectedCrs', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
        super(ProjectedCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AxisOrder':
            AxisOrder_ = child_.text
            AxisOrder_ = self.gds_validate_string(AxisOrder_, node, 'AxisOrder')
            self.AxisOrder = AxisOrder_
            # validate type AxisOrder2d
            self.validate_AxisOrder2d(self.AxisOrder)
        elif nodeName_ == 'AbstractProjectedCrs':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractProjectedCrs> element')
            self.AbstractProjectedCrs = obj_
            obj_.original_tagname_ = 'AbstractProjectedCrs'
        super(ProjectedCrs, self).buildChildren(child_, node, nodeName_, True)
# end class ProjectedCrs


class ProjectedEpsgCrs(AbstractProjectedCrs):
    """This class contains the EPSG code for a projected CRS."""
    subclass = None
    superclass = AbstractProjectedCrs
    def __init__(self, EpsgCode=None):
        self.original_tagname_ = None
        super(ProjectedEpsgCrs, self).__init__()
        self.EpsgCode = EpsgCode
        self.validate_PositiveLong(self.EpsgCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProjectedEpsgCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProjectedEpsgCrs.subclass:
            return ProjectedEpsgCrs.subclass(*args_, **kwargs_)
        else:
            return ProjectedEpsgCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EpsgCode(self): return self.EpsgCode
    def set_EpsgCode(self, EpsgCode): self.EpsgCode = EpsgCode
    EpsgCodeProp = property(get_EpsgCode, set_EpsgCode)
    def validate_PositiveLong(self, value):
        # Validate type PositiveLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveLong' % {"value" : value} )
    def hasContent_(self):
        if (
            self.EpsgCode is not None or
            super(ProjectedEpsgCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProjectedEpsgCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedEpsgCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProjectedEpsgCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProjectedEpsgCrs'):
        super(ProjectedEpsgCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedEpsgCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProjectedEpsgCrs', fromsubclass_=False, pretty_print=True):
        super(ProjectedEpsgCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EpsgCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEpsgCode>%s</%sEpsgCode>%s' % (namespace_, self.gds_format_integer(self.EpsgCode, input_name='EpsgCode'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ProjectedEpsgCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EpsgCode':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'EpsgCode')
            self.EpsgCode = ival_
            # validate type PositiveLong
            self.validate_PositiveLong(self.EpsgCode)
        super(ProjectedEpsgCrs, self).buildChildren(child_, node, nodeName_, True)
# end class ProjectedEpsgCrs


class ProjectedGmlCrs(AbstractProjectedCrs):
    """This is the Energistics encapsulation of the ProjectedCrs type from
    GML."""
    subclass = None
    superclass = AbstractProjectedCrs
    def __init__(self, GmlProjectedCrsDefinition=None):
        self.original_tagname_ = None
        super(ProjectedGmlCrs, self).__init__()
        self.GmlProjectedCrsDefinition = GmlProjectedCrsDefinition
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProjectedGmlCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProjectedGmlCrs.subclass:
            return ProjectedGmlCrs.subclass(*args_, **kwargs_)
        else:
            return ProjectedGmlCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GmlProjectedCrsDefinition(self): return self.GmlProjectedCrsDefinition
    def set_GmlProjectedCrsDefinition(self, GmlProjectedCrsDefinition): self.GmlProjectedCrsDefinition = GmlProjectedCrsDefinition
    GmlProjectedCrsDefinitionProp = property(get_GmlProjectedCrsDefinition, set_GmlProjectedCrsDefinition)
    def hasContent_(self):
        if (
            self.GmlProjectedCrsDefinition is not None or
            super(ProjectedGmlCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProjectedGmlCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedGmlCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProjectedGmlCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProjectedGmlCrs'):
        super(ProjectedGmlCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedGmlCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProjectedGmlCrs', fromsubclass_=False, pretty_print=True):
        super(ProjectedGmlCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GmlProjectedCrsDefinition is not None:
            self.GmlProjectedCrsDefinition.export(outfile, level, namespace_, name_='GmlProjectedCrsDefinition', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ProjectedGmlCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GmlProjectedCrsDefinition':
            obj_ = ProjectedCRSType.factory()
            obj_.build(child_)
            self.GmlProjectedCrsDefinition = obj_
            obj_.original_tagname_ = 'GmlProjectedCrsDefinition'
        super(ProjectedGmlCrs, self).buildChildren(child_, node, nodeName_, True)
# end class ProjectedGmlCrs


class ProjectedLocalAuthorityCrs(AbstractProjectedCrs):
    """This class contains a code for a projected CRS according to a local
    authority. This would be used in a case where a company or
    regulatory regime has chosen not to use EPSG codes."""
    subclass = None
    superclass = AbstractProjectedCrs
    def __init__(self, LocalAuthorityCrsName=None):
        self.original_tagname_ = None
        super(ProjectedLocalAuthorityCrs, self).__init__()
        self.LocalAuthorityCrsName = LocalAuthorityCrsName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProjectedLocalAuthorityCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProjectedLocalAuthorityCrs.subclass:
            return ProjectedLocalAuthorityCrs.subclass(*args_, **kwargs_)
        else:
            return ProjectedLocalAuthorityCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocalAuthorityCrsName(self): return self.LocalAuthorityCrsName
    def set_LocalAuthorityCrsName(self, LocalAuthorityCrsName): self.LocalAuthorityCrsName = LocalAuthorityCrsName
    LocalAuthorityCrsNameProp = property(get_LocalAuthorityCrsName, set_LocalAuthorityCrsName)
    def hasContent_(self):
        if (
            self.LocalAuthorityCrsName is not None or
            super(ProjectedLocalAuthorityCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProjectedLocalAuthorityCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedLocalAuthorityCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProjectedLocalAuthorityCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProjectedLocalAuthorityCrs'):
        super(ProjectedLocalAuthorityCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedLocalAuthorityCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProjectedLocalAuthorityCrs', fromsubclass_=False, pretty_print=True):
        super(ProjectedLocalAuthorityCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LocalAuthorityCrsName is not None:
            self.LocalAuthorityCrsName.export(outfile, level, namespace_, name_='LocalAuthorityCrsName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ProjectedLocalAuthorityCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LocalAuthorityCrsName':
            obj_ = AuthorityQualifiedName.factory()
            obj_.build(child_)
            self.LocalAuthorityCrsName = obj_
            obj_.original_tagname_ = 'LocalAuthorityCrsName'
        super(ProjectedLocalAuthorityCrs, self).buildChildren(child_, node, nodeName_, True)
# end class ProjectedLocalAuthorityCrs


class ProjectedUnknownCrs(AbstractProjectedCrs):
    """This class is used in a case where the coordinate reference system
    is either unknown or is intentionally not being transferred. In
    this case, the uom and AxisOrder need to be provided on the
    ProjectedCrs class."""
    subclass = None
    superclass = AbstractProjectedCrs
    def __init__(self, Unknown=None):
        self.original_tagname_ = None
        super(ProjectedUnknownCrs, self).__init__()
        self.Unknown = Unknown
        self.validate_String2000(self.Unknown)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProjectedUnknownCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProjectedUnknownCrs.subclass:
            return ProjectedUnknownCrs.subclass(*args_, **kwargs_)
        else:
            return ProjectedUnknownCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Unknown(self): return self.Unknown
    def set_Unknown(self, Unknown): self.Unknown = Unknown
    UnknownProp = property(get_Unknown, set_Unknown)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Unknown is not None or
            super(ProjectedUnknownCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProjectedUnknownCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedUnknownCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProjectedUnknownCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProjectedUnknownCrs'):
        super(ProjectedUnknownCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedUnknownCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProjectedUnknownCrs', fromsubclass_=False, pretty_print=True):
        super(ProjectedUnknownCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ProjectedUnknownCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
            # validate type String2000
            self.validate_String2000(self.Unknown)
        super(ProjectedUnknownCrs, self).buildChildren(child_, node, nodeName_, True)
# end class ProjectedUnknownCrs


class ProjectedWktCrs(AbstractProjectedCrs):
    """ISO 19162-compliant well-known text for the projected CRS"""
    subclass = None
    superclass = AbstractProjectedCrs
    def __init__(self, WellKnownText=None):
        self.original_tagname_ = None
        super(ProjectedWktCrs, self).__init__()
        self.WellKnownText = WellKnownText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProjectedWktCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProjectedWktCrs.subclass:
            return ProjectedWktCrs.subclass(*args_, **kwargs_)
        else:
            return ProjectedWktCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WellKnownText(self): return self.WellKnownText
    def set_WellKnownText(self, WellKnownText): self.WellKnownText = WellKnownText
    WellKnownTextProp = property(get_WellKnownText, set_WellKnownText)
    def hasContent_(self):
        if (
            self.WellKnownText is not None or
            super(ProjectedWktCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProjectedWktCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedWktCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProjectedWktCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProjectedWktCrs'):
        super(ProjectedWktCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedWktCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProjectedWktCrs', fromsubclass_=False, pretty_print=True):
        super(ProjectedWktCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WellKnownText is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWellKnownText>%s</%sWellKnownText>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WellKnownText), input_name='WellKnownText')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ProjectedWktCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WellKnownText':
            WellKnownText_ = child_.text
            WellKnownText_ = self.gds_validate_string(WellKnownText_, node, 'WellKnownText')
            self.WellKnownText = WellKnownText_
        super(ProjectedWktCrs, self).buildChildren(child_, node, nodeName_, True)
# end class ProjectedWktCrs


class VerticalCrs(AbstractObject):
    subclass = None
    superclass = AbstractObject
    def __init__(self, uom=None, Direction=None, AbstractVerticalCrs=None):
        self.original_tagname_ = None
        super(VerticalCrs, self).__init__()
        self.uom = _cast(None, uom)
        self.Direction = Direction
        self.validate_VerticalDirection(self.Direction)
        self.AbstractVerticalCrs = AbstractVerticalCrs
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalCrs.subclass:
            return VerticalCrs.subclass(*args_, **kwargs_)
        else:
            return VerticalCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Direction(self): return self.Direction
    def set_Direction(self, Direction): self.Direction = Direction
    DirectionProp = property(get_Direction, set_Direction)
    def get_AbstractVerticalCrs(self): return self.AbstractVerticalCrs
    def set_AbstractVerticalCrs(self, AbstractVerticalCrs): self.AbstractVerticalCrs = AbstractVerticalCrs
    AbstractVerticalCrsProp = property(get_AbstractVerticalCrs, set_AbstractVerticalCrs)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def validate_VerticalDirection(self, value):
        # Validate type VerticalDirection, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['up', 'down']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VerticalDirection' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Direction is not None or
            self.AbstractVerticalCrs is not None or
            super(VerticalCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VerticalCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VerticalCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VerticalCrs'):
        super(VerticalCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalCrs')
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VerticalCrs', fromsubclass_=False, pretty_print=True):
        super(VerticalCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDirection>%s</%sDirection>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Direction), input_name='Direction')), namespace_, eol_))
        if self.AbstractVerticalCrs is not None:
            self.AbstractVerticalCrs.export(outfile, level, namespace_, name_='AbstractVerticalCrs', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
        super(VerticalCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Direction':
            Direction_ = child_.text
            Direction_ = self.gds_validate_string(Direction_, node, 'Direction')
            self.Direction = Direction_
            # validate type VerticalDirection
            self.validate_VerticalDirection(self.Direction)
        elif nodeName_ == 'AbstractVerticalCrs':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractVerticalCrs> element')
            self.AbstractVerticalCrs = obj_
            obj_.original_tagname_ = 'AbstractVerticalCrs'
        super(VerticalCrs, self).buildChildren(child_, node, nodeName_, True)
# end class VerticalCrs


class VerticalEpsgCrs(AbstractVerticalCrs):
    """This class contains the EPSG code for a vertical CRS."""
    subclass = None
    superclass = AbstractVerticalCrs
    def __init__(self, EpsgCode=None):
        self.original_tagname_ = None
        super(VerticalEpsgCrs, self).__init__()
        self.EpsgCode = EpsgCode
        self.validate_PositiveLong(self.EpsgCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalEpsgCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalEpsgCrs.subclass:
            return VerticalEpsgCrs.subclass(*args_, **kwargs_)
        else:
            return VerticalEpsgCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EpsgCode(self): return self.EpsgCode
    def set_EpsgCode(self, EpsgCode): self.EpsgCode = EpsgCode
    EpsgCodeProp = property(get_EpsgCode, set_EpsgCode)
    def validate_PositiveLong(self, value):
        # Validate type PositiveLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveLong' % {"value" : value} )
    def hasContent_(self):
        if (
            self.EpsgCode is not None or
            super(VerticalEpsgCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VerticalEpsgCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalEpsgCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VerticalEpsgCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VerticalEpsgCrs'):
        super(VerticalEpsgCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalEpsgCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VerticalEpsgCrs', fromsubclass_=False, pretty_print=True):
        super(VerticalEpsgCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EpsgCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEpsgCode>%s</%sEpsgCode>%s' % (namespace_, self.gds_format_integer(self.EpsgCode, input_name='EpsgCode'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VerticalEpsgCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EpsgCode':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'EpsgCode')
            self.EpsgCode = ival_
            # validate type PositiveLong
            self.validate_PositiveLong(self.EpsgCode)
        super(VerticalEpsgCrs, self).buildChildren(child_, node, nodeName_, True)
# end class VerticalEpsgCrs


class VerticalGmlCrs(AbstractVerticalCrs):
    """This is the Energistics encapsulation of the VerticalCrs type from
    GML."""
    subclass = None
    superclass = AbstractVerticalCrs
    def __init__(self, GmlVerticalCrsDefinition=None):
        self.original_tagname_ = None
        super(VerticalGmlCrs, self).__init__()
        self.GmlVerticalCrsDefinition = GmlVerticalCrsDefinition
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalGmlCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalGmlCrs.subclass:
            return VerticalGmlCrs.subclass(*args_, **kwargs_)
        else:
            return VerticalGmlCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GmlVerticalCrsDefinition(self): return self.GmlVerticalCrsDefinition
    def set_GmlVerticalCrsDefinition(self, GmlVerticalCrsDefinition): self.GmlVerticalCrsDefinition = GmlVerticalCrsDefinition
    GmlVerticalCrsDefinitionProp = property(get_GmlVerticalCrsDefinition, set_GmlVerticalCrsDefinition)
    def hasContent_(self):
        if (
            self.GmlVerticalCrsDefinition is not None or
            super(VerticalGmlCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VerticalGmlCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalGmlCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VerticalGmlCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VerticalGmlCrs'):
        super(VerticalGmlCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalGmlCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VerticalGmlCrs', fromsubclass_=False, pretty_print=True):
        super(VerticalGmlCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GmlVerticalCrsDefinition is not None:
            self.GmlVerticalCrsDefinition.export(outfile, level, namespace_, name_='GmlVerticalCrsDefinition', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VerticalGmlCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GmlVerticalCrsDefinition':
            obj_ = VerticalCRSType.factory()
            obj_.build(child_)
            self.GmlVerticalCrsDefinition = obj_
            obj_.original_tagname_ = 'GmlVerticalCrsDefinition'
        super(VerticalGmlCrs, self).buildChildren(child_, node, nodeName_, True)
# end class VerticalGmlCrs


class VerticalLocalAuthorityCrs(AbstractVerticalCrs):
    """This class contains a code for a vertical CRS according to a local
    authority. This would be used in a case where a company or
    regulatory regime has chosen not to use EPSG codes."""
    subclass = None
    superclass = AbstractVerticalCrs
    def __init__(self, LocalAuthorityCrsName=None):
        self.original_tagname_ = None
        super(VerticalLocalAuthorityCrs, self).__init__()
        self.LocalAuthorityCrsName = LocalAuthorityCrsName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalLocalAuthorityCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalLocalAuthorityCrs.subclass:
            return VerticalLocalAuthorityCrs.subclass(*args_, **kwargs_)
        else:
            return VerticalLocalAuthorityCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocalAuthorityCrsName(self): return self.LocalAuthorityCrsName
    def set_LocalAuthorityCrsName(self, LocalAuthorityCrsName): self.LocalAuthorityCrsName = LocalAuthorityCrsName
    LocalAuthorityCrsNameProp = property(get_LocalAuthorityCrsName, set_LocalAuthorityCrsName)
    def hasContent_(self):
        if (
            self.LocalAuthorityCrsName is not None or
            super(VerticalLocalAuthorityCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VerticalLocalAuthorityCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalLocalAuthorityCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VerticalLocalAuthorityCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VerticalLocalAuthorityCrs'):
        super(VerticalLocalAuthorityCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalLocalAuthorityCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VerticalLocalAuthorityCrs', fromsubclass_=False, pretty_print=True):
        super(VerticalLocalAuthorityCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LocalAuthorityCrsName is not None:
            self.LocalAuthorityCrsName.export(outfile, level, namespace_, name_='LocalAuthorityCrsName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VerticalLocalAuthorityCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LocalAuthorityCrsName':
            obj_ = AuthorityQualifiedName.factory()
            obj_.build(child_)
            self.LocalAuthorityCrsName = obj_
            obj_.original_tagname_ = 'LocalAuthorityCrsName'
        super(VerticalLocalAuthorityCrs, self).buildChildren(child_, node, nodeName_, True)
# end class VerticalLocalAuthorityCrs


class VerticalUnknownCrs(AbstractVerticalCrs):
    """This class is used in a case where the coordinate reference system
    is either unknown or is intentionally not being transferred. In
    this case, the uom and Direction need to be provided on the
    VerticalCrs class."""
    subclass = None
    superclass = AbstractVerticalCrs
    def __init__(self, Unknown=None):
        self.original_tagname_ = None
        super(VerticalUnknownCrs, self).__init__()
        self.Unknown = Unknown
        self.validate_String2000(self.Unknown)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalUnknownCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalUnknownCrs.subclass:
            return VerticalUnknownCrs.subclass(*args_, **kwargs_)
        else:
            return VerticalUnknownCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Unknown(self): return self.Unknown
    def set_Unknown(self, Unknown): self.Unknown = Unknown
    UnknownProp = property(get_Unknown, set_Unknown)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Unknown is not None or
            super(VerticalUnknownCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VerticalUnknownCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalUnknownCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VerticalUnknownCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VerticalUnknownCrs'):
        super(VerticalUnknownCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalUnknownCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VerticalUnknownCrs', fromsubclass_=False, pretty_print=True):
        super(VerticalUnknownCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VerticalUnknownCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
            # validate type String2000
            self.validate_String2000(self.Unknown)
        super(VerticalUnknownCrs, self).buildChildren(child_, node, nodeName_, True)
# end class VerticalUnknownCrs


class VerticalWktCrs(AbstractVerticalCrs):
    """ISO 19162-compliant well-known text for the vertical CRS"""
    subclass = None
    superclass = AbstractVerticalCrs
    def __init__(self, WellKnownText=None):
        self.original_tagname_ = None
        super(VerticalWktCrs, self).__init__()
        self.WellKnownText = WellKnownText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalWktCrs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalWktCrs.subclass:
            return VerticalWktCrs.subclass(*args_, **kwargs_)
        else:
            return VerticalWktCrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WellKnownText(self): return self.WellKnownText
    def set_WellKnownText(self, WellKnownText): self.WellKnownText = WellKnownText
    WellKnownTextProp = property(get_WellKnownText, set_WellKnownText)
    def hasContent_(self):
        if (
            self.WellKnownText is not None or
            super(VerticalWktCrs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VerticalWktCrs', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalWktCrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VerticalWktCrs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VerticalWktCrs'):
        super(VerticalWktCrs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalWktCrs')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VerticalWktCrs', fromsubclass_=False, pretty_print=True):
        super(VerticalWktCrs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WellKnownText is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWellKnownText>%s</%sWellKnownText>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WellKnownText), input_name='WellKnownText')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VerticalWktCrs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WellKnownText':
            WellKnownText_ = child_.text
            WellKnownText_ = self.gds_validate_string(WellKnownText_, node, 'WellKnownText')
            self.WellKnownText = WellKnownText_
        super(VerticalWktCrs, self).buildChildren(child_, node, nodeName_, True)
# end class VerticalWktCrs


class DataAssuranceRecord(AbstractObject):
    """A little XML document describing whether or not a particular data
    object conforms with a pre-defined policy which consists of at
    least one rule."""
    subclass = None
    superclass = AbstractObject
    def __init__(self, PolicyId=None, PolicyName=None, ReferencedElementName=None, ReferencedElementUid=None, Origin=None, Conformance=None, Date=None, Comment=None, FailingRules=None, IndexRange=None, ReferencedData=None):
        self.original_tagname_ = None
        super(DataAssuranceRecord, self).__init__()
        self.PolicyId = PolicyId
        self.validate_String64(self.PolicyId)
        self.PolicyName = PolicyName
        self.validate_String2000(self.PolicyName)
        self.ReferencedElementName = ReferencedElementName
        self.validate_String64(self.ReferencedElementName)
        self.ReferencedElementUid = ReferencedElementUid
        self.validate_String64(self.ReferencedElementUid)
        self.Origin = Origin
        self.Conformance = Conformance
        self.Date = Date
        self.validate_TimeStamp(self.Date)
        self.Comment = Comment
        if FailingRules is None:
            self.FailingRules = []
        else:
            self.FailingRules = FailingRules
        self.IndexRange = IndexRange
        self.ReferencedData = ReferencedData
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataAssuranceRecord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataAssuranceRecord.subclass:
            return DataAssuranceRecord.subclass(*args_, **kwargs_)
        else:
            return DataAssuranceRecord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PolicyId(self): return self.PolicyId
    def set_PolicyId(self, PolicyId): self.PolicyId = PolicyId
    PolicyIdProp = property(get_PolicyId, set_PolicyId)
    def get_PolicyName(self): return self.PolicyName
    def set_PolicyName(self, PolicyName): self.PolicyName = PolicyName
    PolicyNameProp = property(get_PolicyName, set_PolicyName)
    def get_ReferencedElementName(self): return self.ReferencedElementName
    def set_ReferencedElementName(self, ReferencedElementName): self.ReferencedElementName = ReferencedElementName
    ReferencedElementNameProp = property(get_ReferencedElementName, set_ReferencedElementName)
    def get_ReferencedElementUid(self): return self.ReferencedElementUid
    def set_ReferencedElementUid(self, ReferencedElementUid): self.ReferencedElementUid = ReferencedElementUid
    ReferencedElementUidProp = property(get_ReferencedElementUid, set_ReferencedElementUid)
    def get_Origin(self): return self.Origin
    def set_Origin(self, Origin): self.Origin = Origin
    OriginProp = property(get_Origin, set_Origin)
    def get_Conformance(self): return self.Conformance
    def set_Conformance(self, Conformance): self.Conformance = Conformance
    ConformanceProp = property(get_Conformance, set_Conformance)
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    DateProp = property(get_Date, set_Date)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_FailingRules(self): return self.FailingRules
    def set_FailingRules(self, FailingRules): self.FailingRules = FailingRules
    def add_FailingRules(self, value): self.FailingRules.append(value)
    def insert_FailingRules_at(self, index, value): self.FailingRules.insert(index, value)
    def replace_FailingRules_at(self, index, value): self.FailingRules[index] = value
    FailingRulesProp = property(get_FailingRules, set_FailingRules)
    def get_IndexRange(self): return self.IndexRange
    def set_IndexRange(self, IndexRange): self.IndexRange = IndexRange
    IndexRangeProp = property(get_IndexRange, set_IndexRange)
    def get_ReferencedData(self): return self.ReferencedData
    def set_ReferencedData(self, ReferencedData): self.ReferencedData = ReferencedData
    ReferencedDataProp = property(get_ReferencedData, set_ReferencedData)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def validate_TimeStamp(self, value):
        # Validate type TimeStamp, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TimeStamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TimeStamp_patterns_, ))
    validate_TimeStamp_patterns_ = [['^.+T.+[Z+\\-].*$']]
    def hasContent_(self):
        if (
            self.PolicyId is not None or
            self.PolicyName is not None or
            self.ReferencedElementName is not None or
            self.ReferencedElementUid is not None or
            self.Origin is not None or
            self.Conformance is not None or
            self.Date is not None or
            self.Comment is not None or
            self.FailingRules or
            self.IndexRange is not None or
            self.ReferencedData is not None or
            super(DataAssuranceRecord, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DataAssuranceRecord', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataAssuranceRecord')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DataAssuranceRecord', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DataAssuranceRecord'):
        super(DataAssuranceRecord, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DataAssuranceRecord')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DataAssuranceRecord', fromsubclass_=False, pretty_print=True):
        super(DataAssuranceRecord, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PolicyId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPolicyId>%s</%sPolicyId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PolicyId), input_name='PolicyId')), namespace_, eol_))
        if self.PolicyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPolicyName>%s</%sPolicyName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PolicyName), input_name='PolicyName')), namespace_, eol_))
        if self.ReferencedElementName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReferencedElementName>%s</%sReferencedElementName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ReferencedElementName), input_name='ReferencedElementName')), namespace_, eol_))
        if self.ReferencedElementUid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReferencedElementUid>%s</%sReferencedElementUid>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ReferencedElementUid), input_name='ReferencedElementUid')), namespace_, eol_))
        if self.Origin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrigin>%s</%sOrigin>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Origin), input_name='Origin')), namespace_, eol_))
        if self.Conformance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConformance>%s</%sConformance>%s' % (namespace_, self.gds_format_boolean(self.Conformance, input_name='Conformance'), namespace_, eol_))
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDate>%s</%sDate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Date), input_name='Date')), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
        for FailingRules_ in self.FailingRules:
            FailingRules_.export(outfile, level, namespace_, name_='FailingRules', pretty_print=pretty_print)
        if self.IndexRange is not None:
            self.IndexRange.export(outfile, level, namespace_, name_='IndexRange', pretty_print=pretty_print)
        if self.ReferencedData is not None:
            self.ReferencedData.export(outfile, level, namespace_, name_='ReferencedData', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DataAssuranceRecord, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PolicyId':
            PolicyId_ = child_.text
            PolicyId_ = self.gds_validate_string(PolicyId_, node, 'PolicyId')
            self.PolicyId = PolicyId_
            # validate type String64
            self.validate_String64(self.PolicyId)
        elif nodeName_ == 'PolicyName':
            PolicyName_ = child_.text
            PolicyName_ = self.gds_validate_string(PolicyName_, node, 'PolicyName')
            self.PolicyName = PolicyName_
            # validate type String2000
            self.validate_String2000(self.PolicyName)
        elif nodeName_ == 'ReferencedElementName':
            ReferencedElementName_ = child_.text
            ReferencedElementName_ = self.gds_validate_string(ReferencedElementName_, node, 'ReferencedElementName')
            self.ReferencedElementName = ReferencedElementName_
            # validate type String64
            self.validate_String64(self.ReferencedElementName)
        elif nodeName_ == 'ReferencedElementUid':
            ReferencedElementUid_ = child_.text
            ReferencedElementUid_ = self.gds_validate_string(ReferencedElementUid_, node, 'ReferencedElementUid')
            self.ReferencedElementUid = ReferencedElementUid_
            # validate type String64
            self.validate_String64(self.ReferencedElementUid)
        elif nodeName_ == 'Origin':
            Origin_ = child_.text
            Origin_ = self.gds_validate_string(Origin_, node, 'Origin')
            self.Origin = Origin_
        elif nodeName_ == 'Conformance':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Conformance')
            self.Conformance = ival_
        elif nodeName_ == 'Date':
            Date_ = child_.text
            Date_ = self.gds_validate_string(Date_, node, 'Date')
            self.Date = Date_
            # validate type TimeStamp
            self.validate_TimeStamp(self.Date)
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
        elif nodeName_ == 'FailingRules':
            obj_ = FailingRule.factory()
            obj_.build(child_)
            self.FailingRules.append(obj_)
            obj_.original_tagname_ = 'FailingRules'
        elif nodeName_ == 'IndexRange':
            obj_ = IndexRange.factory()
            obj_.build(child_)
            self.IndexRange = obj_
            obj_.original_tagname_ = 'IndexRange'
        elif nodeName_ == 'ReferencedData':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.ReferencedData = obj_
            obj_.original_tagname_ = 'ReferencedData'
        super(DataAssuranceRecord, self).buildChildren(child_, node, nodeName_, True)
# end class DataAssuranceRecord


class FailingRule(GeneratedsSuper):
    """The FailingRule class holds summary information on which of the
    rules within a policy failed."""
    subclass = None
    superclass = None
    def __init__(self, RuleId=None, RuleName=None, Severity=None, FailingRuleExtensions=None):
        self.original_tagname_ = None
        self.RuleId = RuleId
        self.validate_String64(self.RuleId)
        self.RuleName = RuleName
        self.validate_String2000(self.RuleName)
        self.Severity = Severity
        self.validate_String64(self.Severity)
        if FailingRuleExtensions is None:
            self.FailingRuleExtensions = []
        else:
            self.FailingRuleExtensions = FailingRuleExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FailingRule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FailingRule.subclass:
            return FailingRule.subclass(*args_, **kwargs_)
        else:
            return FailingRule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RuleId(self): return self.RuleId
    def set_RuleId(self, RuleId): self.RuleId = RuleId
    RuleIdProp = property(get_RuleId, set_RuleId)
    def get_RuleName(self): return self.RuleName
    def set_RuleName(self, RuleName): self.RuleName = RuleName
    RuleNameProp = property(get_RuleName, set_RuleName)
    def get_Severity(self): return self.Severity
    def set_Severity(self, Severity): self.Severity = Severity
    SeverityProp = property(get_Severity, set_Severity)
    def get_FailingRuleExtensions(self): return self.FailingRuleExtensions
    def set_FailingRuleExtensions(self, FailingRuleExtensions): self.FailingRuleExtensions = FailingRuleExtensions
    def add_FailingRuleExtensions(self, value): self.FailingRuleExtensions.append(value)
    def insert_FailingRuleExtensions_at(self, index, value): self.FailingRuleExtensions.insert(index, value)
    def replace_FailingRuleExtensions_at(self, index, value): self.FailingRuleExtensions[index] = value
    FailingRuleExtensionsProp = property(get_FailingRuleExtensions, set_FailingRuleExtensions)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.RuleId is not None or
            self.RuleName is not None or
            self.Severity is not None or
            self.FailingRuleExtensions
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FailingRule', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FailingRule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FailingRule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FailingRule'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FailingRule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RuleId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRuleId>%s</%sRuleId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RuleId), input_name='RuleId')), namespace_, eol_))
        if self.RuleName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRuleName>%s</%sRuleName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RuleName), input_name='RuleName')), namespace_, eol_))
        if self.Severity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSeverity>%s</%sSeverity>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Severity), input_name='Severity')), namespace_, eol_))
        for FailingRuleExtensions_ in self.FailingRuleExtensions:
            FailingRuleExtensions_.export(outfile, level, namespace_, name_='FailingRuleExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RuleId':
            RuleId_ = child_.text
            RuleId_ = self.gds_validate_string(RuleId_, node, 'RuleId')
            self.RuleId = RuleId_
            # validate type String64
            self.validate_String64(self.RuleId)
        elif nodeName_ == 'RuleName':
            RuleName_ = child_.text
            RuleName_ = self.gds_validate_string(RuleName_, node, 'RuleName')
            self.RuleName = RuleName_
            # validate type String2000
            self.validate_String2000(self.RuleName)
        elif nodeName_ == 'Severity':
            Severity_ = child_.text
            Severity_ = self.gds_validate_string(Severity_, node, 'Severity')
            self.Severity = Severity_
            # validate type String64
            self.validate_String64(self.Severity)
        elif nodeName_ == 'FailingRuleExtensions':
            obj_ = ExtensionNameValue.factory()
            obj_.build(child_)
            self.FailingRuleExtensions.append(obj_)
            obj_.original_tagname_ = 'FailingRuleExtensions'
# end class FailingRule


class IndexRange(GeneratedsSuper):
    """In the case that the ReferencedData is indexed and the conformance
    with the DataAssurance policy applies to a range within that
    index space, this class represents that range. The elements are
    string types because the index could be of numerous data types,
    including integer, float and date."""
    subclass = None
    superclass = None
    def __init__(self, IndexMinimum=None, IndexMaximum=None):
        self.original_tagname_ = None
        self.IndexMinimum = IndexMinimum
        self.validate_String64(self.IndexMinimum)
        self.IndexMaximum = IndexMaximum
        self.validate_String64(self.IndexMaximum)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndexRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndexRange.subclass:
            return IndexRange.subclass(*args_, **kwargs_)
        else:
            return IndexRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IndexMinimum(self): return self.IndexMinimum
    def set_IndexMinimum(self, IndexMinimum): self.IndexMinimum = IndexMinimum
    IndexMinimumProp = property(get_IndexMinimum, set_IndexMinimum)
    def get_IndexMaximum(self): return self.IndexMaximum
    def set_IndexMaximum(self, IndexMaximum): self.IndexMaximum = IndexMaximum
    IndexMaximumProp = property(get_IndexMaximum, set_IndexMaximum)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.IndexMinimum is not None or
            self.IndexMaximum is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='IndexRange', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndexRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='IndexRange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='IndexRange'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='IndexRange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IndexMinimum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndexMinimum>%s</%sIndexMinimum>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.IndexMinimum), input_name='IndexMinimum')), namespace_, eol_))
        if self.IndexMaximum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndexMaximum>%s</%sIndexMaximum>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.IndexMaximum), input_name='IndexMaximum')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IndexMinimum':
            IndexMinimum_ = child_.text
            IndexMinimum_ = self.gds_validate_string(IndexMinimum_, node, 'IndexMinimum')
            self.IndexMinimum = IndexMinimum_
            # validate type String64
            self.validate_String64(self.IndexMinimum)
        elif nodeName_ == 'IndexMaximum':
            IndexMaximum_ = child_.text
            IndexMaximum_ = self.gds_validate_string(IndexMaximum_, node, 'IndexMaximum')
            self.IndexMaximum = IndexMaximum_
            # validate type String64
            self.validate_String64(self.IndexMaximum)
# end class IndexRange


class AbstractGraphicalInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TargetObject=None):
        self.original_tagname_ = None
        self.TargetObject = TargetObject
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractGraphicalInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractGraphicalInformation.subclass:
            return AbstractGraphicalInformation.subclass(*args_, **kwargs_)
        else:
            return AbstractGraphicalInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TargetObject(self): return self.TargetObject
    def set_TargetObject(self, TargetObject): self.TargetObject = TargetObject
    TargetObjectProp = property(get_TargetObject, set_TargetObject)
    def hasContent_(self):
        if (
            self.TargetObject is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractGraphicalInformation', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGraphicalInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractGraphicalInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractGraphicalInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractGraphicalInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TargetObject is not None:
            self.TargetObject.export(outfile, level, namespace_, name_='TargetObject', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TargetObject':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.TargetObject = obj_
            obj_.original_tagname_ = 'TargetObject'
# end class AbstractGraphicalInformation


class GraphicalInformationSet(AbstractObject):
    subclass = None
    superclass = AbstractObject
    def __init__(self, GraphicalInformation=None):
        self.original_tagname_ = None
        super(GraphicalInformationSet, self).__init__()
        if GraphicalInformation is None:
            self.GraphicalInformation = []
        else:
            self.GraphicalInformation = GraphicalInformation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GraphicalInformationSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GraphicalInformationSet.subclass:
            return GraphicalInformationSet.subclass(*args_, **kwargs_)
        else:
            return GraphicalInformationSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GraphicalInformation(self): return self.GraphicalInformation
    def set_GraphicalInformation(self, GraphicalInformation): self.GraphicalInformation = GraphicalInformation
    def add_GraphicalInformation(self, value): self.GraphicalInformation.append(value)
    def insert_GraphicalInformation_at(self, index, value): self.GraphicalInformation.insert(index, value)
    def replace_GraphicalInformation_at(self, index, value): self.GraphicalInformation[index] = value
    GraphicalInformationProp = property(get_GraphicalInformation, set_GraphicalInformation)
    def hasContent_(self):
        if (
            self.GraphicalInformation or
            super(GraphicalInformationSet, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GraphicalInformationSet', namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2" xmlns:eml="http://www.energistics.org/energyml/data/commonv2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GraphicalInformationSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GraphicalInformationSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GraphicalInformationSet'):
        super(GraphicalInformationSet, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GraphicalInformationSet')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GraphicalInformationSet', fromsubclass_=False, pretty_print=True):
        super(GraphicalInformationSet, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for GraphicalInformation_ in self.GraphicalInformation:
            GraphicalInformation_.export(outfile, level, namespace_, name_='GraphicalInformation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GraphicalInformationSet, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GraphicalInformation':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <GraphicalInformation> element')
            self.GraphicalInformation.append(obj_)
            obj_.original_tagname_ = 'GraphicalInformation'
        super(GraphicalInformationSet, self).buildChildren(child_, node, nodeName_, True)
# end class GraphicalInformationSet


class AbsolutePressure(AbstractPressureValue):
    subclass = None
    superclass = AbstractPressureValue
    def __init__(self, AbsolutePressure_member=None):
        self.original_tagname_ = None
        super(AbsolutePressure, self).__init__()
        self.AbsolutePressure = AbsolutePressure_member
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbsolutePressure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbsolutePressure.subclass:
            return AbsolutePressure.subclass(*args_, **kwargs_)
        else:
            return AbsolutePressure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsolutePressure(self): return self.AbsolutePressure
    def set_AbsolutePressure(self, AbsolutePressure): self.AbsolutePressure = AbsolutePressure
    AbsolutePressureProp = property(get_AbsolutePressure, set_AbsolutePressure)
    def hasContent_(self):
        if (
            self.AbsolutePressure is not None or
            super(AbsolutePressure, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbsolutePressure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbsolutePressure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbsolutePressure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbsolutePressure'):
        super(AbsolutePressure, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbsolutePressure')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbsolutePressure', fromsubclass_=False, pretty_print=True):
        super(AbsolutePressure, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AbsolutePressure is not None:
            self.AbsolutePressure.export(outfile, level, namespace_, name_='AbsolutePressure', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AbsolutePressure, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsolutePressure':
            obj_ = PressureMeasureExt.factory()
            obj_.build(child_)
            self.AbsolutePressure = obj_
            obj_.original_tagname_ = 'AbsolutePressure'
        super(AbsolutePressure, self).buildChildren(child_, node, nodeName_, True)
# end class AbsolutePressure


class AbstractDQ_Result_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None):
        self.original_tagname_ = None
        super(AbstractDQ_Result_Type, self).__init__(id, uuid, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractDQ_Result_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractDQ_Result_Type.subclass:
            return AbstractDQ_Result_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractDQ_Result_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(AbstractDQ_Result_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractDQ_Result_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_Result_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractDQ_Result_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractDQ_Result_Type'):
        super(AbstractDQ_Result_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_Result_Type')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractDQ_Result_Type', fromsubclass_=False, pretty_print=True):
        super(AbstractDQ_Result_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractDQ_Result_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractDQ_Result_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractDQ_Result_Type


class CI_Series_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, name=None, issueIdentification=None, page=None):
        self.original_tagname_ = None
        super(CI_Series_Type, self).__init__(id, uuid, )
        self.name = name
        self.issueIdentification = issueIdentification
        self.page = page
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_Series_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_Series_Type.subclass:
            return CI_Series_Type.subclass(*args_, **kwargs_)
        else:
            return CI_Series_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_issueIdentification(self): return self.issueIdentification
    def set_issueIdentification(self, issueIdentification): self.issueIdentification = issueIdentification
    issueIdentificationProp = property(get_issueIdentification, set_issueIdentification)
    def get_page(self): return self.page
    def set_page(self, page): self.page = page
    pageProp = property(get_page, set_page)
    def hasContent_(self):
        if (
            self.name is not None or
            self.issueIdentification is not None or
            self.page is not None or
            super(CI_Series_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_Series_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Series_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_Series_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_Series_Type'):
        super(CI_Series_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Series_Type')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_Series_Type', fromsubclass_=False, pretty_print=True):
        super(CI_Series_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        if self.issueIdentification is not None:
            self.issueIdentification.export(outfile, level, namespace_, name_='issueIdentification', pretty_print=pretty_print)
        if self.page is not None:
            self.page.export(outfile, level, namespace_, name_='page', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_Series_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'issueIdentification':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.issueIdentification = obj_
            obj_.original_tagname_ = 'issueIdentification'
        elif nodeName_ == 'page':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.page = obj_
            obj_.original_tagname_ = 'page'
        super(CI_Series_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_Series_Type


class CI_OnlineResource_Type(AbstractObject_Type):
    """Information about online sources from which the dataset,
    specification, or community profile name and extended metadata
    elements can be obtained."""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, linkage=None, protocol=None, applicationProfile=None, name=None, description=None, function=None):
        self.original_tagname_ = None
        super(CI_OnlineResource_Type, self).__init__(id, uuid, )
        self.linkage = linkage
        self.protocol = protocol
        self.applicationProfile = applicationProfile
        self.name = name
        self.description = description
        self.function = function
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_OnlineResource_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_OnlineResource_Type.subclass:
            return CI_OnlineResource_Type.subclass(*args_, **kwargs_)
        else:
            return CI_OnlineResource_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_linkage(self): return self.linkage
    def set_linkage(self, linkage): self.linkage = linkage
    linkageProp = property(get_linkage, set_linkage)
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    protocolProp = property(get_protocol, set_protocol)
    def get_applicationProfile(self): return self.applicationProfile
    def set_applicationProfile(self, applicationProfile): self.applicationProfile = applicationProfile
    applicationProfileProp = property(get_applicationProfile, set_applicationProfile)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_function(self): return self.function
    def set_function(self, function): self.function = function
    functionProp = property(get_function, set_function)
    def hasContent_(self):
        if (
            self.linkage is not None or
            self.protocol is not None or
            self.applicationProfile is not None or
            self.name is not None or
            self.description is not None or
            self.function is not None or
            super(CI_OnlineResource_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_OnlineResource_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_OnlineResource_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_OnlineResource_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_OnlineResource_Type'):
        super(CI_OnlineResource_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_OnlineResource_Type')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_OnlineResource_Type', fromsubclass_=False, pretty_print=True):
        super(CI_OnlineResource_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.linkage is not None:
            self.linkage.export(outfile, level, namespace_, name_='linkage', pretty_print=pretty_print)
        if self.protocol is not None:
            self.protocol.export(outfile, level, namespace_, name_='protocol', pretty_print=pretty_print)
        if self.applicationProfile is not None:
            self.applicationProfile.export(outfile, level, namespace_, name_='applicationProfile', pretty_print=pretty_print)
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        if self.function is not None:
            self.function.export(outfile, level, namespace_, name_='function', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_OnlineResource_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'linkage':
            obj_ = URL_PropertyType.factory()
            obj_.build(child_)
            self.linkage = obj_
            obj_.original_tagname_ = 'linkage'
        elif nodeName_ == 'protocol':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.protocol = obj_
            obj_.original_tagname_ = 'protocol'
        elif nodeName_ == 'applicationProfile':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.applicationProfile = obj_
            obj_.original_tagname_ = 'applicationProfile'
        elif nodeName_ == 'name':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'description':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'function':
            obj_ = CI_OnLineFunctionCode_PropertyType.factory()
            obj_.build(child_)
            self.function = obj_
            obj_.original_tagname_ = 'function'
        super(CI_OnlineResource_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_OnlineResource_Type


class CI_Address_Type(AbstractObject_Type):
    """Location of the responsible individual or organisation"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, deliveryPoint=None, city=None, administrativeArea=None, postalCode=None, country=None, electronicMailAddress=None):
        self.original_tagname_ = None
        super(CI_Address_Type, self).__init__(id, uuid, )
        if deliveryPoint is None:
            self.deliveryPoint = []
        else:
            self.deliveryPoint = deliveryPoint
        self.city = city
        self.administrativeArea = administrativeArea
        self.postalCode = postalCode
        self.country = country
        if electronicMailAddress is None:
            self.electronicMailAddress = []
        else:
            self.electronicMailAddress = electronicMailAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_Address_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_Address_Type.subclass:
            return CI_Address_Type.subclass(*args_, **kwargs_)
        else:
            return CI_Address_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryPoint(self): return self.deliveryPoint
    def set_deliveryPoint(self, deliveryPoint): self.deliveryPoint = deliveryPoint
    def add_deliveryPoint(self, value): self.deliveryPoint.append(value)
    def insert_deliveryPoint_at(self, index, value): self.deliveryPoint.insert(index, value)
    def replace_deliveryPoint_at(self, index, value): self.deliveryPoint[index] = value
    deliveryPointProp = property(get_deliveryPoint, set_deliveryPoint)
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    cityProp = property(get_city, set_city)
    def get_administrativeArea(self): return self.administrativeArea
    def set_administrativeArea(self, administrativeArea): self.administrativeArea = administrativeArea
    administrativeAreaProp = property(get_administrativeArea, set_administrativeArea)
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    postalCodeProp = property(get_postalCode, set_postalCode)
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    countryProp = property(get_country, set_country)
    def get_electronicMailAddress(self): return self.electronicMailAddress
    def set_electronicMailAddress(self, electronicMailAddress): self.electronicMailAddress = electronicMailAddress
    def add_electronicMailAddress(self, value): self.electronicMailAddress.append(value)
    def insert_electronicMailAddress_at(self, index, value): self.electronicMailAddress.insert(index, value)
    def replace_electronicMailAddress_at(self, index, value): self.electronicMailAddress[index] = value
    electronicMailAddressProp = property(get_electronicMailAddress, set_electronicMailAddress)
    def hasContent_(self):
        if (
            self.deliveryPoint or
            self.city is not None or
            self.administrativeArea is not None or
            self.postalCode is not None or
            self.country is not None or
            self.electronicMailAddress or
            super(CI_Address_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_Address_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Address_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_Address_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_Address_Type'):
        super(CI_Address_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Address_Type')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_Address_Type', fromsubclass_=False, pretty_print=True):
        super(CI_Address_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for deliveryPoint_ in self.deliveryPoint:
            deliveryPoint_.export(outfile, level, namespace_, name_='deliveryPoint', pretty_print=pretty_print)
        if self.city is not None:
            self.city.export(outfile, level, namespace_, name_='city', pretty_print=pretty_print)
        if self.administrativeArea is not None:
            self.administrativeArea.export(outfile, level, namespace_, name_='administrativeArea', pretty_print=pretty_print)
        if self.postalCode is not None:
            self.postalCode.export(outfile, level, namespace_, name_='postalCode', pretty_print=pretty_print)
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
        for electronicMailAddress_ in self.electronicMailAddress:
            electronicMailAddress_.export(outfile, level, namespace_, name_='electronicMailAddress', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_Address_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deliveryPoint':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.deliveryPoint.append(obj_)
            obj_.original_tagname_ = 'deliveryPoint'
        elif nodeName_ == 'city':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.city = obj_
            obj_.original_tagname_ = 'city'
        elif nodeName_ == 'administrativeArea':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.administrativeArea = obj_
            obj_.original_tagname_ = 'administrativeArea'
        elif nodeName_ == 'postalCode':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.postalCode = obj_
            obj_.original_tagname_ = 'postalCode'
        elif nodeName_ == 'country':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'electronicMailAddress':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.electronicMailAddress.append(obj_)
            obj_.original_tagname_ = 'electronicMailAddress'
        super(CI_Address_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_Address_Type


class CI_Telephone_Type(AbstractObject_Type):
    """Telephone numbers for contacting the responsible individual or
    organisation"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, voice=None, facsimile=None):
        self.original_tagname_ = None
        super(CI_Telephone_Type, self).__init__(id, uuid, )
        if voice is None:
            self.voice = []
        else:
            self.voice = voice
        if facsimile is None:
            self.facsimile = []
        else:
            self.facsimile = facsimile
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_Telephone_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_Telephone_Type.subclass:
            return CI_Telephone_Type.subclass(*args_, **kwargs_)
        else:
            return CI_Telephone_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_voice(self): return self.voice
    def set_voice(self, voice): self.voice = voice
    def add_voice(self, value): self.voice.append(value)
    def insert_voice_at(self, index, value): self.voice.insert(index, value)
    def replace_voice_at(self, index, value): self.voice[index] = value
    voiceProp = property(get_voice, set_voice)
    def get_facsimile(self): return self.facsimile
    def set_facsimile(self, facsimile): self.facsimile = facsimile
    def add_facsimile(self, value): self.facsimile.append(value)
    def insert_facsimile_at(self, index, value): self.facsimile.insert(index, value)
    def replace_facsimile_at(self, index, value): self.facsimile[index] = value
    facsimileProp = property(get_facsimile, set_facsimile)
    def hasContent_(self):
        if (
            self.voice or
            self.facsimile or
            super(CI_Telephone_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_Telephone_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Telephone_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_Telephone_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_Telephone_Type'):
        super(CI_Telephone_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Telephone_Type')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_Telephone_Type', fromsubclass_=False, pretty_print=True):
        super(CI_Telephone_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for voice_ in self.voice:
            voice_.export(outfile, level, namespace_, name_='voice', pretty_print=pretty_print)
        for facsimile_ in self.facsimile:
            facsimile_.export(outfile, level, namespace_, name_='facsimile', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_Telephone_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'voice':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.voice.append(obj_)
            obj_.original_tagname_ = 'voice'
        elif nodeName_ == 'facsimile':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.facsimile.append(obj_)
            obj_.original_tagname_ = 'facsimile'
        super(CI_Telephone_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_Telephone_Type


class CI_Contact_Type(AbstractObject_Type):
    """Information required enabling contact with the responsible person
    and/or organisation"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, phone=None, address=None, onlineResource=None, hoursOfService=None, contactInstructions=None):
        self.original_tagname_ = None
        super(CI_Contact_Type, self).__init__(id, uuid, )
        self.phone = phone
        self.address = address
        self.onlineResource = onlineResource
        self.hoursOfService = hoursOfService
        self.contactInstructions = contactInstructions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_Contact_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_Contact_Type.subclass:
            return CI_Contact_Type.subclass(*args_, **kwargs_)
        else:
            return CI_Contact_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_phone(self): return self.phone
    def set_phone(self, phone): self.phone = phone
    phoneProp = property(get_phone, set_phone)
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    addressProp = property(get_address, set_address)
    def get_onlineResource(self): return self.onlineResource
    def set_onlineResource(self, onlineResource): self.onlineResource = onlineResource
    onlineResourceProp = property(get_onlineResource, set_onlineResource)
    def get_hoursOfService(self): return self.hoursOfService
    def set_hoursOfService(self, hoursOfService): self.hoursOfService = hoursOfService
    hoursOfServiceProp = property(get_hoursOfService, set_hoursOfService)
    def get_contactInstructions(self): return self.contactInstructions
    def set_contactInstructions(self, contactInstructions): self.contactInstructions = contactInstructions
    contactInstructionsProp = property(get_contactInstructions, set_contactInstructions)
    def hasContent_(self):
        if (
            self.phone is not None or
            self.address is not None or
            self.onlineResource is not None or
            self.hoursOfService is not None or
            self.contactInstructions is not None or
            super(CI_Contact_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_Contact_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Contact_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_Contact_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_Contact_Type'):
        super(CI_Contact_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Contact_Type')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_Contact_Type', fromsubclass_=False, pretty_print=True):
        super(CI_Contact_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.phone is not None:
            self.phone.export(outfile, level, namespace_, name_='phone', pretty_print=pretty_print)
        if self.address is not None:
            self.address.export(outfile, level, namespace_, name_='address', pretty_print=pretty_print)
        if self.onlineResource is not None:
            self.onlineResource.export(outfile, level, namespace_, name_='onlineResource', pretty_print=pretty_print)
        if self.hoursOfService is not None:
            self.hoursOfService.export(outfile, level, namespace_, name_='hoursOfService', pretty_print=pretty_print)
        if self.contactInstructions is not None:
            self.contactInstructions.export(outfile, level, namespace_, name_='contactInstructions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_Contact_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'phone':
            obj_ = CI_Telephone_PropertyType.factory()
            obj_.build(child_)
            self.phone = obj_
            obj_.original_tagname_ = 'phone'
        elif nodeName_ == 'address':
            obj_ = CI_Address_PropertyType.factory()
            obj_.build(child_)
            self.address = obj_
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'onlineResource':
            obj_ = CI_OnlineResource_PropertyType.factory()
            obj_.build(child_)
            self.onlineResource = obj_
            obj_.original_tagname_ = 'onlineResource'
        elif nodeName_ == 'hoursOfService':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.hoursOfService = obj_
            obj_.original_tagname_ = 'hoursOfService'
        elif nodeName_ == 'contactInstructions':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.contactInstructions = obj_
            obj_.original_tagname_ = 'contactInstructions'
        super(CI_Contact_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_Contact_Type


class CI_ResponsibleParty_Type(AbstractObject_Type):
    """Identification of, and means of communication with, person(s) and
    organisations associated with the dataset"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, individualName=None, organisationName=None, positionName=None, contactInfo=None, role=None):
        self.original_tagname_ = None
        super(CI_ResponsibleParty_Type, self).__init__(id, uuid, )
        self.individualName = individualName
        self.organisationName = organisationName
        self.positionName = positionName
        self.contactInfo = contactInfo
        self.role = role
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_ResponsibleParty_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_ResponsibleParty_Type.subclass:
            return CI_ResponsibleParty_Type.subclass(*args_, **kwargs_)
        else:
            return CI_ResponsibleParty_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_individualName(self): return self.individualName
    def set_individualName(self, individualName): self.individualName = individualName
    individualNameProp = property(get_individualName, set_individualName)
    def get_organisationName(self): return self.organisationName
    def set_organisationName(self, organisationName): self.organisationName = organisationName
    organisationNameProp = property(get_organisationName, set_organisationName)
    def get_positionName(self): return self.positionName
    def set_positionName(self, positionName): self.positionName = positionName
    positionNameProp = property(get_positionName, set_positionName)
    def get_contactInfo(self): return self.contactInfo
    def set_contactInfo(self, contactInfo): self.contactInfo = contactInfo
    contactInfoProp = property(get_contactInfo, set_contactInfo)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    roleProp = property(get_role, set_role)
    def hasContent_(self):
        if (
            self.individualName is not None or
            self.organisationName is not None or
            self.positionName is not None or
            self.contactInfo is not None or
            self.role is not None or
            super(CI_ResponsibleParty_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_ResponsibleParty_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_ResponsibleParty_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_ResponsibleParty_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_ResponsibleParty_Type'):
        super(CI_ResponsibleParty_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_ResponsibleParty_Type')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_ResponsibleParty_Type', fromsubclass_=False, pretty_print=True):
        super(CI_ResponsibleParty_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.individualName is not None:
            self.individualName.export(outfile, level, namespace_, name_='individualName', pretty_print=pretty_print)
        if self.organisationName is not None:
            self.organisationName.export(outfile, level, namespace_, name_='organisationName', pretty_print=pretty_print)
        if self.positionName is not None:
            self.positionName.export(outfile, level, namespace_, name_='positionName', pretty_print=pretty_print)
        if self.contactInfo is not None:
            self.contactInfo.export(outfile, level, namespace_, name_='contactInfo', pretty_print=pretty_print)
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_ResponsibleParty_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'individualName':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.individualName = obj_
            obj_.original_tagname_ = 'individualName'
        elif nodeName_ == 'organisationName':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.organisationName = obj_
            obj_.original_tagname_ = 'organisationName'
        elif nodeName_ == 'positionName':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.positionName = obj_
            obj_.original_tagname_ = 'positionName'
        elif nodeName_ == 'contactInfo':
            obj_ = CI_Contact_PropertyType.factory()
            obj_.build(child_)
            self.contactInfo = obj_
            obj_.original_tagname_ = 'contactInfo'
        elif nodeName_ == 'role':
            obj_ = CI_RoleCode_PropertyType.factory()
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
        super(CI_ResponsibleParty_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_ResponsibleParty_Type


class CI_Date_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, date=None, dateType=None):
        self.original_tagname_ = None
        super(CI_Date_Type, self).__init__(id, uuid, )
        self.date = date
        self.dateType = dateType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_Date_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_Date_Type.subclass:
            return CI_Date_Type.subclass(*args_, **kwargs_)
        else:
            return CI_Date_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    dateProp = property(get_date, set_date)
    def get_dateType(self): return self.dateType
    def set_dateType(self, dateType): self.dateType = dateType
    dateTypeProp = property(get_dateType, set_dateType)
    def hasContent_(self):
        if (
            self.date is not None or
            self.dateType is not None or
            super(CI_Date_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_Date_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Date_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_Date_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_Date_Type'):
        super(CI_Date_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Date_Type')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_Date_Type', fromsubclass_=False, pretty_print=True):
        super(CI_Date_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.date is not None:
            self.date.export(outfile, level, namespace_, name_='date', pretty_print=pretty_print)
        if self.dateType is not None:
            self.dateType.export(outfile, level, namespace_, name_='dateType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_Date_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'date':
            obj_ = Date_PropertyType.factory()
            obj_.build(child_)
            self.date = obj_
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'dateType':
            obj_ = CI_DateTypeCode_PropertyType.factory()
            obj_.build(child_)
            self.dateType = obj_
            obj_.original_tagname_ = 'dateType'
        super(CI_Date_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_Date_Type


class CI_Citation_Type(AbstractObject_Type):
    """Standardized resource reference"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, title=None, alternateTitle=None, date=None, edition=None, editionDate=None, identifier=None, citedResponsibleParty=None, presentationForm=None, series=None, otherCitationDetails=None, collectiveTitle=None, ISBN=None, ISSN=None):
        self.original_tagname_ = None
        super(CI_Citation_Type, self).__init__(id, uuid, )
        self.title = title
        if alternateTitle is None:
            self.alternateTitle = []
        else:
            self.alternateTitle = alternateTitle
        if date is None:
            self.date = []
        else:
            self.date = date
        self.edition = edition
        self.editionDate = editionDate
        if identifier is None:
            self.identifier = []
        else:
            self.identifier = identifier
        if citedResponsibleParty is None:
            self.citedResponsibleParty = []
        else:
            self.citedResponsibleParty = citedResponsibleParty
        if presentationForm is None:
            self.presentationForm = []
        else:
            self.presentationForm = presentationForm
        self.series = series
        self.otherCitationDetails = otherCitationDetails
        self.collectiveTitle = collectiveTitle
        self.ISBN = ISBN
        self.ISSN = ISSN
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CI_Citation_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CI_Citation_Type.subclass:
            return CI_Citation_Type.subclass(*args_, **kwargs_)
        else:
            return CI_Citation_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    titleProp = property(get_title, set_title)
    def get_alternateTitle(self): return self.alternateTitle
    def set_alternateTitle(self, alternateTitle): self.alternateTitle = alternateTitle
    def add_alternateTitle(self, value): self.alternateTitle.append(value)
    def insert_alternateTitle_at(self, index, value): self.alternateTitle.insert(index, value)
    def replace_alternateTitle_at(self, index, value): self.alternateTitle[index] = value
    alternateTitleProp = property(get_alternateTitle, set_alternateTitle)
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def add_date(self, value): self.date.append(value)
    def insert_date_at(self, index, value): self.date.insert(index, value)
    def replace_date_at(self, index, value): self.date[index] = value
    dateProp = property(get_date, set_date)
    def get_edition(self): return self.edition
    def set_edition(self, edition): self.edition = edition
    editionProp = property(get_edition, set_edition)
    def get_editionDate(self): return self.editionDate
    def set_editionDate(self, editionDate): self.editionDate = editionDate
    editionDateProp = property(get_editionDate, set_editionDate)
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def add_identifier(self, value): self.identifier.append(value)
    def insert_identifier_at(self, index, value): self.identifier.insert(index, value)
    def replace_identifier_at(self, index, value): self.identifier[index] = value
    identifierProp = property(get_identifier, set_identifier)
    def get_citedResponsibleParty(self): return self.citedResponsibleParty
    def set_citedResponsibleParty(self, citedResponsibleParty): self.citedResponsibleParty = citedResponsibleParty
    def add_citedResponsibleParty(self, value): self.citedResponsibleParty.append(value)
    def insert_citedResponsibleParty_at(self, index, value): self.citedResponsibleParty.insert(index, value)
    def replace_citedResponsibleParty_at(self, index, value): self.citedResponsibleParty[index] = value
    citedResponsiblePartyProp = property(get_citedResponsibleParty, set_citedResponsibleParty)
    def get_presentationForm(self): return self.presentationForm
    def set_presentationForm(self, presentationForm): self.presentationForm = presentationForm
    def add_presentationForm(self, value): self.presentationForm.append(value)
    def insert_presentationForm_at(self, index, value): self.presentationForm.insert(index, value)
    def replace_presentationForm_at(self, index, value): self.presentationForm[index] = value
    presentationFormProp = property(get_presentationForm, set_presentationForm)
    def get_series(self): return self.series
    def set_series(self, series): self.series = series
    seriesProp = property(get_series, set_series)
    def get_otherCitationDetails(self): return self.otherCitationDetails
    def set_otherCitationDetails(self, otherCitationDetails): self.otherCitationDetails = otherCitationDetails
    otherCitationDetailsProp = property(get_otherCitationDetails, set_otherCitationDetails)
    def get_collectiveTitle(self): return self.collectiveTitle
    def set_collectiveTitle(self, collectiveTitle): self.collectiveTitle = collectiveTitle
    collectiveTitleProp = property(get_collectiveTitle, set_collectiveTitle)
    def get_ISBN(self): return self.ISBN
    def set_ISBN(self, ISBN): self.ISBN = ISBN
    ISBNProp = property(get_ISBN, set_ISBN)
    def get_ISSN(self): return self.ISSN
    def set_ISSN(self, ISSN): self.ISSN = ISSN
    ISSNProp = property(get_ISSN, set_ISSN)
    def hasContent_(self):
        if (
            self.title is not None or
            self.alternateTitle or
            self.date or
            self.edition is not None or
            self.editionDate is not None or
            self.identifier or
            self.citedResponsibleParty or
            self.presentationForm or
            self.series is not None or
            self.otherCitationDetails is not None or
            self.collectiveTitle is not None or
            self.ISBN is not None or
            self.ISSN is not None or
            super(CI_Citation_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CI_Citation_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Citation_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CI_Citation_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CI_Citation_Type'):
        super(CI_Citation_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Citation_Type')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CI_Citation_Type', fromsubclass_=False, pretty_print=True):
        super(CI_Citation_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            self.title.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for alternateTitle_ in self.alternateTitle:
            alternateTitle_.export(outfile, level, namespace_, name_='alternateTitle', pretty_print=pretty_print)
        for date_ in self.date:
            date_.export(outfile, level, namespace_, name_='date', pretty_print=pretty_print)
        if self.edition is not None:
            self.edition.export(outfile, level, namespace_, name_='edition', pretty_print=pretty_print)
        if self.editionDate is not None:
            self.editionDate.export(outfile, level, namespace_, name_='editionDate', pretty_print=pretty_print)
        for identifier_ in self.identifier:
            identifier_.export(outfile, level, namespace_, name_='identifier', pretty_print=pretty_print)
        for citedResponsibleParty_ in self.citedResponsibleParty:
            citedResponsibleParty_.export(outfile, level, namespace_, name_='citedResponsibleParty', pretty_print=pretty_print)
        for presentationForm_ in self.presentationForm:
            presentationForm_.export(outfile, level, namespace_, name_='presentationForm', pretty_print=pretty_print)
        if self.series is not None:
            self.series.export(outfile, level, namespace_, name_='series', pretty_print=pretty_print)
        if self.otherCitationDetails is not None:
            self.otherCitationDetails.export(outfile, level, namespace_, name_='otherCitationDetails', pretty_print=pretty_print)
        if self.collectiveTitle is not None:
            self.collectiveTitle.export(outfile, level, namespace_, name_='collectiveTitle', pretty_print=pretty_print)
        if self.ISBN is not None:
            self.ISBN.export(outfile, level, namespace_, name_='ISBN', pretty_print=pretty_print)
        if self.ISSN is not None:
            self.ISSN.export(outfile, level, namespace_, name_='ISSN', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_Citation_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'alternateTitle':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.alternateTitle.append(obj_)
            obj_.original_tagname_ = 'alternateTitle'
        elif nodeName_ == 'date':
            obj_ = CI_Date_PropertyType.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'edition':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.edition = obj_
            obj_.original_tagname_ = 'edition'
        elif nodeName_ == 'editionDate':
            obj_ = Date_PropertyType.factory()
            obj_.build(child_)
            self.editionDate = obj_
            obj_.original_tagname_ = 'editionDate'
        elif nodeName_ == 'identifier':
            obj_ = MD_Identifier_PropertyType.factory()
            obj_.build(child_)
            self.identifier.append(obj_)
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'citedResponsibleParty':
            obj_ = CI_ResponsibleParty_PropertyType.factory()
            obj_.build(child_)
            self.citedResponsibleParty.append(obj_)
            obj_.original_tagname_ = 'citedResponsibleParty'
        elif nodeName_ == 'presentationForm':
            obj_ = CI_PresentationFormCode_PropertyType.factory()
            obj_.build(child_)
            self.presentationForm.append(obj_)
            obj_.original_tagname_ = 'presentationForm'
        elif nodeName_ == 'series':
            obj_ = CI_Series_PropertyType.factory()
            obj_.build(child_)
            self.series = obj_
            obj_.original_tagname_ = 'series'
        elif nodeName_ == 'otherCitationDetails':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.otherCitationDetails = obj_
            obj_.original_tagname_ = 'otherCitationDetails'
        elif nodeName_ == 'collectiveTitle':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.collectiveTitle = obj_
            obj_.original_tagname_ = 'collectiveTitle'
        elif nodeName_ == 'ISBN':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.ISBN = obj_
            obj_.original_tagname_ = 'ISBN'
        elif nodeName_ == 'ISSN':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.ISSN = obj_
            obj_.original_tagname_ = 'ISSN'
        super(CI_Citation_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_Citation_Type


class MD_Identifier_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, authority=None, code=None):
        self.original_tagname_ = None
        super(MD_Identifier_Type, self).__init__(id, uuid, )
        self.authority = authority
        self.code = code
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MD_Identifier_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MD_Identifier_Type.subclass:
            return MD_Identifier_Type.subclass(*args_, **kwargs_)
        else:
            return MD_Identifier_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_authority(self): return self.authority
    def set_authority(self, authority): self.authority = authority
    authorityProp = property(get_authority, set_authority)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    codeProp = property(get_code, set_code)
    def hasContent_(self):
        if (
            self.authority is not None or
            self.code is not None or
            super(MD_Identifier_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='MD_Identifier_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Identifier_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='MD_Identifier_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='MD_Identifier_Type'):
        super(MD_Identifier_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Identifier_Type')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='MD_Identifier_Type', fromsubclass_=False, pretty_print=True):
        super(MD_Identifier_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.authority is not None:
            self.authority.export(outfile, level, namespace_, name_='authority', pretty_print=pretty_print)
        if self.code is not None:
            self.code.export(outfile, level, namespace_, name_='code', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_Identifier_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'authority':
            obj_ = CI_Citation_PropertyType.factory()
            obj_.build(child_)
            self.authority = obj_
            obj_.original_tagname_ = 'authority'
        elif nodeName_ == 'code':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        super(MD_Identifier_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_Identifier_Type


class AbstractDQ_Element_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None, extensiontype_=None):
        self.original_tagname_ = None
        super(AbstractDQ_Element_Type, self).__init__(id, uuid, extensiontype_, )
        if nameOfMeasure is None:
            self.nameOfMeasure = []
        else:
            self.nameOfMeasure = nameOfMeasure
        self.measureIdentification = measureIdentification
        self.measureDescription = measureDescription
        self.evaluationMethodType = evaluationMethodType
        self.evaluationMethodDescription = evaluationMethodDescription
        self.evaluationProcedure = evaluationProcedure
        if dateTime is None:
            self.dateTime = []
        else:
            self.dateTime = dateTime
        if result is None:
            self.result = []
        else:
            self.result = result
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractDQ_Element_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractDQ_Element_Type.subclass:
            return AbstractDQ_Element_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractDQ_Element_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nameOfMeasure(self): return self.nameOfMeasure
    def set_nameOfMeasure(self, nameOfMeasure): self.nameOfMeasure = nameOfMeasure
    def add_nameOfMeasure(self, value): self.nameOfMeasure.append(value)
    def insert_nameOfMeasure_at(self, index, value): self.nameOfMeasure.insert(index, value)
    def replace_nameOfMeasure_at(self, index, value): self.nameOfMeasure[index] = value
    nameOfMeasureProp = property(get_nameOfMeasure, set_nameOfMeasure)
    def get_measureIdentification(self): return self.measureIdentification
    def set_measureIdentification(self, measureIdentification): self.measureIdentification = measureIdentification
    measureIdentificationProp = property(get_measureIdentification, set_measureIdentification)
    def get_measureDescription(self): return self.measureDescription
    def set_measureDescription(self, measureDescription): self.measureDescription = measureDescription
    measureDescriptionProp = property(get_measureDescription, set_measureDescription)
    def get_evaluationMethodType(self): return self.evaluationMethodType
    def set_evaluationMethodType(self, evaluationMethodType): self.evaluationMethodType = evaluationMethodType
    evaluationMethodTypeProp = property(get_evaluationMethodType, set_evaluationMethodType)
    def get_evaluationMethodDescription(self): return self.evaluationMethodDescription
    def set_evaluationMethodDescription(self, evaluationMethodDescription): self.evaluationMethodDescription = evaluationMethodDescription
    evaluationMethodDescriptionProp = property(get_evaluationMethodDescription, set_evaluationMethodDescription)
    def get_evaluationProcedure(self): return self.evaluationProcedure
    def set_evaluationProcedure(self, evaluationProcedure): self.evaluationProcedure = evaluationProcedure
    evaluationProcedureProp = property(get_evaluationProcedure, set_evaluationProcedure)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def add_dateTime(self, value): self.dateTime.append(value)
    def insert_dateTime_at(self, index, value): self.dateTime.insert(index, value)
    def replace_dateTime_at(self, index, value): self.dateTime[index] = value
    dateTimeProp = property(get_dateTime, set_dateTime)
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def add_result(self, value): self.result.append(value)
    def insert_result_at(self, index, value): self.result.insert(index, value)
    def replace_result_at(self, index, value): self.result[index] = value
    resultProp = property(get_result, set_result)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.nameOfMeasure or
            self.measureIdentification is not None or
            self.measureDescription is not None or
            self.evaluationMethodType is not None or
            self.evaluationMethodDescription is not None or
            self.evaluationProcedure is not None or
            self.dateTime or
            self.result or
            super(AbstractDQ_Element_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractDQ_Element_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_Element_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractDQ_Element_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractDQ_Element_Type'):
        super(AbstractDQ_Element_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_Element_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractDQ_Element_Type', fromsubclass_=False, pretty_print=True):
        super(AbstractDQ_Element_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for nameOfMeasure_ in self.nameOfMeasure:
            nameOfMeasure_.export(outfile, level, namespace_, name_='nameOfMeasure', pretty_print=pretty_print)
        if self.measureIdentification is not None:
            self.measureIdentification.export(outfile, level, namespace_, name_='measureIdentification', pretty_print=pretty_print)
        if self.measureDescription is not None:
            self.measureDescription.export(outfile, level, namespace_, name_='measureDescription', pretty_print=pretty_print)
        if self.evaluationMethodType is not None:
            self.evaluationMethodType.export(outfile, level, namespace_, name_='evaluationMethodType', pretty_print=pretty_print)
        if self.evaluationMethodDescription is not None:
            self.evaluationMethodDescription.export(outfile, level, namespace_, name_='evaluationMethodDescription', pretty_print=pretty_print)
        if self.evaluationProcedure is not None:
            self.evaluationProcedure.export(outfile, level, namespace_, name_='evaluationProcedure', pretty_print=pretty_print)
        for dateTime_ in self.dateTime:
            dateTime_.export(outfile, level, namespace_, name_='dateTime', pretty_print=pretty_print)
        for result_ in self.result:
            result_.export(outfile, level, namespace_, name_='result', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractDQ_Element_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nameOfMeasure':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.nameOfMeasure.append(obj_)
            obj_.original_tagname_ = 'nameOfMeasure'
        elif nodeName_ == 'measureIdentification':
            obj_ = MD_Identifier_PropertyType.factory()
            obj_.build(child_)
            self.measureIdentification = obj_
            obj_.original_tagname_ = 'measureIdentification'
        elif nodeName_ == 'measureDescription':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.measureDescription = obj_
            obj_.original_tagname_ = 'measureDescription'
        elif nodeName_ == 'evaluationMethodType':
            obj_ = DQ_EvaluationMethodTypeCode_PropertyType.factory()
            obj_.build(child_)
            self.evaluationMethodType = obj_
            obj_.original_tagname_ = 'evaluationMethodType'
        elif nodeName_ == 'evaluationMethodDescription':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.evaluationMethodDescription = obj_
            obj_.original_tagname_ = 'evaluationMethodDescription'
        elif nodeName_ == 'evaluationProcedure':
            obj_ = CI_Citation_PropertyType.factory()
            obj_.build(child_)
            self.evaluationProcedure = obj_
            obj_.original_tagname_ = 'evaluationProcedure'
        elif nodeName_ == 'dateTime':
            obj_ = DateTime_PropertyType.factory()
            obj_.build(child_)
            self.dateTime.append(obj_)
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'result':
            obj_ = DQ_Result_PropertyType.factory()
            obj_.build(child_)
            self.result.append(obj_)
            obj_.original_tagname_ = 'result'
        super(AbstractDQ_Element_Type, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractDQ_Element_Type


class AbstractDQ_PositionalAccuracy_Type(AbstractDQ_Element_Type):
    subclass = None
    superclass = AbstractDQ_Element_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        self.original_tagname_ = None
        super(AbstractDQ_PositionalAccuracy_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractDQ_PositionalAccuracy_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractDQ_PositionalAccuracy_Type.subclass:
            return AbstractDQ_PositionalAccuracy_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractDQ_PositionalAccuracy_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(AbstractDQ_PositionalAccuracy_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractDQ_PositionalAccuracy_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_PositionalAccuracy_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractDQ_PositionalAccuracy_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractDQ_PositionalAccuracy_Type'):
        super(AbstractDQ_PositionalAccuracy_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_PositionalAccuracy_Type')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractDQ_PositionalAccuracy_Type', fromsubclass_=False, pretty_print=True):
        super(AbstractDQ_PositionalAccuracy_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractDQ_PositionalAccuracy_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractDQ_PositionalAccuracy_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractDQ_PositionalAccuracy_Type


class EX_VerticalExtent_Type(AbstractObject_Type):
    """Vertical domain of dataset"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, minimumValue=None, maximumValue=None, verticalCRS=None):
        self.original_tagname_ = None
        super(EX_VerticalExtent_Type, self).__init__(id, uuid, )
        self.minimumValue = minimumValue
        self.maximumValue = maximumValue
        self.verticalCRS = verticalCRS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EX_VerticalExtent_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EX_VerticalExtent_Type.subclass:
            return EX_VerticalExtent_Type.subclass(*args_, **kwargs_)
        else:
            return EX_VerticalExtent_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minimumValue(self): return self.minimumValue
    def set_minimumValue(self, minimumValue): self.minimumValue = minimumValue
    minimumValueProp = property(get_minimumValue, set_minimumValue)
    def get_maximumValue(self): return self.maximumValue
    def set_maximumValue(self, maximumValue): self.maximumValue = maximumValue
    maximumValueProp = property(get_maximumValue, set_maximumValue)
    def get_verticalCRS(self): return self.verticalCRS
    def set_verticalCRS(self, verticalCRS): self.verticalCRS = verticalCRS
    verticalCRSProp = property(get_verticalCRS, set_verticalCRS)
    def hasContent_(self):
        if (
            self.minimumValue is not None or
            self.maximumValue is not None or
            self.verticalCRS is not None or
            super(EX_VerticalExtent_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EX_VerticalExtent_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_VerticalExtent_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EX_VerticalExtent_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EX_VerticalExtent_Type'):
        super(EX_VerticalExtent_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EX_VerticalExtent_Type')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EX_VerticalExtent_Type', fromsubclass_=False, pretty_print=True):
        super(EX_VerticalExtent_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.minimumValue is not None:
            self.minimumValue.export(outfile, level, namespace_, name_='minimumValue', pretty_print=pretty_print)
        if self.maximumValue is not None:
            self.maximumValue.export(outfile, level, namespace_, name_='maximumValue', pretty_print=pretty_print)
        if self.verticalCRS is not None:
            self.verticalCRS.export(outfile, level, namespace_, name_='verticalCRS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EX_VerticalExtent_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'minimumValue':
            obj_ = Real_PropertyType.factory()
            obj_.build(child_)
            self.minimumValue = obj_
            obj_.original_tagname_ = 'minimumValue'
        elif nodeName_ == 'maximumValue':
            obj_ = Real_PropertyType.factory()
            obj_.build(child_)
            self.maximumValue = obj_
            obj_.original_tagname_ = 'maximumValue'
        elif nodeName_ == 'verticalCRS':
            obj_ = SC_CRS_PropertyType.factory()
            obj_.build(child_)
            self.verticalCRS = obj_
            obj_.original_tagname_ = 'verticalCRS'
        super(EX_VerticalExtent_Type, self).buildChildren(child_, node, nodeName_, True)
# end class EX_VerticalExtent_Type


class EX_TemporalExtent_Type(AbstractObject_Type):
    """Time period covered by the content of the dataset"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, extent=None):
        self.original_tagname_ = None
        super(EX_TemporalExtent_Type, self).__init__(id, uuid, )
        self.extent = extent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EX_TemporalExtent_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EX_TemporalExtent_Type.subclass:
            return EX_TemporalExtent_Type.subclass(*args_, **kwargs_)
        else:
            return EX_TemporalExtent_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extent(self): return self.extent
    def set_extent(self, extent): self.extent = extent
    extentProp = property(get_extent, set_extent)
    def hasContent_(self):
        if (
            self.extent is not None or
            super(EX_TemporalExtent_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EX_TemporalExtent_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_TemporalExtent_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EX_TemporalExtent_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EX_TemporalExtent_Type'):
        super(EX_TemporalExtent_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EX_TemporalExtent_Type')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EX_TemporalExtent_Type', fromsubclass_=False, pretty_print=True):
        super(EX_TemporalExtent_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.extent is not None:
            self.extent.export(outfile, level, namespace_, name_='extent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EX_TemporalExtent_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'extent':
            obj_ = TM_Primitive_PropertyType.factory()
            obj_.build(child_)
            self.extent = obj_
            obj_.original_tagname_ = 'extent'
        super(EX_TemporalExtent_Type, self).buildChildren(child_, node, nodeName_, True)
# end class EX_TemporalExtent_Type


class AbstractEX_GeographicExtent_Type(AbstractObject_Type):
    """Geographic area of the dataset"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, extentTypeCode=None):
        self.original_tagname_ = None
        super(AbstractEX_GeographicExtent_Type, self).__init__(id, uuid, )
        self.extentTypeCode = extentTypeCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractEX_GeographicExtent_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractEX_GeographicExtent_Type.subclass:
            return AbstractEX_GeographicExtent_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractEX_GeographicExtent_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extentTypeCode(self): return self.extentTypeCode
    def set_extentTypeCode(self, extentTypeCode): self.extentTypeCode = extentTypeCode
    extentTypeCodeProp = property(get_extentTypeCode, set_extentTypeCode)
    def hasContent_(self):
        if (
            self.extentTypeCode is not None or
            super(AbstractEX_GeographicExtent_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractEX_GeographicExtent_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractEX_GeographicExtent_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractEX_GeographicExtent_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractEX_GeographicExtent_Type'):
        super(AbstractEX_GeographicExtent_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractEX_GeographicExtent_Type')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractEX_GeographicExtent_Type', fromsubclass_=False, pretty_print=True):
        super(AbstractEX_GeographicExtent_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.extentTypeCode is not None:
            self.extentTypeCode.export(outfile, level, namespace_, name_='extentTypeCode', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractEX_GeographicExtent_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'extentTypeCode':
            obj_ = Boolean_PropertyType.factory()
            obj_.build(child_)
            self.extentTypeCode = obj_
            obj_.original_tagname_ = 'extentTypeCode'
        super(AbstractEX_GeographicExtent_Type, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractEX_GeographicExtent_Type


class EX_Extent_Type(AbstractObject_Type):
    """Information about spatial, vertical, and temporal extent"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, description=None, geographicElement=None, temporalElement=None, verticalElement=None):
        self.original_tagname_ = None
        super(EX_Extent_Type, self).__init__(id, uuid, )
        self.description = description
        if geographicElement is None:
            self.geographicElement = []
        else:
            self.geographicElement = geographicElement
        if temporalElement is None:
            self.temporalElement = []
        else:
            self.temporalElement = temporalElement
        if verticalElement is None:
            self.verticalElement = []
        else:
            self.verticalElement = verticalElement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EX_Extent_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EX_Extent_Type.subclass:
            return EX_Extent_Type.subclass(*args_, **kwargs_)
        else:
            return EX_Extent_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_geographicElement(self): return self.geographicElement
    def set_geographicElement(self, geographicElement): self.geographicElement = geographicElement
    def add_geographicElement(self, value): self.geographicElement.append(value)
    def insert_geographicElement_at(self, index, value): self.geographicElement.insert(index, value)
    def replace_geographicElement_at(self, index, value): self.geographicElement[index] = value
    geographicElementProp = property(get_geographicElement, set_geographicElement)
    def get_temporalElement(self): return self.temporalElement
    def set_temporalElement(self, temporalElement): self.temporalElement = temporalElement
    def add_temporalElement(self, value): self.temporalElement.append(value)
    def insert_temporalElement_at(self, index, value): self.temporalElement.insert(index, value)
    def replace_temporalElement_at(self, index, value): self.temporalElement[index] = value
    temporalElementProp = property(get_temporalElement, set_temporalElement)
    def get_verticalElement(self): return self.verticalElement
    def set_verticalElement(self, verticalElement): self.verticalElement = verticalElement
    def add_verticalElement(self, value): self.verticalElement.append(value)
    def insert_verticalElement_at(self, index, value): self.verticalElement.insert(index, value)
    def replace_verticalElement_at(self, index, value): self.verticalElement[index] = value
    verticalElementProp = property(get_verticalElement, set_verticalElement)
    def hasContent_(self):
        if (
            self.description is not None or
            self.geographicElement or
            self.temporalElement or
            self.verticalElement or
            super(EX_Extent_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EX_Extent_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_Extent_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EX_Extent_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EX_Extent_Type'):
        super(EX_Extent_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EX_Extent_Type')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EX_Extent_Type', fromsubclass_=False, pretty_print=True):
        super(EX_Extent_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        for geographicElement_ in self.geographicElement:
            geographicElement_.export(outfile, level, namespace_, name_='geographicElement', pretty_print=pretty_print)
        for temporalElement_ in self.temporalElement:
            temporalElement_.export(outfile, level, namespace_, name_='temporalElement', pretty_print=pretty_print)
        for verticalElement_ in self.verticalElement:
            verticalElement_.export(outfile, level, namespace_, name_='verticalElement', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EX_Extent_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = CharacterString_PropertyType.factory()
            obj_.build(child_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'geographicElement':
            obj_ = EX_GeographicExtent_PropertyType.factory()
            obj_.build(child_)
            self.geographicElement.append(obj_)
            obj_.original_tagname_ = 'geographicElement'
        elif nodeName_ == 'temporalElement':
            obj_ = EX_TemporalExtent_PropertyType.factory()
            obj_.build(child_)
            self.temporalElement.append(obj_)
            obj_.original_tagname_ = 'temporalElement'
        elif nodeName_ == 'verticalElement':
            obj_ = EX_VerticalExtent_PropertyType.factory()
            obj_.build(child_)
            self.verticalElement.append(obj_)
            obj_.original_tagname_ = 'verticalElement'
        super(EX_Extent_Type, self).buildChildren(child_, node, nodeName_, True)
# end class EX_Extent_Type


class AngleType(MeasureType):
    subclass = None
    superclass = MeasureType
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(AngleType, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AngleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AngleType.subclass:
            return AngleType.subclass(*args_, **kwargs_)
        else:
            return AngleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_ or
            super(AngleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AngleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AngleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AngleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AngleType'):
        super(AngleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AngleType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AngleType', fromsubclass_=False, pretty_print=True):
        super(AngleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AngleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AngleType


class RelatedTimeType(TimePrimitivePropertyType):
    """gml:RelatedTimeType provides a content model for indicating the
    relative position of an arbitrary member of the substitution
    group whose head is gml:AbstractTimePrimitive. It extends the
    generic gml:TimePrimitivePropertyType with an XML attribute
    relativePosition, whose value is selected from the set of 13
    temporal relationships identified by Allen (1983)"""
    subclass = None
    superclass = TimePrimitivePropertyType
    def __init__(self, type_=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, nilReason=None, owns='false', AbstractTimePrimitive=None, relativePosition=None):
        self.original_tagname_ = None
        super(RelatedTimeType, self).__init__(type_, href, role, arcrole, title, show, actuate, nilReason, owns, AbstractTimePrimitive, )
        self.relativePosition = _cast(None, relativePosition)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelatedTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelatedTimeType.subclass:
            return RelatedTimeType.subclass(*args_, **kwargs_)
        else:
            return RelatedTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relativePosition(self): return self.relativePosition
    def set_relativePosition(self, relativePosition): self.relativePosition = relativePosition
    relativePositionProp = property(get_relativePosition, set_relativePosition)
    def hasContent_(self):
        if (
            super(RelatedTimeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='RelatedTimeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='RelatedTimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='RelatedTimeType'):
        super(RelatedTimeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedTimeType')
        if self.relativePosition is not None and 'relativePosition' not in already_processed:
            already_processed.add('relativePosition')
            outfile.write(' relativePosition=%s' % (quote_attrib(self.relativePosition), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='RelatedTimeType', fromsubclass_=False, pretty_print=True):
        super(RelatedTimeType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('relativePosition', node)
        if value is not None and 'relativePosition' not in already_processed:
            already_processed.add('relativePosition')
            self.relativePosition = value
        super(RelatedTimeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RelatedTimeType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RelatedTimeType


class AbstractTimePrimitiveType(AbstractTimeObjectType):
    subclass = None
    superclass = AbstractTimeObjectType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, relatedTime=None):
        self.original_tagname_ = None
        super(AbstractTimePrimitiveType, self).__init__(id, description, descriptionReference, identifier, name, )
        if relatedTime is None:
            self.relatedTime = []
        else:
            self.relatedTime = relatedTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractTimePrimitiveType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractTimePrimitiveType.subclass:
            return AbstractTimePrimitiveType.subclass(*args_, **kwargs_)
        else:
            return AbstractTimePrimitiveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relatedTime(self): return self.relatedTime
    def set_relatedTime(self, relatedTime): self.relatedTime = relatedTime
    def add_relatedTime(self, value): self.relatedTime.append(value)
    def insert_relatedTime_at(self, index, value): self.relatedTime.insert(index, value)
    def replace_relatedTime_at(self, index, value): self.relatedTime[index] = value
    relatedTimeProp = property(get_relatedTime, set_relatedTime)
    def hasContent_(self):
        if (
            self.relatedTime or
            super(AbstractTimePrimitiveType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractTimePrimitiveType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimePrimitiveType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractTimePrimitiveType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractTimePrimitiveType'):
        super(AbstractTimePrimitiveType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimePrimitiveType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractTimePrimitiveType', fromsubclass_=False, pretty_print=True):
        super(AbstractTimePrimitiveType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for relatedTime_ in self.relatedTime:
            relatedTime_.export(outfile, level, namespace_, name_='relatedTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractTimePrimitiveType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'relatedTime':
            obj_ = RelatedTimeType.factory()
            obj_.build(child_)
            self.relatedTime.append(obj_)
            obj_.original_tagname_ = 'relatedTime'
        super(AbstractTimePrimitiveType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractTimePrimitiveType


class CodeWithAuthorityType(CodeType):
    """gml:CodeWithAuthorityType requires that the codeSpace attribute is
    provided in an instance."""
    subclass = None
    superclass = CodeType
    def __init__(self, codeSpace=None, valueOf_=None):
        self.original_tagname_ = None
        super(CodeWithAuthorityType, self).__init__(codeSpace, valueOf_, )
        self.codeSpace = _cast(None, codeSpace)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeWithAuthorityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeWithAuthorityType.subclass:
            return CodeWithAuthorityType.subclass(*args_, **kwargs_)
        else:
            return CodeWithAuthorityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeSpace(self): return self.codeSpace
    def set_codeSpace(self, codeSpace): self.codeSpace = codeSpace
    codeSpaceProp = property(get_codeSpace, set_codeSpace)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_ or
            super(CodeWithAuthorityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CodeWithAuthorityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeWithAuthorityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CodeWithAuthorityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CodeWithAuthorityType'):
        super(CodeWithAuthorityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CodeWithAuthorityType')
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.add('codeSpace')
            outfile.write(' codeSpace=%s' % (quote_attrib(self.codeSpace), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CodeWithAuthorityType', fromsubclass_=False, pretty_print=True):
        super(CodeWithAuthorityType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeSpace', node)
        if value is not None and 'codeSpace' not in already_processed:
            already_processed.add('codeSpace')
            self.codeSpace = value
        super(CodeWithAuthorityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CodeWithAuthorityType


class DefinitionType(DefinitionBaseType):
    subclass = None
    superclass = DefinitionBaseType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, extensiontype_=None):
        self.original_tagname_ = None
        super(DefinitionType, self).__init__(id, description, descriptionReference, identifier, name, extensiontype_, )
        self.remarks = remarks
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DefinitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DefinitionType.subclass:
            return DefinitionType.subclass(*args_, **kwargs_)
        else:
            return DefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_remarks(self): return self.remarks
    def set_remarks(self, remarks): self.remarks = remarks
    remarksProp = property(get_remarks, set_remarks)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.remarks is not None or
            super(DefinitionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DefinitionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefinitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DefinitionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DefinitionType'):
        super(DefinitionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DefinitionType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DefinitionType', fromsubclass_=False, pretty_print=True):
        super(DefinitionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.remarks is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sremarks>%s</%sremarks>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.remarks), input_name='remarks')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(DefinitionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'remarks':
            remarks_ = child_.text
            remarks_ = self.gds_validate_string(remarks_, node, 'remarks')
            self.remarks = remarks_
        super(DefinitionType, self).buildChildren(child_, node, nodeName_, True)
# end class DefinitionType


class IdentifiedObjectType(DefinitionType):
    """gml:IdentifiedObjectType provides identification properties of a
    CRS-related object. In gml:DefinitionType, the gml:identifier
    element shall be the primary name by which this object is
    identified, encoding the "name" attribute in the UML model. Zero
    or more of the gml:name elements can be an unordered set of
    "identifiers", encoding the "identifier" attribute in the UML
    model. Each of these gml:name elements can reference elsewhere
    the object's defining information or be an identifier by which
    this object can be referenced. Zero or more other gml:name
    elements can be an unordered set of "alias" alternative names by
    which this CRS related object is identified, encoding the
    "alias" attributes in the UML model. An object may have several
    aliases, typically used in different contexts. The context for
    an alias is indicated by the value of its (optional) codeSpace
    attribute. Any needed version information shall be included in
    the codeSpace attribute of a gml:identifier and gml:name
    elements. In this use, the gml:remarks element in the
    gml:DefinitionType shall contain comments on or information
    about this object, including data source information."""
    subclass = None
    superclass = DefinitionType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, extensiontype_=None):
        self.original_tagname_ = None
        super(IdentifiedObjectType, self).__init__(id, description, descriptionReference, identifier, name, remarks, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedObjectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedObjectType.subclass:
            return IdentifiedObjectType.subclass(*args_, **kwargs_)
        else:
            return IdentifiedObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(IdentifiedObjectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='IdentifiedObjectType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='IdentifiedObjectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='IdentifiedObjectType'):
        super(IdentifiedObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedObjectType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='IdentifiedObjectType', fromsubclass_=False, pretty_print=True):
        super(IdentifiedObjectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IdentifiedObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IdentifiedObjectType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IdentifiedObjectType


class AbstractCRSType(IdentifiedObjectType):
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, extensiontype_=None):
        self.original_tagname_ = None
        super(AbstractCRSType, self).__init__(id, description, descriptionReference, identifier, name, remarks, extensiontype_, )
        if domainOfValidity is None:
            self.domainOfValidity = []
        else:
            self.domainOfValidity = domainOfValidity
        if scope is None:
            self.scope = []
        else:
            self.scope = scope
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractCRSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractCRSType.subclass:
            return AbstractCRSType.subclass(*args_, **kwargs_)
        else:
            return AbstractCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domainOfValidity(self): return self.domainOfValidity
    def set_domainOfValidity(self, domainOfValidity): self.domainOfValidity = domainOfValidity
    def add_domainOfValidity(self, value): self.domainOfValidity.append(value)
    def insert_domainOfValidity_at(self, index, value): self.domainOfValidity.insert(index, value)
    def replace_domainOfValidity_at(self, index, value): self.domainOfValidity[index] = value
    domainOfValidityProp = property(get_domainOfValidity, set_domainOfValidity)
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def add_scope(self, value): self.scope.append(value)
    def insert_scope_at(self, index, value): self.scope.insert(index, value)
    def replace_scope_at(self, index, value): self.scope[index] = value
    scopeProp = property(get_scope, set_scope)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.domainOfValidity or
            self.scope or
            super(AbstractCRSType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractCRSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCRSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractCRSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractCRSType'):
        super(AbstractCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCRSType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractCRSType', fromsubclass_=False, pretty_print=True):
        super(AbstractCRSType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for domainOfValidity_ in self.domainOfValidity:
            domainOfValidity_.export(outfile, level, namespace_='gml:', name_='domainOfValidity', pretty_print=pretty_print)
        for scope_ in self.scope:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscope>%s</%sscope>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(scope_), input_name='scope')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domainOfValidity':
            obj_ = domainOfValidity.factory()
            obj_.build(child_)
            self.domainOfValidity.append(obj_)
            obj_.original_tagname_ = 'domainOfValidity'
        elif nodeName_ == 'scope':
            scope_ = child_.text
            scope_ = self.gds_validate_string(scope_, node, 'scope')
            self.scope.append(scope_)
        super(AbstractCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractCRSType


class GeodeticCRSType(AbstractCRSType):
    """gml:GeodeticCRS is a coordinate reference system based on a geodetic
    datum."""
    subclass = None
    superclass = AbstractCRSType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, ellipsoidalCS=None, cartesianCS=None, sphericalCS=None, geodeticDatum=None):
        self.original_tagname_ = None
        super(GeodeticCRSType, self).__init__(id, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, )
        self.ellipsoidalCS = ellipsoidalCS
        self.cartesianCS = cartesianCS
        self.sphericalCS = sphericalCS
        self.geodeticDatum = geodeticDatum
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeodeticCRSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeodeticCRSType.subclass:
            return GeodeticCRSType.subclass(*args_, **kwargs_)
        else:
            return GeodeticCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ellipsoidalCS(self): return self.ellipsoidalCS
    def set_ellipsoidalCS(self, ellipsoidalCS): self.ellipsoidalCS = ellipsoidalCS
    ellipsoidalCSProp = property(get_ellipsoidalCS, set_ellipsoidalCS)
    def get_cartesianCS(self): return self.cartesianCS
    def set_cartesianCS(self, cartesianCS): self.cartesianCS = cartesianCS
    cartesianCSProp = property(get_cartesianCS, set_cartesianCS)
    def get_sphericalCS(self): return self.sphericalCS
    def set_sphericalCS(self, sphericalCS): self.sphericalCS = sphericalCS
    sphericalCSProp = property(get_sphericalCS, set_sphericalCS)
    def get_geodeticDatum(self): return self.geodeticDatum
    def set_geodeticDatum(self, geodeticDatum): self.geodeticDatum = geodeticDatum
    geodeticDatumProp = property(get_geodeticDatum, set_geodeticDatum)
    def hasContent_(self):
        if (
            self.ellipsoidalCS is not None or
            self.cartesianCS is not None or
            self.sphericalCS is not None or
            self.geodeticDatum is not None or
            super(GeodeticCRSType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeodeticCRSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticCRSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeodeticCRSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeodeticCRSType'):
        super(GeodeticCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticCRSType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeodeticCRSType', fromsubclass_=False, pretty_print=True):
        super(GeodeticCRSType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ellipsoidalCS is not None:
            self.ellipsoidalCS.export(outfile, level, namespace_='gml:', name_='ellipsoidalCS', pretty_print=pretty_print)
        if self.cartesianCS is not None:
            self.cartesianCS.export(outfile, level, namespace_='gml:', name_='cartesianCS', pretty_print=pretty_print)
        if self.sphericalCS is not None:
            self.sphericalCS.export(outfile, level, namespace_='gml:', name_='sphericalCS', pretty_print=pretty_print)
        if self.geodeticDatum is not None:
            self.geodeticDatum.export(outfile, level, namespace_='gml:', name_='geodeticDatum', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GeodeticCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ellipsoidalCS':
            obj_ = EllipsoidalCSPropertyType.factory()
            obj_.build(child_)
            self.ellipsoidalCS = obj_
            obj_.original_tagname_ = 'ellipsoidalCS'
        elif nodeName_ == 'cartesianCS':
            obj_ = CartesianCSPropertyType.factory()
            obj_.build(child_)
            self.cartesianCS = obj_
            obj_.original_tagname_ = 'cartesianCS'
        elif nodeName_ == 'sphericalCS':
            obj_ = SphericalCSPropertyType.factory()
            obj_.build(child_)
            self.sphericalCS = obj_
            obj_.original_tagname_ = 'sphericalCS'
        elif nodeName_ == 'geodeticDatum':
            obj_ = GeodeticDatumPropertyType.factory()
            obj_.build(child_)
            self.geodeticDatum = obj_
            obj_.original_tagname_ = 'geodeticDatum'
        super(GeodeticCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class GeodeticCRSType


class AbstractStringArray(AbstractValueArray):
    subclass = None
    superclass = AbstractValueArray
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        super(AbstractStringArray, self).__init__(extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractStringArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractStringArray.subclass:
            return AbstractStringArray.subclass(*args_, **kwargs_)
        else:
            return AbstractStringArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(AbstractStringArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractStringArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractStringArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractStringArray', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractStringArray'):
        super(AbstractStringArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractStringArray')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractStringArray', fromsubclass_=False, pretty_print=True):
        super(AbstractStringArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractStringArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractStringArray, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractStringArray


class AbstractNumericArray(AbstractValueArray):
    subclass = None
    superclass = AbstractValueArray
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        super(AbstractNumericArray, self).__init__(extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractNumericArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractNumericArray.subclass:
            return AbstractNumericArray.subclass(*args_, **kwargs_)
        else:
            return AbstractNumericArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(AbstractNumericArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractNumericArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractNumericArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractNumericArray', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractNumericArray'):
        super(AbstractNumericArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractNumericArray')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractNumericArray', fromsubclass_=False, pretty_print=True):
        super(AbstractNumericArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractNumericArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractNumericArray, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractNumericArray


class AbstractIntegerArray(AbstractNumericArray):
    """Generic representation of an array of integer values. Each derived
    element provides specialized implementation to allow specific
    optimization of the representation."""
    subclass = None
    superclass = AbstractNumericArray
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        super(AbstractIntegerArray, self).__init__(extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractIntegerArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractIntegerArray.subclass:
            return AbstractIntegerArray.subclass(*args_, **kwargs_)
        else:
            return AbstractIntegerArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(AbstractIntegerArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractIntegerArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractIntegerArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractIntegerArray', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractIntegerArray'):
        super(AbstractIntegerArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractIntegerArray')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractIntegerArray', fromsubclass_=False, pretty_print=True):
        super(AbstractIntegerArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractIntegerArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractIntegerArray, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractIntegerArray


class AbstractFloatingPointArray(AbstractNumericArray):
    """Generic representation of an array of double values. Each derived
    element provides specialized implementation to allow specific
    optimization of the representation."""
    subclass = None
    superclass = AbstractNumericArray
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        super(AbstractFloatingPointArray, self).__init__(extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractFloatingPointArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractFloatingPointArray.subclass:
            return AbstractFloatingPointArray.subclass(*args_, **kwargs_)
        else:
            return AbstractFloatingPointArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(AbstractFloatingPointArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractFloatingPointArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractFloatingPointArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractFloatingPointArray', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractFloatingPointArray'):
        super(AbstractFloatingPointArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractFloatingPointArray')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractFloatingPointArray', fromsubclass_=False, pretty_print=True):
        super(AbstractFloatingPointArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractFloatingPointArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractFloatingPointArray, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractFloatingPointArray


class AbstractBooleanArray(AbstractValueArray):
    """Generic representation of an array of Boolean values. Each derived
    element provides a specialized implementation to allow specific
    optimization of the representation."""
    subclass = None
    superclass = AbstractValueArray
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        super(AbstractBooleanArray, self).__init__(extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractBooleanArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractBooleanArray.subclass:
            return AbstractBooleanArray.subclass(*args_, **kwargs_)
        else:
            return AbstractBooleanArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(AbstractBooleanArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractBooleanArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractBooleanArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractBooleanArray', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractBooleanArray'):
        super(AbstractBooleanArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractBooleanArray')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractBooleanArray', fromsubclass_=False, pretty_print=True):
        super(AbstractBooleanArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractBooleanArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractBooleanArray, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractBooleanArray


class ProductFlowModel(AbstractObject):
    """The non-contextual content of a product flow model data object."""
    subclass = None
    superclass = AbstractObject
    def __init__(self, Installation=None, ContextFacility=None, DTimStart=None, DTimEnd=None, ExistenceTime=None, DTimMin=None, DTimMax=None, Comment=None, ExternalConnect=None, Network=None):
        self.original_tagname_ = None
        super(ProductFlowModel, self).__init__()
        self.Installation = Installation
        if ContextFacility is None:
            self.ContextFacility = []
        else:
            self.ContextFacility = ContextFacility
        if isinstance(DTimStart, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DTimStart, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DTimStart
        self.DTimStart = initvalue_
        if isinstance(DTimEnd, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DTimEnd, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DTimEnd
        self.DTimEnd = initvalue_
        self.ExistenceTime = ExistenceTime
        self.DTimMin = DTimMin
        self.DTimMax = DTimMax
        self.Comment = Comment
        self.validate_String2000(self.Comment)
        if ExternalConnect is None:
            self.ExternalConnect = []
        else:
            self.ExternalConnect = ExternalConnect
        if Network is None:
            self.Network = []
        else:
            self.Network = Network
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductFlowModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductFlowModel.subclass:
            return ProductFlowModel.subclass(*args_, **kwargs_)
        else:
            return ProductFlowModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Installation(self): return self.Installation
    def set_Installation(self, Installation): self.Installation = Installation
    InstallationProp = property(get_Installation, set_Installation)
    def get_ContextFacility(self): return self.ContextFacility
    def set_ContextFacility(self, ContextFacility): self.ContextFacility = ContextFacility
    def add_ContextFacility(self, value): self.ContextFacility.append(value)
    def insert_ContextFacility_at(self, index, value): self.ContextFacility.insert(index, value)
    def replace_ContextFacility_at(self, index, value): self.ContextFacility[index] = value
    ContextFacilityProp = property(get_ContextFacility, set_ContextFacility)
    def get_DTimStart(self): return self.DTimStart
    def set_DTimStart(self, DTimStart): self.DTimStart = DTimStart
    DTimStartProp = property(get_DTimStart, set_DTimStart)
    def get_DTimEnd(self): return self.DTimEnd
    def set_DTimEnd(self, DTimEnd): self.DTimEnd = DTimEnd
    DTimEndProp = property(get_DTimEnd, set_DTimEnd)
    def get_ExistenceTime(self): return self.ExistenceTime
    def set_ExistenceTime(self, ExistenceTime): self.ExistenceTime = ExistenceTime
    ExistenceTimeProp = property(get_ExistenceTime, set_ExistenceTime)
    def get_DTimMin(self): return self.DTimMin
    def set_DTimMin(self, DTimMin): self.DTimMin = DTimMin
    DTimMinProp = property(get_DTimMin, set_DTimMin)
    def get_DTimMax(self): return self.DTimMax
    def set_DTimMax(self, DTimMax): self.DTimMax = DTimMax
    DTimMaxProp = property(get_DTimMax, set_DTimMax)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_ExternalConnect(self): return self.ExternalConnect
    def set_ExternalConnect(self, ExternalConnect): self.ExternalConnect = ExternalConnect
    def add_ExternalConnect(self, value): self.ExternalConnect.append(value)
    def insert_ExternalConnect_at(self, index, value): self.ExternalConnect.insert(index, value)
    def replace_ExternalConnect_at(self, index, value): self.ExternalConnect[index] = value
    ExternalConnectProp = property(get_ExternalConnect, set_ExternalConnect)
    def get_Network(self): return self.Network
    def set_Network(self, Network): self.Network = Network
    def add_Network(self, value): self.Network.append(value)
    def insert_Network_at(self, index, value): self.Network.insert(index, value)
    def replace_Network_at(self, index, value): self.Network[index] = value
    NetworkProp = property(get_Network, set_Network)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Installation is not None or
            self.ContextFacility or
            self.DTimStart is not None or
            self.DTimEnd is not None or
            self.ExistenceTime is not None or
            self.DTimMin is not None or
            self.DTimMax is not None or
            self.Comment is not None or
            self.ExternalConnect or
            self.Network or
            super(ProductFlowModel, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductFlowModel', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductFlowModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductFlowModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductFlowModel'):
        super(ProductFlowModel, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProductFlowModel')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductFlowModel', fromsubclass_=False, pretty_print=True):
        super(ProductFlowModel, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Installation is not None:
            self.Installation.export(outfile, level, namespace_, name_='Installation', pretty_print=pretty_print)
        for ContextFacility_ in self.ContextFacility:
            ContextFacility_.export(outfile, level, namespace_, name_='ContextFacility', pretty_print=pretty_print)
        if self.DTimStart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTimStart>%s</%sDTimStart>%s' % (namespace_, self.gds_format_datetime(self.DTimStart, input_name='DTimStart'), namespace_, eol_))
        if self.DTimEnd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTimEnd>%s</%sDTimEnd>%s' % (namespace_, self.gds_format_datetime(self.DTimEnd, input_name='DTimEnd'), namespace_, eol_))
        if self.ExistenceTime is not None:
            self.ExistenceTime.export(outfile, level, namespace_, name_='ExistenceTime', pretty_print=pretty_print)
        if self.DTimMin is not None:
            self.DTimMin.export(outfile, level, namespace_, name_='DTimMin', pretty_print=pretty_print)
        if self.DTimMax is not None:
            self.DTimMax.export(outfile, level, namespace_, name_='DTimMax', pretty_print=pretty_print)
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
        for ExternalConnect_ in self.ExternalConnect:
            ExternalConnect_.export(outfile, level, namespace_, name_='ExternalConnect', pretty_print=pretty_print)
        for Network_ in self.Network:
            Network_.export(outfile, level, namespace_, name_='Network', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ProductFlowModel, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Installation':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.Installation = obj_
            obj_.original_tagname_ = 'Installation'
        elif nodeName_ == 'ContextFacility':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.ContextFacility.append(obj_)
            obj_.original_tagname_ = 'ContextFacility'
        elif nodeName_ == 'DTimStart':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DTimStart = dval_
        elif nodeName_ == 'DTimEnd':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DTimEnd = dval_
        elif nodeName_ == 'ExistenceTime':
            obj_ = EndpointQualifiedDateTime.factory()
            obj_.build(child_)
            self.ExistenceTime = obj_
            obj_.original_tagname_ = 'ExistenceTime'
        elif nodeName_ == 'DTimMin':
            obj_ = EndpointQualifiedDateTime.factory()
            obj_.build(child_)
            self.DTimMin = obj_
            obj_.original_tagname_ = 'DTimMin'
        elif nodeName_ == 'DTimMax':
            obj_ = EndpointQualifiedDateTime.factory()
            obj_.build(child_)
            self.DTimMax = obj_
            obj_.original_tagname_ = 'DTimMax'
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        elif nodeName_ == 'ExternalConnect':
            obj_ = ProductFlowExternalReference.factory()
            obj_.build(child_)
            self.ExternalConnect.append(obj_)
            obj_.original_tagname_ = 'ExternalConnect'
        elif nodeName_ == 'Network':
            obj_ = ProductFlowNetwork.factory()
            obj_.build(child_)
            self.Network.append(obj_)
            obj_.original_tagname_ = 'Network'
        super(ProductFlowModel, self).buildChildren(child_, node, nodeName_, True)
# end class ProductFlowModel


class ProductVolume(AbstractObject):
    """The non-contextual content of a product volume object."""
    subclass = None
    superclass = AbstractObject
    def __init__(self, Installation=None, ContextFacility=None, Kind=None, PeriodKind=None, DTimMin=None, DTimMax=None, DTimCurrent=None, CalculationMethod=None, Operator=None, Title=None, GeographicContext=None, IssueDate=None, IssuedBy=None, ApprovalDate=None, Approver=None, StandardTempPres=None, ProductFlowModel=None, DateTime=None, Facility=None, BusinessUnit=None):
        self.original_tagname_ = None
        super(ProductVolume, self).__init__()
        self.Installation = Installation
        if ContextFacility is None:
            self.ContextFacility = []
        else:
            self.ContextFacility = ContextFacility
        self.Kind = Kind
        self.validate_String64(self.Kind)
        self.PeriodKind = PeriodKind
        self.validate_ReportingDurationKind(self.PeriodKind)
        self.DTimMin = DTimMin
        self.DTimMax = DTimMax
        if isinstance(DTimCurrent, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DTimCurrent, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DTimCurrent
        self.DTimCurrent = initvalue_
        self.CalculationMethod = CalculationMethod
        self.validate_CalculationMethod(self.CalculationMethod)
        self.Operator = Operator
        self.Title = Title
        self.GeographicContext = GeographicContext
        if isinstance(IssueDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(IssueDate, '%Y-%m-%d').date()
        else:
            initvalue_ = IssueDate
        self.IssueDate = initvalue_
        self.IssuedBy = IssuedBy
        if isinstance(ApprovalDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ApprovalDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ApprovalDate
        self.ApprovalDate = initvalue_
        self.Approver = Approver
        self.StandardTempPres = StandardTempPres
        self.validate_ReferenceCondition(self.StandardTempPres)
        self.ProductFlowModel = ProductFlowModel
        self.DateTime = DateTime
        if Facility is None:
            self.Facility = []
        else:
            self.Facility = Facility
        if BusinessUnit is None:
            self.BusinessUnit = []
        else:
            self.BusinessUnit = BusinessUnit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductVolume)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductVolume.subclass:
            return ProductVolume.subclass(*args_, **kwargs_)
        else:
            return ProductVolume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Installation(self): return self.Installation
    def set_Installation(self, Installation): self.Installation = Installation
    InstallationProp = property(get_Installation, set_Installation)
    def get_ContextFacility(self): return self.ContextFacility
    def set_ContextFacility(self, ContextFacility): self.ContextFacility = ContextFacility
    def add_ContextFacility(self, value): self.ContextFacility.append(value)
    def insert_ContextFacility_at(self, index, value): self.ContextFacility.insert(index, value)
    def replace_ContextFacility_at(self, index, value): self.ContextFacility[index] = value
    ContextFacilityProp = property(get_ContextFacility, set_ContextFacility)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    KindProp = property(get_Kind, set_Kind)
    def get_PeriodKind(self): return self.PeriodKind
    def set_PeriodKind(self, PeriodKind): self.PeriodKind = PeriodKind
    PeriodKindProp = property(get_PeriodKind, set_PeriodKind)
    def get_DTimMin(self): return self.DTimMin
    def set_DTimMin(self, DTimMin): self.DTimMin = DTimMin
    DTimMinProp = property(get_DTimMin, set_DTimMin)
    def get_DTimMax(self): return self.DTimMax
    def set_DTimMax(self, DTimMax): self.DTimMax = DTimMax
    DTimMaxProp = property(get_DTimMax, set_DTimMax)
    def get_DTimCurrent(self): return self.DTimCurrent
    def set_DTimCurrent(self, DTimCurrent): self.DTimCurrent = DTimCurrent
    DTimCurrentProp = property(get_DTimCurrent, set_DTimCurrent)
    def get_CalculationMethod(self): return self.CalculationMethod
    def set_CalculationMethod(self, CalculationMethod): self.CalculationMethod = CalculationMethod
    CalculationMethodProp = property(get_CalculationMethod, set_CalculationMethod)
    def get_Operator(self): return self.Operator
    def set_Operator(self, Operator): self.Operator = Operator
    OperatorProp = property(get_Operator, set_Operator)
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    TitleProp = property(get_Title, set_Title)
    def get_GeographicContext(self): return self.GeographicContext
    def set_GeographicContext(self, GeographicContext): self.GeographicContext = GeographicContext
    GeographicContextProp = property(get_GeographicContext, set_GeographicContext)
    def get_IssueDate(self): return self.IssueDate
    def set_IssueDate(self, IssueDate): self.IssueDate = IssueDate
    IssueDateProp = property(get_IssueDate, set_IssueDate)
    def get_IssuedBy(self): return self.IssuedBy
    def set_IssuedBy(self, IssuedBy): self.IssuedBy = IssuedBy
    IssuedByProp = property(get_IssuedBy, set_IssuedBy)
    def get_ApprovalDate(self): return self.ApprovalDate
    def set_ApprovalDate(self, ApprovalDate): self.ApprovalDate = ApprovalDate
    ApprovalDateProp = property(get_ApprovalDate, set_ApprovalDate)
    def get_Approver(self): return self.Approver
    def set_Approver(self, Approver): self.Approver = Approver
    ApproverProp = property(get_Approver, set_Approver)
    def get_StandardTempPres(self): return self.StandardTempPres
    def set_StandardTempPres(self, StandardTempPres): self.StandardTempPres = StandardTempPres
    StandardTempPresProp = property(get_StandardTempPres, set_StandardTempPres)
    def get_ProductFlowModel(self): return self.ProductFlowModel
    def set_ProductFlowModel(self, ProductFlowModel): self.ProductFlowModel = ProductFlowModel
    ProductFlowModelProp = property(get_ProductFlowModel, set_ProductFlowModel)
    def get_DateTime(self): return self.DateTime
    def set_DateTime(self, DateTime): self.DateTime = DateTime
    DateTimeProp = property(get_DateTime, set_DateTime)
    def get_Facility(self): return self.Facility
    def set_Facility(self, Facility): self.Facility = Facility
    def add_Facility(self, value): self.Facility.append(value)
    def insert_Facility_at(self, index, value): self.Facility.insert(index, value)
    def replace_Facility_at(self, index, value): self.Facility[index] = value
    FacilityProp = property(get_Facility, set_Facility)
    def get_BusinessUnit(self): return self.BusinessUnit
    def set_BusinessUnit(self, BusinessUnit): self.BusinessUnit = BusinessUnit
    def add_BusinessUnit(self, value): self.BusinessUnit.append(value)
    def insert_BusinessUnit_at(self, index, value): self.BusinessUnit.insert(index, value)
    def replace_BusinessUnit_at(self, index, value): self.BusinessUnit[index] = value
    BusinessUnitProp = property(get_BusinessUnit, set_BusinessUnit)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_ReportingDurationKind(self, value):
        # Validate type ReportingDurationKind, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['day', 'life to date', 'month', 'month to date', 'total cumulative', 'week', 'year', 'year to date']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReportingDurationKind' % {"value" : value.encode("utf-8")} )
    def validate_CalculationMethod(self, value):
        # Validate type CalculationMethod, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'step wise constant', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CalculationMethod' % {"value" : value.encode("utf-8")} )
    def validate_ReferenceCondition(self, value):
        # Validate type ReferenceCondition, a restriction on eml:TypeEnum.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0 degC 1 atm', '0 degC 1 bar', '15 degC 1 atm', '15 degC 1 bar', '20 degC 1 atm', '20 degC 1 bar', '25 degC 1 bar', '60 degF 1 atm', '60 degF 30 in Hg', 'ambient']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReferenceCondition' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Installation is not None or
            self.ContextFacility or
            self.Kind is not None or
            self.PeriodKind is not None or
            self.DTimMin is not None or
            self.DTimMax is not None or
            self.DTimCurrent is not None or
            self.CalculationMethod is not None or
            self.Operator is not None or
            self.Title is not None or
            self.GeographicContext is not None or
            self.IssueDate is not None or
            self.IssuedBy is not None or
            self.ApprovalDate is not None or
            self.Approver is not None or
            self.StandardTempPres is not None or
            self.ProductFlowModel is not None or
            self.DateTime is not None or
            self.Facility or
            self.BusinessUnit or
            super(ProductVolume, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProductVolume', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolume')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProductVolume', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProductVolume'):
        super(ProductVolume, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProductVolume')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProductVolume', fromsubclass_=False, pretty_print=True):
        super(ProductVolume, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Installation is not None:
            self.Installation.export(outfile, level, namespace_, name_='Installation', pretty_print=pretty_print)
        for ContextFacility_ in self.ContextFacility:
            ContextFacility_.export(outfile, level, namespace_, name_='ContextFacility', pretty_print=pretty_print)
        if self.Kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKind>%s</%sKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Kind), input_name='Kind')), namespace_, eol_))
        if self.PeriodKind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeriodKind>%s</%sPeriodKind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PeriodKind), input_name='PeriodKind')), namespace_, eol_))
        if self.DTimMin is not None:
            self.DTimMin.export(outfile, level, namespace_, name_='DTimMin', pretty_print=pretty_print)
        if self.DTimMax is not None:
            self.DTimMax.export(outfile, level, namespace_, name_='DTimMax', pretty_print=pretty_print)
        if self.DTimCurrent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDTimCurrent>%s</%sDTimCurrent>%s' % (namespace_, self.gds_format_datetime(self.DTimCurrent, input_name='DTimCurrent'), namespace_, eol_))
        if self.CalculationMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCalculationMethod>%s</%sCalculationMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CalculationMethod), input_name='CalculationMethod')), namespace_, eol_))
        if self.Operator is not None:
            self.Operator.export(outfile, level, namespace_, name_='Operator', pretty_print=pretty_print)
        if self.Title is not None:
            self.Title.export(outfile, level, namespace_, name_='Title', pretty_print=pretty_print)
        if self.GeographicContext is not None:
            self.GeographicContext.export(outfile, level, namespace_, name_='GeographicContext', pretty_print=pretty_print)
        if self.IssueDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssueDate>%s</%sIssueDate>%s' % (namespace_, self.gds_format_date(self.IssueDate, input_name='IssueDate'), namespace_, eol_))
        if self.IssuedBy is not None:
            self.IssuedBy.export(outfile, level, namespace_, name_='IssuedBy', pretty_print=pretty_print)
        if self.ApprovalDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApprovalDate>%s</%sApprovalDate>%s' % (namespace_, self.gds_format_date(self.ApprovalDate, input_name='ApprovalDate'), namespace_, eol_))
        if self.Approver is not None:
            self.Approver.export(outfile, level, namespace_, name_='Approver', pretty_print=pretty_print)
        if self.StandardTempPres is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStandardTempPres>%s</%sStandardTempPres>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StandardTempPres), input_name='StandardTempPres')), namespace_, eol_))
        if self.ProductFlowModel is not None:
            self.ProductFlowModel.export(outfile, level, namespace_, name_='ProductFlowModel', pretty_print=pretty_print)
        if self.DateTime is not None:
            self.DateTime.export(outfile, level, namespace_, name_='DateTime', pretty_print=pretty_print)
        for Facility_ in self.Facility:
            Facility_.export(outfile, level, namespace_, name_='Facility', pretty_print=pretty_print)
        for BusinessUnit_ in self.BusinessUnit:
            BusinessUnit_.export(outfile, level, namespace_, name_='BusinessUnit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ProductVolume, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Installation':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.Installation = obj_
            obj_.original_tagname_ = 'Installation'
        elif nodeName_ == 'ContextFacility':
            obj_ = FacilityIdentifierStruct.factory()
            obj_.build(child_)
            self.ContextFacility.append(obj_)
            obj_.original_tagname_ = 'ContextFacility'
        elif nodeName_ == 'Kind':
            Kind_ = child_.text
            Kind_ = self.gds_validate_string(Kind_, node, 'Kind')
            self.Kind = Kind_
            # validate type String64
            self.validate_String64(self.Kind)
        elif nodeName_ == 'PeriodKind':
            PeriodKind_ = child_.text
            PeriodKind_ = self.gds_validate_string(PeriodKind_, node, 'PeriodKind')
            self.PeriodKind = PeriodKind_
            # validate type ReportingDurationKind
            self.validate_ReportingDurationKind(self.PeriodKind)
        elif nodeName_ == 'DTimMin':
            obj_ = EndpointQualifiedDateTime.factory()
            obj_.build(child_)
            self.DTimMin = obj_
            obj_.original_tagname_ = 'DTimMin'
        elif nodeName_ == 'DTimMax':
            obj_ = EndpointQualifiedDateTime.factory()
            obj_.build(child_)
            self.DTimMax = obj_
            obj_.original_tagname_ = 'DTimMax'
        elif nodeName_ == 'DTimCurrent':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DTimCurrent = dval_
        elif nodeName_ == 'CalculationMethod':
            CalculationMethod_ = child_.text
            CalculationMethod_ = self.gds_validate_string(CalculationMethod_, node, 'CalculationMethod')
            self.CalculationMethod = CalculationMethod_
            # validate type CalculationMethod
            self.validate_CalculationMethod(self.CalculationMethod)
        elif nodeName_ == 'Operator':
            obj_ = BusinessAssociate.factory()
            obj_.build(child_)
            self.Operator = obj_
            obj_.original_tagname_ = 'Operator'
        elif nodeName_ == 'Title':
            obj_ = NameStruct.factory()
            obj_.build(child_)
            self.Title = obj_
            obj_.original_tagname_ = 'Title'
        elif nodeName_ == 'GeographicContext':
            obj_ = GeographicContext.factory()
            obj_.build(child_)
            self.GeographicContext = obj_
            obj_.original_tagname_ = 'GeographicContext'
        elif nodeName_ == 'IssueDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.IssueDate = dval_
        elif nodeName_ == 'IssuedBy':
            obj_ = BusinessAssociate.factory()
            obj_.build(child_)
            self.IssuedBy = obj_
            obj_.original_tagname_ = 'IssuedBy'
        elif nodeName_ == 'ApprovalDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ApprovalDate = dval_
        elif nodeName_ == 'Approver':
            obj_ = BusinessAssociate.factory()
            obj_.build(child_)
            self.Approver = obj_
            obj_.original_tagname_ = 'Approver'
        elif nodeName_ == 'StandardTempPres':
            StandardTempPres_ = child_.text
            StandardTempPres_ = self.gds_validate_string(StandardTempPres_, node, 'StandardTempPres')
            self.StandardTempPres = StandardTempPres_
            # validate type ReferenceCondition
            self.validate_ReferenceCondition(self.StandardTempPres)
        elif nodeName_ == 'ProductFlowModel':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.ProductFlowModel = obj_
            obj_.original_tagname_ = 'ProductFlowModel'
        elif nodeName_ == 'DateTime':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <DateTime> element')
            self.DateTime = obj_
            obj_.original_tagname_ = 'DateTime'
        elif nodeName_ == 'Facility':
            obj_ = ProductVolumeFacility.factory()
            obj_.build(child_)
            self.Facility.append(obj_)
            obj_.original_tagname_ = 'Facility'
        elif nodeName_ == 'BusinessUnit':
            obj_ = ProductVolumeBusinessUnit.factory()
            obj_.build(child_)
            self.BusinessUnit.append(obj_)
            obj_.original_tagname_ = 'BusinessUnit'
        super(ProductVolume, self).buildChildren(child_, node, nodeName_, True)
# end class ProductVolume


class KindQualifiedString(AbstractMeasureDataType):
    """A kind which may have a quality status. If the 'status' attribute is
    absent and the value is not "NaN", the data value can be assumed
    to be good with no restrictions.An indicator of the quality of
    the value."""
    subclass = None
    superclass = AbstractMeasureDataType
    def __init__(self, status=None):
        self.original_tagname_ = None
        super(KindQualifiedString, self).__init__()
        self.status = _cast(None, status)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KindQualifiedString)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KindQualifiedString.subclass:
            return KindQualifiedString.subclass(*args_, **kwargs_)
        else:
            return KindQualifiedString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    statusProp = property(get_status, set_status)
    def hasContent_(self):
        if (
            super(KindQualifiedString, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='KindQualifiedString', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KindQualifiedString')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='KindQualifiedString', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='KindQualifiedString'):
        super(KindQualifiedString, self).exportAttributes(outfile, level, already_processed, namespace_, name_='KindQualifiedString')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='KindQualifiedString', fromsubclass_=False, pretty_print=True):
        super(KindQualifiedString, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        super(KindQualifiedString, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(KindQualifiedString, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class KindQualifiedString


class IntegerQualifiedCount(AbstractMeasureDataType):
    """An integer which may have a quality status. If the 'status'
    attribute is absent and the value is not "NaN", the data value
    can be assumed to be good with no restrictions.An indicator of
    the quality of the value."""
    subclass = None
    superclass = AbstractMeasureDataType
    def __init__(self, status=None):
        self.original_tagname_ = None
        super(IntegerQualifiedCount, self).__init__()
        self.status = _cast(None, status)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntegerQualifiedCount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntegerQualifiedCount.subclass:
            return IntegerQualifiedCount.subclass(*args_, **kwargs_)
        else:
            return IntegerQualifiedCount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    statusProp = property(get_status, set_status)
    def hasContent_(self):
        if (
            super(IntegerQualifiedCount, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='IntegerQualifiedCount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerQualifiedCount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='IntegerQualifiedCount', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='IntegerQualifiedCount'):
        super(IntegerQualifiedCount, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerQualifiedCount')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='IntegerQualifiedCount', fromsubclass_=False, pretty_print=True):
        super(IntegerQualifiedCount, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        super(IntegerQualifiedCount, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IntegerQualifiedCount, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IntegerQualifiedCount


class GeneralQualifiedMeasure(AbstractMeasureDataType):
    """A measure which may have a quality status. The measure class (e.g.,
    length) must be defined within the context of the usage of this
    type (e.g., in another element). This should not be used if the
    measure class will always be the same thing. If the 'status'
    attribute is absent and the value is not "NaN", the data value
    can be assumed to be good with no restrictions.An indicator of
    the quality of the value.The kind of the value component. For
    example, "X" in a tuple of X and Y.The unit of measure for the
    value. This value must conform to the values allowed by the
    measure class."""
    subclass = None
    superclass = AbstractMeasureDataType
    def __init__(self, status=None, componentReference=None, uom=None):
        self.original_tagname_ = None
        super(GeneralQualifiedMeasure, self).__init__()
        self.status = _cast(None, status)
        self.componentReference = _cast(None, componentReference)
        self.uom = _cast(None, uom)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralQualifiedMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralQualifiedMeasure.subclass:
            return GeneralQualifiedMeasure.subclass(*args_, **kwargs_)
        else:
            return GeneralQualifiedMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    statusProp = property(get_status, set_status)
    def get_componentReference(self): return self.componentReference
    def set_componentReference(self, componentReference): self.componentReference = componentReference
    componentReferenceProp = property(get_componentReference, set_componentReference)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    uomProp = property(get_uom, set_uom)
    def hasContent_(self):
        if (
            super(GeneralQualifiedMeasure, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeneralQualifiedMeasure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeneralQualifiedMeasure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeneralQualifiedMeasure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeneralQualifiedMeasure'):
        super(GeneralQualifiedMeasure, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeneralQualifiedMeasure')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.componentReference is not None and 'componentReference' not in already_processed:
            already_processed.add('componentReference')
            outfile.write(' componentReference=%s' % (quote_attrib(self.componentReference), ))
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeneralQualifiedMeasure', fromsubclass_=False, pretty_print=True):
        super(GeneralQualifiedMeasure, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('componentReference', node)
        if value is not None and 'componentReference' not in already_processed:
            already_processed.add('componentReference')
            self.componentReference = value
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
        super(GeneralQualifiedMeasure, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GeneralQualifiedMeasure, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GeneralQualifiedMeasure


class FiberOpticalPath(AbstractObject):
    """The optical fiber path used for distributed property surveys, e.g.
    temperature (DTS) or acoustics (DAS). Comprises a number of
    items of equipment, such as fiber segments and connectors of
    various types."""
    subclass = None
    superclass = AbstractObject
    def __init__(self, Inventory=None, OpticalPathNetwork=None, FacilityMapping=None, Defect=None, Otdr=None, InstallingVendor=None, FacilityIdentifier=None):
        self.original_tagname_ = None
        super(FiberOpticalPath, self).__init__()
        self.Inventory = Inventory
        if OpticalPathNetwork is None:
            self.OpticalPathNetwork = []
        else:
            self.OpticalPathNetwork = OpticalPathNetwork
        if FacilityMapping is None:
            self.FacilityMapping = []
        else:
            self.FacilityMapping = FacilityMapping
        if Defect is None:
            self.Defect = []
        else:
            self.Defect = Defect
        if Otdr is None:
            self.Otdr = []
        else:
            self.Otdr = Otdr
        self.InstallingVendor = InstallingVendor
        self.FacilityIdentifier = FacilityIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiberOpticalPath)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiberOpticalPath.subclass:
            return FiberOpticalPath.subclass(*args_, **kwargs_)
        else:
            return FiberOpticalPath(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Inventory(self): return self.Inventory
    def set_Inventory(self, Inventory): self.Inventory = Inventory
    InventoryProp = property(get_Inventory, set_Inventory)
    def get_OpticalPathNetwork(self): return self.OpticalPathNetwork
    def set_OpticalPathNetwork(self, OpticalPathNetwork): self.OpticalPathNetwork = OpticalPathNetwork
    def add_OpticalPathNetwork(self, value): self.OpticalPathNetwork.append(value)
    def insert_OpticalPathNetwork_at(self, index, value): self.OpticalPathNetwork.insert(index, value)
    def replace_OpticalPathNetwork_at(self, index, value): self.OpticalPathNetwork[index] = value
    OpticalPathNetworkProp = property(get_OpticalPathNetwork, set_OpticalPathNetwork)
    def get_FacilityMapping(self): return self.FacilityMapping
    def set_FacilityMapping(self, FacilityMapping): self.FacilityMapping = FacilityMapping
    def add_FacilityMapping(self, value): self.FacilityMapping.append(value)
    def insert_FacilityMapping_at(self, index, value): self.FacilityMapping.insert(index, value)
    def replace_FacilityMapping_at(self, index, value): self.FacilityMapping[index] = value
    FacilityMappingProp = property(get_FacilityMapping, set_FacilityMapping)
    def get_Defect(self): return self.Defect
    def set_Defect(self, Defect): self.Defect = Defect
    def add_Defect(self, value): self.Defect.append(value)
    def insert_Defect_at(self, index, value): self.Defect.insert(index, value)
    def replace_Defect_at(self, index, value): self.Defect[index] = value
    DefectProp = property(get_Defect, set_Defect)
    def get_Otdr(self): return self.Otdr
    def set_Otdr(self, Otdr): self.Otdr = Otdr
    def add_Otdr(self, value): self.Otdr.append(value)
    def insert_Otdr_at(self, index, value): self.Otdr.insert(index, value)
    def replace_Otdr_at(self, index, value): self.Otdr[index] = value
    OtdrProp = property(get_Otdr, set_Otdr)
    def get_InstallingVendor(self): return self.InstallingVendor
    def set_InstallingVendor(self, InstallingVendor): self.InstallingVendor = InstallingVendor
    InstallingVendorProp = property(get_InstallingVendor, set_InstallingVendor)
    def get_FacilityIdentifier(self): return self.FacilityIdentifier
    def set_FacilityIdentifier(self, FacilityIdentifier): self.FacilityIdentifier = FacilityIdentifier
    FacilityIdentifierProp = property(get_FacilityIdentifier, set_FacilityIdentifier)
    def hasContent_(self):
        if (
            self.Inventory is not None or
            self.OpticalPathNetwork or
            self.FacilityMapping or
            self.Defect or
            self.Otdr or
            self.InstallingVendor is not None or
            self.FacilityIdentifier is not None or
            super(FiberOpticalPath, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FiberOpticalPath', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiberOpticalPath')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FiberOpticalPath', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FiberOpticalPath'):
        super(FiberOpticalPath, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FiberOpticalPath')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FiberOpticalPath', fromsubclass_=False, pretty_print=True):
        super(FiberOpticalPath, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Inventory is not None:
            self.Inventory.export(outfile, level, namespace_, name_='Inventory', pretty_print=pretty_print)
        for OpticalPathNetwork_ in self.OpticalPathNetwork:
            OpticalPathNetwork_.export(outfile, level, namespace_, name_='OpticalPathNetwork', pretty_print=pretty_print)
        for FacilityMapping_ in self.FacilityMapping:
            FacilityMapping_.export(outfile, level, namespace_, name_='FacilityMapping', pretty_print=pretty_print)
        for Defect_ in self.Defect:
            Defect_.export(outfile, level, namespace_, name_='Defect', pretty_print=pretty_print)
        for Otdr_ in self.Otdr:
            Otdr_.export(outfile, level, namespace_, name_='Otdr', pretty_print=pretty_print)
        if self.InstallingVendor is not None:
            self.InstallingVendor.export(outfile, level, namespace_, name_='InstallingVendor', pretty_print=pretty_print)
        if self.FacilityIdentifier is not None:
            self.FacilityIdentifier.export(outfile, level, namespace_, name_='FacilityIdentifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FiberOpticalPath, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Inventory':
            obj_ = FiberOpticalPathInventory.factory()
            obj_.build(child_)
            self.Inventory = obj_
            obj_.original_tagname_ = 'Inventory'
        elif nodeName_ == 'OpticalPathNetwork':
            obj_ = FiberOpticalPathNetwork.factory()
            obj_.build(child_)
            self.OpticalPathNetwork.append(obj_)
            obj_.original_tagname_ = 'OpticalPathNetwork'
        elif nodeName_ == 'FacilityMapping':
            obj_ = FiberFacilityMapping.factory()
            obj_.build(child_)
            self.FacilityMapping.append(obj_)
            obj_.original_tagname_ = 'FacilityMapping'
        elif nodeName_ == 'Defect':
            obj_ = FiberPathDefect.factory()
            obj_.build(child_)
            self.Defect.append(obj_)
            obj_.original_tagname_ = 'Defect'
        elif nodeName_ == 'Otdr':
            obj_ = FiberOTDR.factory()
            obj_.build(child_)
            self.Otdr.append(obj_)
            obj_.original_tagname_ = 'Otdr'
        elif nodeName_ == 'InstallingVendor':
            obj_ = BusinessAssociate.factory()
            obj_.build(child_)
            self.InstallingVendor = obj_
            obj_.original_tagname_ = 'InstallingVendor'
        elif nodeName_ == 'FacilityIdentifier':
            obj_ = FacilityIdentifier.factory()
            obj_.build(child_)
            self.FacilityIdentifier = obj_
            obj_.original_tagname_ = 'FacilityIdentifier'
        super(FiberOpticalPath, self).buildChildren(child_, node, nodeName_, True)
# end class FiberOpticalPath


class DtsInstalledSystem(AbstractObject):
    """The group of elements corresponding to a DTS installed system."""
    subclass = None
    superclass = AbstractObject
    def __init__(self, DateMin=None, DateMax=None, OpticalPathLength=None, OpticalBudget=None, OpticalPathReference=None, InstrumentBoxReference=None, Comment=None, FacilityIdentifier=None, DtsCalibration=None):
        self.original_tagname_ = None
        super(DtsInstalledSystem, self).__init__()
        if isinstance(DateMin, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DateMin, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DateMin
        self.DateMin = initvalue_
        if isinstance(DateMax, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DateMax, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DateMax
        self.DateMax = initvalue_
        self.OpticalPathLength = OpticalPathLength
        self.OpticalBudget = OpticalBudget
        self.OpticalPathReference = OpticalPathReference
        self.InstrumentBoxReference = InstrumentBoxReference
        self.Comment = Comment
        self.validate_String2000(self.Comment)
        self.FacilityIdentifier = FacilityIdentifier
        if DtsCalibration is None:
            self.DtsCalibration = []
        else:
            self.DtsCalibration = DtsCalibration
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DtsInstalledSystem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DtsInstalledSystem.subclass:
            return DtsInstalledSystem.subclass(*args_, **kwargs_)
        else:
            return DtsInstalledSystem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DateMin(self): return self.DateMin
    def set_DateMin(self, DateMin): self.DateMin = DateMin
    DateMinProp = property(get_DateMin, set_DateMin)
    def get_DateMax(self): return self.DateMax
    def set_DateMax(self, DateMax): self.DateMax = DateMax
    DateMaxProp = property(get_DateMax, set_DateMax)
    def get_OpticalPathLength(self): return self.OpticalPathLength
    def set_OpticalPathLength(self, OpticalPathLength): self.OpticalPathLength = OpticalPathLength
    OpticalPathLengthProp = property(get_OpticalPathLength, set_OpticalPathLength)
    def get_OpticalBudget(self): return self.OpticalBudget
    def set_OpticalBudget(self, OpticalBudget): self.OpticalBudget = OpticalBudget
    OpticalBudgetProp = property(get_OpticalBudget, set_OpticalBudget)
    def get_OpticalPathReference(self): return self.OpticalPathReference
    def set_OpticalPathReference(self, OpticalPathReference): self.OpticalPathReference = OpticalPathReference
    OpticalPathReferenceProp = property(get_OpticalPathReference, set_OpticalPathReference)
    def get_InstrumentBoxReference(self): return self.InstrumentBoxReference
    def set_InstrumentBoxReference(self, InstrumentBoxReference): self.InstrumentBoxReference = InstrumentBoxReference
    InstrumentBoxReferenceProp = property(get_InstrumentBoxReference, set_InstrumentBoxReference)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    CommentProp = property(get_Comment, set_Comment)
    def get_FacilityIdentifier(self): return self.FacilityIdentifier
    def set_FacilityIdentifier(self, FacilityIdentifier): self.FacilityIdentifier = FacilityIdentifier
    FacilityIdentifierProp = property(get_FacilityIdentifier, set_FacilityIdentifier)
    def get_DtsCalibration(self): return self.DtsCalibration
    def set_DtsCalibration(self, DtsCalibration): self.DtsCalibration = DtsCalibration
    def add_DtsCalibration(self, value): self.DtsCalibration.append(value)
    def insert_DtsCalibration_at(self, index, value): self.DtsCalibration.insert(index, value)
    def replace_DtsCalibration_at(self, index, value): self.DtsCalibration[index] = value
    DtsCalibrationProp = property(get_DtsCalibration, set_DtsCalibration)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.DateMin is not None or
            self.DateMax is not None or
            self.OpticalPathLength is not None or
            self.OpticalBudget is not None or
            self.OpticalPathReference is not None or
            self.InstrumentBoxReference is not None or
            self.Comment is not None or
            self.FacilityIdentifier is not None or
            self.DtsCalibration or
            super(DtsInstalledSystem, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DtsInstalledSystem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DtsInstalledSystem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DtsInstalledSystem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DtsInstalledSystem'):
        super(DtsInstalledSystem, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DtsInstalledSystem')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DtsInstalledSystem', fromsubclass_=False, pretty_print=True):
        super(DtsInstalledSystem, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DateMin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateMin>%s</%sDateMin>%s' % (namespace_, self.gds_format_datetime(self.DateMin, input_name='DateMin'), namespace_, eol_))
        if self.DateMax is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateMax>%s</%sDateMax>%s' % (namespace_, self.gds_format_datetime(self.DateMax, input_name='DateMax'), namespace_, eol_))
        if self.OpticalPathLength is not None:
            self.OpticalPathLength.export(outfile, level, namespace_, name_='OpticalPathLength', pretty_print=pretty_print)
        if self.OpticalBudget is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOpticalBudget>%s</%sOpticalBudget>%s' % (namespace_, self.gds_format_double(self.OpticalBudget, input_name='OpticalBudget'), namespace_, eol_))
        if self.OpticalPathReference is not None:
            self.OpticalPathReference.export(outfile, level, namespace_, name_='OpticalPathReference', pretty_print=pretty_print)
        if self.InstrumentBoxReference is not None:
            self.InstrumentBoxReference.export(outfile, level, namespace_, name_='InstrumentBoxReference', pretty_print=pretty_print)
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespace_, eol_))
        if self.FacilityIdentifier is not None:
            self.FacilityIdentifier.export(outfile, level, namespace_, name_='FacilityIdentifier', pretty_print=pretty_print)
        for DtsCalibration_ in self.DtsCalibration:
            DtsCalibration_.export(outfile, level, namespace_, name_='DtsCalibration', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DtsInstalledSystem, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DateMin':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DateMin = dval_
        elif nodeName_ == 'DateMax':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DateMax = dval_
        elif nodeName_ == 'OpticalPathLength':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.OpticalPathLength = obj_
            obj_.original_tagname_ = 'OpticalPathLength'
        elif nodeName_ == 'OpticalBudget':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'OpticalBudget')
            self.OpticalBudget = fval_
        elif nodeName_ == 'OpticalPathReference':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.OpticalPathReference = obj_
            obj_.original_tagname_ = 'OpticalPathReference'
        elif nodeName_ == 'InstrumentBoxReference':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.InstrumentBoxReference = obj_
            obj_.original_tagname_ = 'InstrumentBoxReference'
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
            # validate type String2000
            self.validate_String2000(self.Comment)
        elif nodeName_ == 'FacilityIdentifier':
            obj_ = FacilityIdentifier.factory()
            obj_.build(child_)
            self.FacilityIdentifier = obj_
            obj_.original_tagname_ = 'FacilityIdentifier'
        elif nodeName_ == 'DtsCalibration':
            obj_ = DtsCalibration.factory()
            obj_.build(child_)
            self.DtsCalibration.append(obj_)
            obj_.original_tagname_ = 'DtsCalibration'
        super(DtsInstalledSystem, self).buildChildren(child_, node, nodeName_, True)
# end class DtsInstalledSystem


class DtsInstrumentBox(AbstractObject):
    """The group of elements corresponding to a DTS instrument box."""
    subclass = None
    superclass = AbstractObject
    def __init__(self, SerialNumber=None, InternalOvenLocationNear=None, InternalOvenLocationFar=None, ReferenceCoilTemperature=None, Parameter=None, WarmupTime=None, StartupTime=None, FacilityIdentifier=None, DtsPatchCord=None, InstrumentCalibration=None, Instrument=None):
        self.original_tagname_ = None
        super(DtsInstrumentBox, self).__init__()
        self.SerialNumber = SerialNumber
        self.validate_String64(self.SerialNumber)
        self.InternalOvenLocationNear = InternalOvenLocationNear
        self.InternalOvenLocationFar = InternalOvenLocationFar
        self.ReferenceCoilTemperature = ReferenceCoilTemperature
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
        self.WarmupTime = WarmupTime
        self.StartupTime = StartupTime
        self.FacilityIdentifier = FacilityIdentifier
        self.DtsPatchCord = DtsPatchCord
        if InstrumentCalibration is None:
            self.InstrumentCalibration = []
        else:
            self.InstrumentCalibration = InstrumentCalibration
        self.Instrument = Instrument
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DtsInstrumentBox)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DtsInstrumentBox.subclass:
            return DtsInstrumentBox.subclass(*args_, **kwargs_)
        else:
            return DtsInstrumentBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SerialNumber(self): return self.SerialNumber
    def set_SerialNumber(self, SerialNumber): self.SerialNumber = SerialNumber
    SerialNumberProp = property(get_SerialNumber, set_SerialNumber)
    def get_InternalOvenLocationNear(self): return self.InternalOvenLocationNear
    def set_InternalOvenLocationNear(self, InternalOvenLocationNear): self.InternalOvenLocationNear = InternalOvenLocationNear
    InternalOvenLocationNearProp = property(get_InternalOvenLocationNear, set_InternalOvenLocationNear)
    def get_InternalOvenLocationFar(self): return self.InternalOvenLocationFar
    def set_InternalOvenLocationFar(self, InternalOvenLocationFar): self.InternalOvenLocationFar = InternalOvenLocationFar
    InternalOvenLocationFarProp = property(get_InternalOvenLocationFar, set_InternalOvenLocationFar)
    def get_ReferenceCoilTemperature(self): return self.ReferenceCoilTemperature
    def set_ReferenceCoilTemperature(self, ReferenceCoilTemperature): self.ReferenceCoilTemperature = ReferenceCoilTemperature
    ReferenceCoilTemperatureProp = property(get_ReferenceCoilTemperature, set_ReferenceCoilTemperature)
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    def add_Parameter(self, value): self.Parameter.append(value)
    def insert_Parameter_at(self, index, value): self.Parameter.insert(index, value)
    def replace_Parameter_at(self, index, value): self.Parameter[index] = value
    ParameterProp = property(get_Parameter, set_Parameter)
    def get_WarmupTime(self): return self.WarmupTime
    def set_WarmupTime(self, WarmupTime): self.WarmupTime = WarmupTime
    WarmupTimeProp = property(get_WarmupTime, set_WarmupTime)
    def get_StartupTime(self): return self.StartupTime
    def set_StartupTime(self, StartupTime): self.StartupTime = StartupTime
    StartupTimeProp = property(get_StartupTime, set_StartupTime)
    def get_FacilityIdentifier(self): return self.FacilityIdentifier
    def set_FacilityIdentifier(self, FacilityIdentifier): self.FacilityIdentifier = FacilityIdentifier
    FacilityIdentifierProp = property(get_FacilityIdentifier, set_FacilityIdentifier)
    def get_DtsPatchCord(self): return self.DtsPatchCord
    def set_DtsPatchCord(self, DtsPatchCord): self.DtsPatchCord = DtsPatchCord
    DtsPatchCordProp = property(get_DtsPatchCord, set_DtsPatchCord)
    def get_InstrumentCalibration(self): return self.InstrumentCalibration
    def set_InstrumentCalibration(self, InstrumentCalibration): self.InstrumentCalibration = InstrumentCalibration
    def add_InstrumentCalibration(self, value): self.InstrumentCalibration.append(value)
    def insert_InstrumentCalibration_at(self, index, value): self.InstrumentCalibration.insert(index, value)
    def replace_InstrumentCalibration_at(self, index, value): self.InstrumentCalibration[index] = value
    InstrumentCalibrationProp = property(get_InstrumentCalibration, set_InstrumentCalibration)
    def get_Instrument(self): return self.Instrument
    def set_Instrument(self, Instrument): self.Instrument = Instrument
    InstrumentProp = property(get_Instrument, set_Instrument)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def hasContent_(self):
        if (
            self.SerialNumber is not None or
            self.InternalOvenLocationNear is not None or
            self.InternalOvenLocationFar is not None or
            self.ReferenceCoilTemperature is not None or
            self.Parameter or
            self.WarmupTime is not None or
            self.StartupTime is not None or
            self.FacilityIdentifier is not None or
            self.DtsPatchCord is not None or
            self.InstrumentCalibration or
            self.Instrument is not None or
            super(DtsInstrumentBox, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DtsInstrumentBox', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DtsInstrumentBox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DtsInstrumentBox', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DtsInstrumentBox'):
        super(DtsInstrumentBox, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DtsInstrumentBox')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DtsInstrumentBox', fromsubclass_=False, pretty_print=True):
        super(DtsInstrumentBox, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SerialNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSerialNumber>%s</%sSerialNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SerialNumber), input_name='SerialNumber')), namespace_, eol_))
        if self.InternalOvenLocationNear is not None:
            self.InternalOvenLocationNear.export(outfile, level, namespace_, name_='InternalOvenLocationNear', pretty_print=pretty_print)
        if self.InternalOvenLocationFar is not None:
            self.InternalOvenLocationFar.export(outfile, level, namespace_, name_='InternalOvenLocationFar', pretty_print=pretty_print)
        if self.ReferenceCoilTemperature is not None:
            self.ReferenceCoilTemperature.export(outfile, level, namespace_, name_='ReferenceCoilTemperature', pretty_print=pretty_print)
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, namespace_, name_='Parameter', pretty_print=pretty_print)
        if self.WarmupTime is not None:
            self.WarmupTime.export(outfile, level, namespace_, name_='WarmupTime', pretty_print=pretty_print)
        if self.StartupTime is not None:
            self.StartupTime.export(outfile, level, namespace_, name_='StartupTime', pretty_print=pretty_print)
        if self.FacilityIdentifier is not None:
            self.FacilityIdentifier.export(outfile, level, namespace_, name_='FacilityIdentifier', pretty_print=pretty_print)
        if self.DtsPatchCord is not None:
            self.DtsPatchCord.export(outfile, level, namespace_, name_='DtsPatchCord', pretty_print=pretty_print)
        for InstrumentCalibration_ in self.InstrumentCalibration:
            InstrumentCalibration_.export(outfile, level, namespace_, name_='InstrumentCalibration', pretty_print=pretty_print)
        if self.Instrument is not None:
            self.Instrument.export(outfile, level, namespace_, name_='Instrument', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DtsInstrumentBox, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SerialNumber':
            SerialNumber_ = child_.text
            SerialNumber_ = self.gds_validate_string(SerialNumber_, node, 'SerialNumber')
            self.SerialNumber = SerialNumber_
            # validate type String64
            self.validate_String64(self.SerialNumber)
        elif nodeName_ == 'InternalOvenLocationNear':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.InternalOvenLocationNear = obj_
            obj_.original_tagname_ = 'InternalOvenLocationNear'
        elif nodeName_ == 'InternalOvenLocationFar':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.InternalOvenLocationFar = obj_
            obj_.original_tagname_ = 'InternalOvenLocationFar'
        elif nodeName_ == 'ReferenceCoilTemperature':
            obj_ = ThermodynamicTemperatureMeasure.factory()
            obj_.build(child_)
            self.ReferenceCoilTemperature = obj_
            obj_.original_tagname_ = 'ReferenceCoilTemperature'
        elif nodeName_ == 'Parameter':
            obj_ = IndexedObject.factory()
            obj_.build(child_)
            self.Parameter.append(obj_)
            obj_.original_tagname_ = 'Parameter'
        elif nodeName_ == 'WarmupTime':
            obj_ = TimeMeasure.factory()
            obj_.build(child_)
            self.WarmupTime = obj_
            obj_.original_tagname_ = 'WarmupTime'
        elif nodeName_ == 'StartupTime':
            obj_ = TimeMeasure.factory()
            obj_.build(child_)
            self.StartupTime = obj_
            obj_.original_tagname_ = 'StartupTime'
        elif nodeName_ == 'FacilityIdentifier':
            obj_ = FacilityIdentifier.factory()
            obj_.build(child_)
            self.FacilityIdentifier = obj_
            obj_.original_tagname_ = 'FacilityIdentifier'
        elif nodeName_ == 'DtsPatchCord':
            obj_ = DtsPatchCord.factory()
            obj_.build(child_)
            self.DtsPatchCord = obj_
            obj_.original_tagname_ = 'DtsPatchCord'
        elif nodeName_ == 'InstrumentCalibration':
            obj_ = DtsCalibration.factory()
            obj_.build(child_)
            self.InstrumentCalibration.append(obj_)
            obj_.original_tagname_ = 'InstrumentCalibration'
        elif nodeName_ == 'Instrument':
            class_obj_ = self.get_class_obj_(child_, Instrument)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Instrument = obj_
            obj_.original_tagname_ = 'Instrument'
        super(DtsInstrumentBox, self).buildChildren(child_, node, nodeName_, True)
# end class DtsInstrumentBox


class DasInstrumentBox(AbstractObject):
    """The group of elements corresponding to a DAS instrument box."""
    subclass = None
    superclass = AbstractObject
    def __init__(self, SerialNumber=None, Parameter=None, FacilityIdentifier=None, Instrument=None, FirmwareVersion=None, PatchCord=None, InstrumentBoxDescription=None):
        self.original_tagname_ = None
        super(DasInstrumentBox, self).__init__()
        self.SerialNumber = SerialNumber
        self.validate_String64(self.SerialNumber)
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
        self.FacilityIdentifier = FacilityIdentifier
        self.Instrument = Instrument
        self.FirmwareVersion = FirmwareVersion
        self.validate_String64(self.FirmwareVersion)
        self.PatchCord = PatchCord
        self.InstrumentBoxDescription = InstrumentBoxDescription
        self.validate_String2000(self.InstrumentBoxDescription)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DasInstrumentBox)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DasInstrumentBox.subclass:
            return DasInstrumentBox.subclass(*args_, **kwargs_)
        else:
            return DasInstrumentBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SerialNumber(self): return self.SerialNumber
    def set_SerialNumber(self, SerialNumber): self.SerialNumber = SerialNumber
    SerialNumberProp = property(get_SerialNumber, set_SerialNumber)
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    def add_Parameter(self, value): self.Parameter.append(value)
    def insert_Parameter_at(self, index, value): self.Parameter.insert(index, value)
    def replace_Parameter_at(self, index, value): self.Parameter[index] = value
    ParameterProp = property(get_Parameter, set_Parameter)
    def get_FacilityIdentifier(self): return self.FacilityIdentifier
    def set_FacilityIdentifier(self, FacilityIdentifier): self.FacilityIdentifier = FacilityIdentifier
    FacilityIdentifierProp = property(get_FacilityIdentifier, set_FacilityIdentifier)
    def get_Instrument(self): return self.Instrument
    def set_Instrument(self, Instrument): self.Instrument = Instrument
    InstrumentProp = property(get_Instrument, set_Instrument)
    def get_FirmwareVersion(self): return self.FirmwareVersion
    def set_FirmwareVersion(self, FirmwareVersion): self.FirmwareVersion = FirmwareVersion
    FirmwareVersionProp = property(get_FirmwareVersion, set_FirmwareVersion)
    def get_PatchCord(self): return self.PatchCord
    def set_PatchCord(self, PatchCord): self.PatchCord = PatchCord
    PatchCordProp = property(get_PatchCord, set_PatchCord)
    def get_InstrumentBoxDescription(self): return self.InstrumentBoxDescription
    def set_InstrumentBoxDescription(self, InstrumentBoxDescription): self.InstrumentBoxDescription = InstrumentBoxDescription
    InstrumentBoxDescriptionProp = property(get_InstrumentBoxDescription, set_InstrumentBoxDescription)
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def hasContent_(self):
        if (
            self.SerialNumber is not None or
            self.Parameter or
            self.FacilityIdentifier is not None or
            self.Instrument is not None or
            self.FirmwareVersion is not None or
            self.PatchCord is not None or
            self.InstrumentBoxDescription is not None or
            super(DasInstrumentBox, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DasInstrumentBox', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DasInstrumentBox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DasInstrumentBox', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DasInstrumentBox'):
        super(DasInstrumentBox, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DasInstrumentBox')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DasInstrumentBox', fromsubclass_=False, pretty_print=True):
        super(DasInstrumentBox, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SerialNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSerialNumber>%s</%sSerialNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SerialNumber), input_name='SerialNumber')), namespace_, eol_))
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, namespace_, name_='Parameter', pretty_print=pretty_print)
        if self.FacilityIdentifier is not None:
            self.FacilityIdentifier.export(outfile, level, namespace_, name_='FacilityIdentifier', pretty_print=pretty_print)
        if self.Instrument is not None:
            self.Instrument.export(outfile, level, namespace_, name_='Instrument', pretty_print=pretty_print)
        if self.FirmwareVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFirmwareVersion>%s</%sFirmwareVersion>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FirmwareVersion), input_name='FirmwareVersion')), namespace_, eol_))
        if self.PatchCord is not None:
            self.PatchCord.export(outfile, level, namespace_, name_='PatchCord', pretty_print=pretty_print)
        if self.InstrumentBoxDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstrumentBoxDescription>%s</%sInstrumentBoxDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.InstrumentBoxDescription), input_name='InstrumentBoxDescription')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DasInstrumentBox, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SerialNumber':
            SerialNumber_ = child_.text
            SerialNumber_ = self.gds_validate_string(SerialNumber_, node, 'SerialNumber')
            self.SerialNumber = SerialNumber_
            # validate type String64
            self.validate_String64(self.SerialNumber)
        elif nodeName_ == 'Parameter':
            obj_ = IndexedObject.factory()
            obj_.build(child_)
            self.Parameter.append(obj_)
            obj_.original_tagname_ = 'Parameter'
        elif nodeName_ == 'FacilityIdentifier':
            obj_ = FacilityIdentifier.factory()
            obj_.build(child_)
            self.FacilityIdentifier = obj_
            obj_.original_tagname_ = 'FacilityIdentifier'
        elif nodeName_ == 'Instrument':
            class_obj_ = self.get_class_obj_(child_, Instrument)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Instrument = obj_
            obj_.original_tagname_ = 'Instrument'
        elif nodeName_ == 'FirmwareVersion':
            FirmwareVersion_ = child_.text
            FirmwareVersion_ = self.gds_validate_string(FirmwareVersion_, node, 'FirmwareVersion')
            self.FirmwareVersion = FirmwareVersion_
            # validate type String64
            self.validate_String64(self.FirmwareVersion)
        elif nodeName_ == 'PatchCord':
            obj_ = DtsPatchCord.factory()
            obj_.build(child_)
            self.PatchCord = obj_
            obj_.original_tagname_ = 'PatchCord'
        elif nodeName_ == 'InstrumentBoxDescription':
            InstrumentBoxDescription_ = child_.text
            InstrumentBoxDescription_ = self.gds_validate_string(InstrumentBoxDescription_, node, 'InstrumentBoxDescription')
            self.InstrumentBoxDescription = InstrumentBoxDescription_
            # validate type String2000
            self.validate_String2000(self.InstrumentBoxDescription)
        super(DasInstrumentBox, self).buildChildren(child_, node, nodeName_, True)
# end class DasInstrumentBox


class DasExternalDatasetPart(ExternalDatasetPart):
    """Array of integer values provided explicitly by an HDF5 dataset. The
    null value must be explicitly provided in the NullValue
    attribute of this class."""
    subclass = None
    superclass = ExternalDatasetPart
    def __init__(self, Count=None, PathInExternalFile=None, StartIndex=None, EpcExternalPartReference=None, PartStartTime=None, PartEndTime=None):
        self.original_tagname_ = None
        super(DasExternalDatasetPart, self).__init__(Count, PathInExternalFile, StartIndex, EpcExternalPartReference, )
        self.PartStartTime = PartStartTime
        self.validate_TimeStamp(self.PartStartTime)
        self.PartEndTime = PartEndTime
        self.validate_TimeStamp(self.PartEndTime)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DasExternalDatasetPart)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DasExternalDatasetPart.subclass:
            return DasExternalDatasetPart.subclass(*args_, **kwargs_)
        else:
            return DasExternalDatasetPart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PartStartTime(self): return self.PartStartTime
    def set_PartStartTime(self, PartStartTime): self.PartStartTime = PartStartTime
    PartStartTimeProp = property(get_PartStartTime, set_PartStartTime)
    def get_PartEndTime(self): return self.PartEndTime
    def set_PartEndTime(self, PartEndTime): self.PartEndTime = PartEndTime
    PartEndTimeProp = property(get_PartEndTime, set_PartEndTime)
    def validate_TimeStamp(self, value):
        # Validate type TimeStamp, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TimeStamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TimeStamp_patterns_, ))
    validate_TimeStamp_patterns_ = [['^.+T.+[Z+\\-].*$']]
    def hasContent_(self):
        if (
            self.PartStartTime is not None or
            self.PartEndTime is not None or
            super(DasExternalDatasetPart, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DasExternalDatasetPart', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DasExternalDatasetPart')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DasExternalDatasetPart', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DasExternalDatasetPart'):
        super(DasExternalDatasetPart, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DasExternalDatasetPart')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DasExternalDatasetPart', fromsubclass_=False, pretty_print=True):
        super(DasExternalDatasetPart, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        namespace_='prodml:' # TODO fix in generateds?
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PartStartTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPartStartTime>%s</%sPartStartTime>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PartStartTime), input_name='PartStartTime')), namespace_, eol_))
        if self.PartEndTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPartEndTime>%s</%sPartEndTime>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PartEndTime), input_name='PartEndTime')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DasExternalDatasetPart, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PartStartTime':
            PartStartTime_ = child_.text
            PartStartTime_ = self.gds_validate_string(PartStartTime_, node, 'PartStartTime')
            self.PartStartTime = PartStartTime_
            # validate type TimeStamp
            self.validate_TimeStamp(self.PartStartTime)
        elif nodeName_ == 'PartEndTime':
            PartEndTime_ = child_.text
            PartEndTime_ = self.gds_validate_string(PartEndTime_, node, 'PartEndTime')
            self.PartEndTime = PartEndTime_
            # validate type TimeStamp
            self.validate_TimeStamp(self.PartEndTime)
        super(DasExternalDatasetPart, self).buildChildren(child_, node, nodeName_, True)
# end class DasExternalDatasetPart


class DasAcquisition(AbstractObject):
    """Contains metadata about the DAS acquisition common to the various
    types of data acquired during the acquisition, which includes
    DAS measurement instrument data, fiber optical path, time zone,
    and core acquisition settings like pulse rate and gauge length,
    measurement start time and whether or not this was a triggered
    measurement."""
    subclass = None
    superclass = AbstractObject
    def __init__(self, AcquisitionId=None, AcquisitionDescription=None, OpticalPath=None, DasInstrumentBox=None, FacilityId=None, VendorCode=None, PulseRate=None, PulseWidth=None, GaugeLength=None, GaugeLengthUnit=None, SpatialSamplingInterval=None, SpatialSamplingIntervalUnit=None, MinimumFrequency=None, MaximumFrequency=None, NumberOfLoci=None, StartLocusIndex=None, MeasurementStartTime=None, TriggeredMeasurement=None, PulseWidthUnit=None, Raw=None, Custom=None, Calibration=None, Processed=None):
        self.original_tagname_ = None
        super(DasAcquisition, self).__init__()
        self.AcquisitionId = AcquisitionId
        self.validate_UuidString(self.AcquisitionId)
        self.AcquisitionDescription = AcquisitionDescription
        self.validate_String2000(self.AcquisitionDescription)
        self.OpticalPath = OpticalPath
        self.DasInstrumentBox = DasInstrumentBox
        if FacilityId is None:
            self.FacilityId = []
        else:
            self.FacilityId = FacilityId
        self.VendorCode = VendorCode
        self.PulseRate = PulseRate
        self.PulseWidth = PulseWidth
        self.GaugeLength = GaugeLength
        self.GaugeLengthUnit = GaugeLengthUnit
        self.validate_String64(self.GaugeLengthUnit)
        self.SpatialSamplingInterval = SpatialSamplingInterval
        self.SpatialSamplingIntervalUnit = SpatialSamplingIntervalUnit
        self.validate_String64(self.SpatialSamplingIntervalUnit)
        self.MinimumFrequency = MinimumFrequency
        self.MaximumFrequency = MaximumFrequency
        self.NumberOfLoci = NumberOfLoci
        self.validate_NonNegativeLong(self.NumberOfLoci)
        self.StartLocusIndex = StartLocusIndex
        self.validate_NonNegativeLong(self.StartLocusIndex)
        self.MeasurementStartTime = MeasurementStartTime
        self.validate_TimeStamp(self.MeasurementStartTime)
        self.TriggeredMeasurement = TriggeredMeasurement
        self.PulseWidthUnit = PulseWidthUnit
        self.validate_String64(self.PulseWidthUnit)
        if Raw is None:
            self.Raw = []
        else:
            self.Raw = Raw
        self.Custom = Custom
        if Calibration is None:
            self.Calibration = []
        else:
            self.Calibration = Calibration
        self.Processed = Processed
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DasAcquisition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DasAcquisition.subclass:
            return DasAcquisition.subclass(*args_, **kwargs_)
        else:
            return DasAcquisition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AcquisitionId(self): return self.AcquisitionId
    def set_AcquisitionId(self, AcquisitionId): self.AcquisitionId = AcquisitionId
    AcquisitionIdProp = property(get_AcquisitionId, set_AcquisitionId)
    def get_AcquisitionDescription(self): return self.AcquisitionDescription
    def set_AcquisitionDescription(self, AcquisitionDescription): self.AcquisitionDescription = AcquisitionDescription
    AcquisitionDescriptionProp = property(get_AcquisitionDescription, set_AcquisitionDescription)
    def get_OpticalPath(self): return self.OpticalPath
    def set_OpticalPath(self, OpticalPath): self.OpticalPath = OpticalPath
    OpticalPathProp = property(get_OpticalPath, set_OpticalPath)
    def get_DasInstrumentBox(self): return self.DasInstrumentBox
    def set_DasInstrumentBox(self, DasInstrumentBox): self.DasInstrumentBox = DasInstrumentBox
    DasInstrumentBoxProp = property(get_DasInstrumentBox, set_DasInstrumentBox)
    def get_FacilityId(self): return self.FacilityId
    def set_FacilityId(self, FacilityId): self.FacilityId = FacilityId
    def add_FacilityId(self, value): self.FacilityId.append(value)
    def insert_FacilityId_at(self, index, value): self.FacilityId.insert(index, value)
    def replace_FacilityId_at(self, index, value): self.FacilityId[index] = value
    FacilityIdProp = property(get_FacilityId, set_FacilityId)
    def get_VendorCode(self): return self.VendorCode
    def set_VendorCode(self, VendorCode): self.VendorCode = VendorCode
    VendorCodeProp = property(get_VendorCode, set_VendorCode)
    def get_PulseRate(self): return self.PulseRate
    def set_PulseRate(self, PulseRate): self.PulseRate = PulseRate
    PulseRateProp = property(get_PulseRate, set_PulseRate)
    def get_PulseWidth(self): return self.PulseWidth
    def set_PulseWidth(self, PulseWidth): self.PulseWidth = PulseWidth
    PulseWidthProp = property(get_PulseWidth, set_PulseWidth)
    def get_GaugeLength(self): return self.GaugeLength
    def set_GaugeLength(self, GaugeLength): self.GaugeLength = GaugeLength
    GaugeLengthProp = property(get_GaugeLength, set_GaugeLength)
    def get_GaugeLengthUnit(self): return self.GaugeLengthUnit
    def set_GaugeLengthUnit(self, GaugeLengthUnit): self.GaugeLengthUnit = GaugeLengthUnit
    GaugeLengthUnitProp = property(get_GaugeLengthUnit, set_GaugeLengthUnit)
    def get_SpatialSamplingInterval(self): return self.SpatialSamplingInterval
    def set_SpatialSamplingInterval(self, SpatialSamplingInterval): self.SpatialSamplingInterval = SpatialSamplingInterval
    SpatialSamplingIntervalProp = property(get_SpatialSamplingInterval, set_SpatialSamplingInterval)
    def get_SpatialSamplingIntervalUnit(self): return self.SpatialSamplingIntervalUnit
    def set_SpatialSamplingIntervalUnit(self, SpatialSamplingIntervalUnit): self.SpatialSamplingIntervalUnit = SpatialSamplingIntervalUnit
    SpatialSamplingIntervalUnitProp = property(get_SpatialSamplingIntervalUnit, set_SpatialSamplingIntervalUnit)
    def get_MinimumFrequency(self): return self.MinimumFrequency
    def set_MinimumFrequency(self, MinimumFrequency): self.MinimumFrequency = MinimumFrequency
    MinimumFrequencyProp = property(get_MinimumFrequency, set_MinimumFrequency)
    def get_MaximumFrequency(self): return self.MaximumFrequency
    def set_MaximumFrequency(self, MaximumFrequency): self.MaximumFrequency = MaximumFrequency
    MaximumFrequencyProp = property(get_MaximumFrequency, set_MaximumFrequency)
    def get_NumberOfLoci(self): return self.NumberOfLoci
    def set_NumberOfLoci(self, NumberOfLoci): self.NumberOfLoci = NumberOfLoci
    NumberOfLociProp = property(get_NumberOfLoci, set_NumberOfLoci)
    def get_StartLocusIndex(self): return self.StartLocusIndex
    def set_StartLocusIndex(self, StartLocusIndex): self.StartLocusIndex = StartLocusIndex
    StartLocusIndexProp = property(get_StartLocusIndex, set_StartLocusIndex)
    def get_MeasurementStartTime(self): return self.MeasurementStartTime
    def set_MeasurementStartTime(self, MeasurementStartTime): self.MeasurementStartTime = MeasurementStartTime
    MeasurementStartTimeProp = property(get_MeasurementStartTime, set_MeasurementStartTime)
    def get_TriggeredMeasurement(self): return self.TriggeredMeasurement
    def set_TriggeredMeasurement(self, TriggeredMeasurement): self.TriggeredMeasurement = TriggeredMeasurement
    TriggeredMeasurementProp = property(get_TriggeredMeasurement, set_TriggeredMeasurement)
    def get_PulseWidthUnit(self): return self.PulseWidthUnit
    def set_PulseWidthUnit(self, PulseWidthUnit): self.PulseWidthUnit = PulseWidthUnit
    PulseWidthUnitProp = property(get_PulseWidthUnit, set_PulseWidthUnit)
    def get_Raw(self): return self.Raw
    def set_Raw(self, Raw): self.Raw = Raw
    def add_Raw(self, value): self.Raw.append(value)
    def insert_Raw_at(self, index, value): self.Raw.insert(index, value)
    def replace_Raw_at(self, index, value): self.Raw[index] = value
    RawProp = property(get_Raw, set_Raw)
    def get_Custom(self): return self.Custom
    def set_Custom(self, Custom): self.Custom = Custom
    CustomProp = property(get_Custom, set_Custom)
    def get_Calibration(self): return self.Calibration
    def set_Calibration(self, Calibration): self.Calibration = Calibration
    def add_Calibration(self, value): self.Calibration.append(value)
    def insert_Calibration_at(self, index, value): self.Calibration.insert(index, value)
    def replace_Calibration_at(self, index, value): self.Calibration[index] = value
    CalibrationProp = property(get_Calibration, set_Calibration)
    def get_Processed(self): return self.Processed
    def set_Processed(self, Processed): self.Processed = Processed
    ProcessedProp = property(get_Processed, set_Processed)
    def validate_UuidString(self, value):
        # Validate type UuidString, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_UuidString_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_UuidString_patterns_, ))
    validate_UuidString_patterns_ = [['^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$']]
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def validate_String64(self, value):
        # Validate type String64, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String64' % {"value" : value} )
    def validate_NonNegativeLong(self, value):
        # Validate type NonNegativeLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeLong' % {"value" : value} )
    def validate_TimeStamp(self, value):
        # Validate type TimeStamp, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TimeStamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TimeStamp_patterns_, ))
    validate_TimeStamp_patterns_ = [['^.+T.+[Z+\\-].*$']]
    def hasContent_(self):
        if (
            self.AcquisitionId is not None or
            self.AcquisitionDescription is not None or
            self.OpticalPath is not None or
            self.DasInstrumentBox is not None or
            self.FacilityId or
            self.VendorCode is not None or
            self.PulseRate is not None or
            self.PulseWidth is not None or
            self.GaugeLength is not None or
            self.GaugeLengthUnit is not None or
            self.SpatialSamplingInterval is not None or
            self.SpatialSamplingIntervalUnit is not None or
            self.MinimumFrequency is not None or
            self.MaximumFrequency is not None or
            self.NumberOfLoci is not None or
            self.StartLocusIndex is not None or
            self.MeasurementStartTime is not None or
            self.TriggeredMeasurement is not None or
            self.PulseWidthUnit is not None or
            self.Raw or
            self.Custom is not None or
            self.Calibration or
            self.Processed is not None or
            super(DasAcquisition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DasAcquisition', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DasAcquisition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DasAcquisition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DasAcquisition'):
        super(DasAcquisition, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DasAcquisition')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DasAcquisition', fromsubclass_=False, pretty_print=True):
        super(DasAcquisition, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AcquisitionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAcquisitionId>%s</%sAcquisitionId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AcquisitionId), input_name='AcquisitionId')), namespace_, eol_))
        if self.AcquisitionDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAcquisitionDescription>%s</%sAcquisitionDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AcquisitionDescription), input_name='AcquisitionDescription')), namespace_, eol_))
        if self.OpticalPath is not None:
            self.OpticalPath.export(outfile, level, namespace_, name_='OpticalPath', pretty_print=pretty_print)
        if self.DasInstrumentBox is not None:
            self.DasInstrumentBox.export(outfile, level, namespace_, name_='DasInstrumentBox', pretty_print=pretty_print)
        for FacilityId_ in self.FacilityId:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFacilityId>%s</%sFacilityId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(FacilityId_), input_name='FacilityId')), namespace_, eol_))
        if self.VendorCode is not None:
            self.VendorCode.export(outfile, level, namespace_, name_='VendorCode', pretty_print=pretty_print)
        if self.PulseRate is not None:
            self.PulseRate.export(outfile, level, namespace_, name_='PulseRate', pretty_print=pretty_print)
        if self.PulseWidth is not None:
            self.PulseWidth.export(outfile, level, namespace_, name_='PulseWidth', pretty_print=pretty_print)
        if self.GaugeLength is not None:
            self.GaugeLength.export(outfile, level, namespace_, name_='GaugeLength', pretty_print=pretty_print)
        if self.GaugeLengthUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGaugeLengthUnit>%s</%sGaugeLengthUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.GaugeLengthUnit), input_name='GaugeLengthUnit')), namespace_, eol_))
        if self.SpatialSamplingInterval is not None:
            self.SpatialSamplingInterval.export(outfile, level, namespace_, name_='SpatialSamplingInterval', pretty_print=pretty_print)
        if self.SpatialSamplingIntervalUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpatialSamplingIntervalUnit>%s</%sSpatialSamplingIntervalUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SpatialSamplingIntervalUnit), input_name='SpatialSamplingIntervalUnit')), namespace_, eol_))
        if self.MinimumFrequency is not None:
            self.MinimumFrequency.export(outfile, level, namespace_, name_='MinimumFrequency', pretty_print=pretty_print)
        if self.MaximumFrequency is not None:
            self.MaximumFrequency.export(outfile, level, namespace_, name_='MaximumFrequency', pretty_print=pretty_print)
        if self.NumberOfLoci is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberOfLoci>%s</%sNumberOfLoci>%s' % (namespace_, self.gds_format_integer(self.NumberOfLoci, input_name='NumberOfLoci'), namespace_, eol_))
        if self.StartLocusIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartLocusIndex>%s</%sStartLocusIndex>%s' % (namespace_, self.gds_format_integer(self.StartLocusIndex, input_name='StartLocusIndex'), namespace_, eol_))
        if self.MeasurementStartTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasurementStartTime>%s</%sMeasurementStartTime>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MeasurementStartTime), input_name='MeasurementStartTime')), namespace_, eol_))
        if self.TriggeredMeasurement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTriggeredMeasurement>%s</%sTriggeredMeasurement>%s' % (namespace_, self.gds_format_boolean(self.TriggeredMeasurement, input_name='TriggeredMeasurement'), namespace_, eol_))
        if self.PulseWidthUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPulseWidthUnit>%s</%sPulseWidthUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PulseWidthUnit), input_name='PulseWidthUnit')), namespace_, eol_))
        for Raw_ in self.Raw:
            Raw_.export(outfile, level, namespace_, name_='Raw', pretty_print=pretty_print)
        if self.Custom is not None:
            self.Custom.export(outfile, level, namespace_, name_='Custom', pretty_print=pretty_print)
        for Calibration_ in self.Calibration:
            Calibration_.export(outfile, level, namespace_, name_='Calibration', pretty_print=pretty_print)
        if self.Processed is not None:
            self.Processed.export(outfile, level, namespace_, name_='Processed', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DasAcquisition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AcquisitionId':
            AcquisitionId_ = child_.text
            AcquisitionId_ = self.gds_validate_string(AcquisitionId_, node, 'AcquisitionId')
            self.AcquisitionId = AcquisitionId_
            # validate type UuidString
            self.validate_UuidString(self.AcquisitionId)
        elif nodeName_ == 'AcquisitionDescription':
            AcquisitionDescription_ = child_.text
            AcquisitionDescription_ = self.gds_validate_string(AcquisitionDescription_, node, 'AcquisitionDescription')
            self.AcquisitionDescription = AcquisitionDescription_
            # validate type String2000
            self.validate_String2000(self.AcquisitionDescription)
        elif nodeName_ == 'OpticalPath':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.OpticalPath = obj_
            obj_.original_tagname_ = 'OpticalPath'
        elif nodeName_ == 'DasInstrumentBox':
            obj_ = DataObjectReference.factory()
            obj_.build(child_)
            self.DasInstrumentBox = obj_
            obj_.original_tagname_ = 'DasInstrumentBox'
        elif nodeName_ == 'FacilityId':
            FacilityId_ = child_.text
            FacilityId_ = self.gds_validate_string(FacilityId_, node, 'FacilityId')
            self.FacilityId.append(FacilityId_)
            # validate type String64
            self.validate_String64(self.FacilityId[-1])
        elif nodeName_ == 'VendorCode':
            obj_ = BusinessAssociate.factory()
            obj_.build(child_)
            self.VendorCode = obj_
            obj_.original_tagname_ = 'VendorCode'
        elif nodeName_ == 'PulseRate':
            obj_ = FrequencyMeasure.factory()
            obj_.build(child_)
            self.PulseRate = obj_
            obj_.original_tagname_ = 'PulseRate'
        elif nodeName_ == 'PulseWidth':
            obj_ = TimeMeasure.factory()
            obj_.build(child_)
            self.PulseWidth = obj_
            obj_.original_tagname_ = 'PulseWidth'
        elif nodeName_ == 'GaugeLength':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.GaugeLength = obj_
            obj_.original_tagname_ = 'GaugeLength'
        elif nodeName_ == 'GaugeLengthUnit':
            GaugeLengthUnit_ = child_.text
            GaugeLengthUnit_ = self.gds_validate_string(GaugeLengthUnit_, node, 'GaugeLengthUnit')
            self.GaugeLengthUnit = GaugeLengthUnit_
            # validate type String64
            self.validate_String64(self.GaugeLengthUnit)
        elif nodeName_ == 'SpatialSamplingInterval':
            obj_ = LengthMeasure.factory()
            obj_.build(child_)
            self.SpatialSamplingInterval = obj_
            obj_.original_tagname_ = 'SpatialSamplingInterval'
        elif nodeName_ == 'SpatialSamplingIntervalUnit':
            SpatialSamplingIntervalUnit_ = child_.text
            SpatialSamplingIntervalUnit_ = self.gds_validate_string(SpatialSamplingIntervalUnit_, node, 'SpatialSamplingIntervalUnit')
            self.SpatialSamplingIntervalUnit = SpatialSamplingIntervalUnit_
            # validate type String64
            self.validate_String64(self.SpatialSamplingIntervalUnit)
        elif nodeName_ == 'MinimumFrequency':
            obj_ = FrequencyMeasure.factory()
            obj_.build(child_)
            self.MinimumFrequency = obj_
            obj_.original_tagname_ = 'MinimumFrequency'
        elif nodeName_ == 'MaximumFrequency':
            obj_ = FrequencyMeasure.factory()
            obj_.build(child_)
            self.MaximumFrequency = obj_
            obj_.original_tagname_ = 'MaximumFrequency'
        elif nodeName_ == 'NumberOfLoci':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfLoci')
            self.NumberOfLoci = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.NumberOfLoci)
        elif nodeName_ == 'StartLocusIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StartLocusIndex')
            self.StartLocusIndex = ival_
            # validate type NonNegativeLong
            self.validate_NonNegativeLong(self.StartLocusIndex)
        elif nodeName_ == 'MeasurementStartTime':
            MeasurementStartTime_ = child_.text
            MeasurementStartTime_ = self.gds_validate_string(MeasurementStartTime_, node, 'MeasurementStartTime')
            self.MeasurementStartTime = MeasurementStartTime_
            # validate type TimeStamp
            self.validate_TimeStamp(self.MeasurementStartTime)
        elif nodeName_ == 'TriggeredMeasurement':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'TriggeredMeasurement')
            self.TriggeredMeasurement = ival_
        elif nodeName_ == 'PulseWidthUnit':
            PulseWidthUnit_ = child_.text
            PulseWidthUnit_ = self.gds_validate_string(PulseWidthUnit_, node, 'PulseWidthUnit')
            self.PulseWidthUnit = PulseWidthUnit_
            # validate type String64
            self.validate_String64(self.PulseWidthUnit)
        elif nodeName_ == 'Raw':
            obj_ = DasRaw.factory()
            obj_.build(child_)
            self.Raw.append(obj_)
            obj_.original_tagname_ = 'Raw'
        elif nodeName_ == 'Custom':
            obj_ = DasCustom.factory()
            obj_.build(child_)
            self.Custom = obj_
            obj_.original_tagname_ = 'Custom'
        elif nodeName_ == 'Calibration':
            obj_ = DasCalibration.factory()
            obj_.build(child_)
            self.Calibration.append(obj_)
            obj_.original_tagname_ = 'Calibration'
        elif nodeName_ == 'Processed':
            obj_ = DasProcessed.factory()
            obj_.build(child_)
            self.Processed = obj_
            obj_.original_tagname_ = 'Processed'
        super(DasAcquisition, self).buildChildren(child_, node, nodeName_, True)
# end class DasAcquisition


class VerticalCRSType(AbstractCRSType):
    subclass = None
    superclass = AbstractCRSType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, verticalCS=None, verticalDatum=None):
        self.original_tagname_ = None
        super(VerticalCRSType, self).__init__(id, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, )
        self.verticalCS = verticalCS
        self.verticalDatum = verticalDatum
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalCRSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalCRSType.subclass:
            return VerticalCRSType.subclass(*args_, **kwargs_)
        else:
            return VerticalCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_verticalCS(self): return self.verticalCS
    def set_verticalCS(self, verticalCS): self.verticalCS = verticalCS
    verticalCSProp = property(get_verticalCS, set_verticalCS)
    def get_verticalDatum(self): return self.verticalDatum
    def set_verticalDatum(self, verticalDatum): self.verticalDatum = verticalDatum
    verticalDatumProp = property(get_verticalDatum, set_verticalDatum)
    def hasContent_(self):
        if (
            self.verticalCS is not None or
            self.verticalDatum is not None or
            super(VerticalCRSType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VerticalCRSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalCRSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VerticalCRSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VerticalCRSType'):
        super(VerticalCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalCRSType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VerticalCRSType', fromsubclass_=False, pretty_print=True):
        super(VerticalCRSType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.verticalCS is not None:
            self.verticalCS.export(outfile, level, namespace_='gml:', name_='verticalCS', pretty_print=pretty_print)
        if self.verticalDatum is not None:
            self.verticalDatum.export(outfile, level, namespace_='gml:', name_='verticalDatum', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VerticalCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'verticalCS':
            obj_ = VerticalCSPropertyType.factory()
            obj_.build(child_)
            self.verticalCS = obj_
            obj_.original_tagname_ = 'verticalCS'
        elif nodeName_ == 'verticalDatum':
            obj_ = VerticalDatumPropertyType.factory()
            obj_.build(child_)
            self.verticalDatum = obj_
            obj_.original_tagname_ = 'verticalDatum'
        super(VerticalCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class VerticalCRSType


class AbstractCoordinateOperationType(IdentifiedObjectType):
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, operationVersion=None, coordinateOperationAccuracy=None, sourceCRS=None, targetCRS=None):
        self.original_tagname_ = None
        super(AbstractCoordinateOperationType, self).__init__(id, description, descriptionReference, identifier, name, remarks, )
        self.domainOfValidity = domainOfValidity
        if scope is None:
            self.scope = []
        else:
            self.scope = scope
        self.operationVersion = operationVersion
        if coordinateOperationAccuracy is None:
            self.coordinateOperationAccuracy = []
        else:
            self.coordinateOperationAccuracy = coordinateOperationAccuracy
        self.sourceCRS = sourceCRS
        self.targetCRS = targetCRS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractCoordinateOperationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractCoordinateOperationType.subclass:
            return AbstractCoordinateOperationType.subclass(*args_, **kwargs_)
        else:
            return AbstractCoordinateOperationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domainOfValidity(self): return self.domainOfValidity
    def set_domainOfValidity(self, domainOfValidity): self.domainOfValidity = domainOfValidity
    domainOfValidityProp = property(get_domainOfValidity, set_domainOfValidity)
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def add_scope(self, value): self.scope.append(value)
    def insert_scope_at(self, index, value): self.scope.insert(index, value)
    def replace_scope_at(self, index, value): self.scope[index] = value
    scopeProp = property(get_scope, set_scope)
    def get_operationVersion(self): return self.operationVersion
    def set_operationVersion(self, operationVersion): self.operationVersion = operationVersion
    operationVersionProp = property(get_operationVersion, set_operationVersion)
    def get_coordinateOperationAccuracy(self): return self.coordinateOperationAccuracy
    def set_coordinateOperationAccuracy(self, coordinateOperationAccuracy): self.coordinateOperationAccuracy = coordinateOperationAccuracy
    def add_coordinateOperationAccuracy(self, value): self.coordinateOperationAccuracy.append(value)
    def insert_coordinateOperationAccuracy_at(self, index, value): self.coordinateOperationAccuracy.insert(index, value)
    def replace_coordinateOperationAccuracy_at(self, index, value): self.coordinateOperationAccuracy[index] = value
    coordinateOperationAccuracyProp = property(get_coordinateOperationAccuracy, set_coordinateOperationAccuracy)
    def get_sourceCRS(self): return self.sourceCRS
    def set_sourceCRS(self, sourceCRS): self.sourceCRS = sourceCRS
    sourceCRSProp = property(get_sourceCRS, set_sourceCRS)
    def get_targetCRS(self): return self.targetCRS
    def set_targetCRS(self, targetCRS): self.targetCRS = targetCRS
    targetCRSProp = property(get_targetCRS, set_targetCRS)
    def hasContent_(self):
        if (
            self.domainOfValidity is not None or
            self.scope or
            self.operationVersion is not None or
            self.coordinateOperationAccuracy or
            self.sourceCRS is not None or
            self.targetCRS is not None or
            super(AbstractCoordinateOperationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractCoordinateOperationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCoordinateOperationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractCoordinateOperationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractCoordinateOperationType'):
        super(AbstractCoordinateOperationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCoordinateOperationType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractCoordinateOperationType', fromsubclass_=False, pretty_print=True):
        super(AbstractCoordinateOperationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.domainOfValidity is not None:
            self.domainOfValidity.export(outfile, level, namespace_='gml:', name_='domainOfValidity', pretty_print=pretty_print)
        for scope_ in self.scope:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscope>%s</%sscope>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(scope_), input_name='scope')), namespace_, eol_))
        if self.operationVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soperationVersion>%s</%soperationVersion>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.operationVersion), input_name='operationVersion')), namespace_, eol_))
        for coordinateOperationAccuracy_ in self.coordinateOperationAccuracy:
            coordinateOperationAccuracy_.export(outfile, level, namespace_='gml:', name_='coordinateOperationAccuracy', pretty_print=pretty_print)
        if self.sourceCRS is not None:
            self.sourceCRS.export(outfile, level, namespace_='gml:', name_='sourceCRS', pretty_print=pretty_print)
        if self.targetCRS is not None:
            self.targetCRS.export(outfile, level, namespace_='gml:', name_='targetCRS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractCoordinateOperationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domainOfValidity':
            obj_ = domainOfValidity.factory()
            obj_.build(child_)
            self.domainOfValidity = obj_
            obj_.original_tagname_ = 'domainOfValidity'
        elif nodeName_ == 'scope':
            scope_ = child_.text
            scope_ = self.gds_validate_string(scope_, node, 'scope')
            self.scope.append(scope_)
        elif nodeName_ == 'operationVersion':
            operationVersion_ = child_.text
            operationVersion_ = self.gds_validate_string(operationVersion_, node, 'operationVersion')
            self.operationVersion = operationVersion_
        elif nodeName_ == 'coordinateOperationAccuracy':
            obj_ = coordinateOperationAccuracy.factory()
            obj_.build(child_)
            self.coordinateOperationAccuracy.append(obj_)
            obj_.original_tagname_ = 'coordinateOperationAccuracy'
        elif nodeName_ == 'sourceCRS':
            obj_ = CRSPropertyType.factory()
            obj_.build(child_)
            self.sourceCRS = obj_
            obj_.original_tagname_ = 'sourceCRS'
        elif nodeName_ == 'targetCRS':
            obj_ = CRSPropertyType.factory()
            obj_.build(child_)
            self.targetCRS = obj_
            obj_.original_tagname_ = 'targetCRS'
        super(AbstractCoordinateOperationType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractCoordinateOperationType


class AbstractGeneralDerivedCRSType(AbstractCRSType):
    subclass = None
    superclass = AbstractCRSType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, conversion=None, extensiontype_=None):
        self.original_tagname_ = None
        super(AbstractGeneralDerivedCRSType, self).__init__(id, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, extensiontype_, )
        self.conversion = conversion
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractGeneralDerivedCRSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractGeneralDerivedCRSType.subclass:
            return AbstractGeneralDerivedCRSType.subclass(*args_, **kwargs_)
        else:
            return AbstractGeneralDerivedCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_conversion(self): return self.conversion
    def set_conversion(self, conversion): self.conversion = conversion
    conversionProp = property(get_conversion, set_conversion)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.conversion is not None or
            super(AbstractGeneralDerivedCRSType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractGeneralDerivedCRSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeneralDerivedCRSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractGeneralDerivedCRSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractGeneralDerivedCRSType'):
        super(AbstractGeneralDerivedCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeneralDerivedCRSType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractGeneralDerivedCRSType', fromsubclass_=False, pretty_print=True):
        super(AbstractGeneralDerivedCRSType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.conversion is not None:
            self.conversion.export(outfile, level, namespace_='gml:', name_='conversion', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractGeneralDerivedCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'conversion':
            obj_ = GeneralConversionPropertyType.factory()
            obj_.build(child_)
            self.conversion = obj_
            obj_.original_tagname_ = 'conversion'
        super(AbstractGeneralDerivedCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractGeneralDerivedCRSType


class ProjectedCRSType(AbstractGeneralDerivedCRSType):
    subclass = None
    superclass = AbstractGeneralDerivedCRSType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, conversion=None, baseGeodeticCRS=None, cartesianCS=None):
        self.original_tagname_ = None
        super(ProjectedCRSType, self).__init__(id, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, conversion, )
        self.baseGeodeticCRS = baseGeodeticCRS
        self.cartesianCS = cartesianCS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProjectedCRSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProjectedCRSType.subclass:
            return ProjectedCRSType.subclass(*args_, **kwargs_)
        else:
            return ProjectedCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_baseGeodeticCRS(self): return self.baseGeodeticCRS
    def set_baseGeodeticCRS(self, baseGeodeticCRS): self.baseGeodeticCRS = baseGeodeticCRS
    baseGeodeticCRSProp = property(get_baseGeodeticCRS, set_baseGeodeticCRS)
    def get_cartesianCS(self): return self.cartesianCS
    def set_cartesianCS(self, cartesianCS): self.cartesianCS = cartesianCS
    cartesianCSProp = property(get_cartesianCS, set_cartesianCS)
    def hasContent_(self):
        if (
            self.baseGeodeticCRS is not None or
            self.cartesianCS is not None or
            super(ProjectedCRSType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='ProjectedCRSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedCRSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='ProjectedCRSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='ProjectedCRSType'):
        super(ProjectedCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedCRSType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='ProjectedCRSType', fromsubclass_=False, pretty_print=True):
        super(ProjectedCRSType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.baseGeodeticCRS is not None:
            self.baseGeodeticCRS.export(outfile, level, namespace_='gml:', name_='baseGeodeticCRS', pretty_print=pretty_print)
        if self.cartesianCS is not None:
            self.cartesianCS.export(outfile, level, namespace_='gml:', name_='cartesianCS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ProjectedCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'baseGeodeticCRS':
            obj_ = GeodeticCRSPropertyType.factory()
            obj_.build(child_)
            self.baseGeodeticCRS = obj_
            obj_.original_tagname_ = 'baseGeodeticCRS'
        elif nodeName_ == 'cartesianCS':
            obj_ = CartesianCSPropertyType.factory()
            obj_.build(child_)
            self.cartesianCS = obj_
            obj_.original_tagname_ = 'cartesianCS'
        super(ProjectedCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class ProjectedCRSType


class EllipsoidType(IdentifiedObjectType):
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, semiMajorAxis=None, secondDefiningParameter=None):
        self.original_tagname_ = None
        super(EllipsoidType, self).__init__(id, description, descriptionReference, identifier, name, remarks, )
        self.semiMajorAxis = semiMajorAxis
        self.secondDefiningParameter = secondDefiningParameter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EllipsoidType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EllipsoidType.subclass:
            return EllipsoidType.subclass(*args_, **kwargs_)
        else:
            return EllipsoidType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_semiMajorAxis(self): return self.semiMajorAxis
    def set_semiMajorAxis(self, semiMajorAxis): self.semiMajorAxis = semiMajorAxis
    semiMajorAxisProp = property(get_semiMajorAxis, set_semiMajorAxis)
    def get_secondDefiningParameter(self): return self.secondDefiningParameter
    def set_secondDefiningParameter(self, secondDefiningParameter): self.secondDefiningParameter = secondDefiningParameter
    secondDefiningParameterProp = property(get_secondDefiningParameter, set_secondDefiningParameter)
    def hasContent_(self):
        if (
            self.semiMajorAxis is not None or
            self.secondDefiningParameter is not None or
            super(EllipsoidType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EllipsoidType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EllipsoidType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EllipsoidType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EllipsoidType'):
        super(EllipsoidType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EllipsoidType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EllipsoidType', fromsubclass_=False, pretty_print=True):
        super(EllipsoidType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.semiMajorAxis is not None:
            self.semiMajorAxis.export(outfile, level, namespace_='gml:', name_='semiMajorAxis', pretty_print=pretty_print)
        if self.secondDefiningParameter is not None:
            self.secondDefiningParameter.export(outfile, level, namespace_='gml:', name_='secondDefiningParameter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EllipsoidType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'semiMajorAxis':
            class_obj_ = self.get_class_obj_(child_, MeasureType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.semiMajorAxis = obj_
            obj_.original_tagname_ = 'semiMajorAxis'
        elif nodeName_ == 'secondDefiningParameter':
            obj_ = secondDefiningParameter.factory()
            obj_.build(child_)
            self.secondDefiningParameter = obj_
            obj_.original_tagname_ = 'secondDefiningParameter'
        super(EllipsoidType, self).buildChildren(child_, node, nodeName_, True)
# end class EllipsoidType


class PrimeMeridianType(IdentifiedObjectType):
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, greenwichLongitude=None):
        self.original_tagname_ = None
        super(PrimeMeridianType, self).__init__(id, description, descriptionReference, identifier, name, remarks, )
        self.greenwichLongitude = greenwichLongitude
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrimeMeridianType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrimeMeridianType.subclass:
            return PrimeMeridianType.subclass(*args_, **kwargs_)
        else:
            return PrimeMeridianType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_greenwichLongitude(self): return self.greenwichLongitude
    def set_greenwichLongitude(self, greenwichLongitude): self.greenwichLongitude = greenwichLongitude
    greenwichLongitudeProp = property(get_greenwichLongitude, set_greenwichLongitude)
    def hasContent_(self):
        if (
            self.greenwichLongitude is not None or
            super(PrimeMeridianType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='PrimeMeridianType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrimeMeridianType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='PrimeMeridianType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='PrimeMeridianType'):
        super(PrimeMeridianType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PrimeMeridianType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='PrimeMeridianType', fromsubclass_=False, pretty_print=True):
        super(PrimeMeridianType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.greenwichLongitude is not None:
            self.greenwichLongitude.export(outfile, level, namespace_='gml:', name_='greenwichLongitude', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PrimeMeridianType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'greenwichLongitude':
            obj_ = AngleType.factory()
            obj_.build(child_)
            self.greenwichLongitude = obj_
            obj_.original_tagname_ = 'greenwichLongitude'
        super(PrimeMeridianType, self).buildChildren(child_, node, nodeName_, True)
# end class PrimeMeridianType


class AbstractDatumType(IdentifiedObjectType):
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, anchorDefinition=None, realizationEpoch=None, extensiontype_=None):
        self.original_tagname_ = None
        super(AbstractDatumType, self).__init__(id, description, descriptionReference, identifier, name, remarks, extensiontype_, )
        self.domainOfValidity = domainOfValidity
        if scope is None:
            self.scope = []
        else:
            self.scope = scope
        self.anchorDefinition = anchorDefinition
        self.realizationEpoch = realizationEpoch
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractDatumType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractDatumType.subclass:
            return AbstractDatumType.subclass(*args_, **kwargs_)
        else:
            return AbstractDatumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domainOfValidity(self): return self.domainOfValidity
    def set_domainOfValidity(self, domainOfValidity): self.domainOfValidity = domainOfValidity
    domainOfValidityProp = property(get_domainOfValidity, set_domainOfValidity)
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def add_scope(self, value): self.scope.append(value)
    def insert_scope_at(self, index, value): self.scope.insert(index, value)
    def replace_scope_at(self, index, value): self.scope[index] = value
    scopeProp = property(get_scope, set_scope)
    def get_anchorDefinition(self): return self.anchorDefinition
    def set_anchorDefinition(self, anchorDefinition): self.anchorDefinition = anchorDefinition
    anchorDefinitionProp = property(get_anchorDefinition, set_anchorDefinition)
    def get_realizationEpoch(self): return self.realizationEpoch
    def set_realizationEpoch(self, realizationEpoch): self.realizationEpoch = realizationEpoch
    realizationEpochProp = property(get_realizationEpoch, set_realizationEpoch)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.domainOfValidity is not None or
            self.scope or
            self.anchorDefinition is not None or
            self.realizationEpoch is not None or
            super(AbstractDatumType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractDatumType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDatumType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractDatumType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractDatumType'):
        super(AbstractDatumType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDatumType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractDatumType', fromsubclass_=False, pretty_print=True):
        super(AbstractDatumType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.domainOfValidity is not None:
            self.domainOfValidity.export(outfile, level, namespace_='gml:', name_='domainOfValidity', pretty_print=pretty_print)
        for scope_ in self.scope:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscope>%s</%sscope>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(scope_), input_name='scope')), namespace_, eol_))
        if self.anchorDefinition is not None:
            self.anchorDefinition.export(outfile, level, namespace_='gml:', name_='anchorDefinition', pretty_print=pretty_print)
        if self.realizationEpoch is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srealizationEpoch>%s</%srealizationEpoch>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.realizationEpoch), input_name='realizationEpoch')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractDatumType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domainOfValidity':
            obj_ = domainOfValidity.factory()
            obj_.build(child_)
            self.domainOfValidity = obj_
            obj_.original_tagname_ = 'domainOfValidity'
        elif nodeName_ == 'scope':
            scope_ = child_.text
            scope_ = self.gds_validate_string(scope_, node, 'scope')
            self.scope.append(scope_)
        elif nodeName_ == 'anchorDefinition':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.anchorDefinition = obj_
            obj_.original_tagname_ = 'anchorDefinition'
        elif nodeName_ == 'realizationEpoch':
            realizationEpoch_ = child_.text
            realizationEpoch_ = self.gds_validate_string(realizationEpoch_, node, 'realizationEpoch')
            self.realizationEpoch = realizationEpoch_
        super(AbstractDatumType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractDatumType


class GeodeticDatumType(AbstractDatumType):
    subclass = None
    superclass = AbstractDatumType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, anchorDefinition=None, realizationEpoch=None, primeMeridian=None, ellipsoid=None):
        self.original_tagname_ = None
        super(GeodeticDatumType, self).__init__(id, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, anchorDefinition, realizationEpoch, )
        self.primeMeridian = primeMeridian
        self.ellipsoid = ellipsoid
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeodeticDatumType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeodeticDatumType.subclass:
            return GeodeticDatumType.subclass(*args_, **kwargs_)
        else:
            return GeodeticDatumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_primeMeridian(self): return self.primeMeridian
    def set_primeMeridian(self, primeMeridian): self.primeMeridian = primeMeridian
    primeMeridianProp = property(get_primeMeridian, set_primeMeridian)
    def get_ellipsoid(self): return self.ellipsoid
    def set_ellipsoid(self, ellipsoid): self.ellipsoid = ellipsoid
    ellipsoidProp = property(get_ellipsoid, set_ellipsoid)
    def hasContent_(self):
        if (
            self.primeMeridian is not None or
            self.ellipsoid is not None or
            super(GeodeticDatumType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='GeodeticDatumType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticDatumType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='GeodeticDatumType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='GeodeticDatumType'):
        super(GeodeticDatumType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticDatumType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='GeodeticDatumType', fromsubclass_=False, pretty_print=True):
        super(GeodeticDatumType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.primeMeridian is not None:
            self.primeMeridian.export(outfile, level, namespace_='gml:', name_='primeMeridian', pretty_print=pretty_print)
        if self.ellipsoid is not None:
            self.ellipsoid.export(outfile, level, namespace_='gml:', name_='ellipsoid', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GeodeticDatumType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'primeMeridian':
            obj_ = PrimeMeridianPropertyType.factory()
            obj_.build(child_)
            self.primeMeridian = obj_
            obj_.original_tagname_ = 'primeMeridian'
        elif nodeName_ == 'ellipsoid':
            obj_ = EllipsoidPropertyType.factory()
            obj_.build(child_)
            self.ellipsoid = obj_
            obj_.original_tagname_ = 'ellipsoid'
        super(GeodeticDatumType, self).buildChildren(child_, node, nodeName_, True)
# end class GeodeticDatumType


class CoordinateSystemAxisType(IdentifiedObjectType):
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, axisAbbrev=None, axisDirection=None, minimumValue=None, maximumValue=None, rangeMeaning=None):
        self.original_tagname_ = None
        super(CoordinateSystemAxisType, self).__init__(id, description, descriptionReference, identifier, name, remarks, )
        self.axisAbbrev = axisAbbrev
        self.axisDirection = axisDirection
        self.minimumValue = minimumValue
        self.maximumValue = maximumValue
        self.rangeMeaning = rangeMeaning
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoordinateSystemAxisType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordinateSystemAxisType.subclass:
            return CoordinateSystemAxisType.subclass(*args_, **kwargs_)
        else:
            return CoordinateSystemAxisType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_axisAbbrev(self): return self.axisAbbrev
    def set_axisAbbrev(self, axisAbbrev): self.axisAbbrev = axisAbbrev
    axisAbbrevProp = property(get_axisAbbrev, set_axisAbbrev)
    def get_axisDirection(self): return self.axisDirection
    def set_axisDirection(self, axisDirection): self.axisDirection = axisDirection
    axisDirectionProp = property(get_axisDirection, set_axisDirection)
    def get_minimumValue(self): return self.minimumValue
    def set_minimumValue(self, minimumValue): self.minimumValue = minimumValue
    minimumValueProp = property(get_minimumValue, set_minimumValue)
    def get_maximumValue(self): return self.maximumValue
    def set_maximumValue(self, maximumValue): self.maximumValue = maximumValue
    maximumValueProp = property(get_maximumValue, set_maximumValue)
    def get_rangeMeaning(self): return self.rangeMeaning
    def set_rangeMeaning(self, rangeMeaning): self.rangeMeaning = rangeMeaning
    rangeMeaningProp = property(get_rangeMeaning, set_rangeMeaning)
    def hasContent_(self):
        if (
            self.axisAbbrev is not None or
            self.axisDirection is not None or
            self.minimumValue is not None or
            self.maximumValue is not None or
            self.rangeMeaning is not None or
            super(CoordinateSystemAxisType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CoordinateSystemAxisType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoordinateSystemAxisType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CoordinateSystemAxisType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CoordinateSystemAxisType'):
        super(CoordinateSystemAxisType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CoordinateSystemAxisType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CoordinateSystemAxisType', fromsubclass_=False, pretty_print=True):
        super(CoordinateSystemAxisType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.axisAbbrev is not None:
            self.axisAbbrev.export(outfile, level, namespace_='gml:', name_='axisAbbrev', pretty_print=pretty_print)
        if self.axisDirection is not None:
            self.axisDirection.export(outfile, level, namespace_='gml:', name_='axisDirection', pretty_print=pretty_print)
        if self.minimumValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumValue>%s</%sminimumValue>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.minimumValue), input_name='minimumValue')), namespace_, eol_))
        if self.maximumValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaximumValue>%s</%smaximumValue>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.maximumValue), input_name='maximumValue')), namespace_, eol_))
        if self.rangeMeaning is not None:
            self.rangeMeaning.export(outfile, level, namespace_='gml:', name_='rangeMeaning', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CoordinateSystemAxisType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'axisAbbrev':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.axisAbbrev = obj_
            obj_.original_tagname_ = 'axisAbbrev'
        elif nodeName_ == 'axisDirection':
            obj_ = CodeWithAuthorityType.factory()
            obj_.build(child_)
            self.axisDirection = obj_
            obj_.original_tagname_ = 'axisDirection'
        elif nodeName_ == 'minimumValue':
            minimumValue_ = child_.text
            minimumValue_ = self.gds_validate_string(minimumValue_, node, 'minimumValue')
            self.minimumValue = minimumValue_
        elif nodeName_ == 'maximumValue':
            maximumValue_ = child_.text
            maximumValue_ = self.gds_validate_string(maximumValue_, node, 'maximumValue')
            self.maximumValue = maximumValue_
        elif nodeName_ == 'rangeMeaning':
            obj_ = CodeWithAuthorityType.factory()
            obj_.build(child_)
            self.rangeMeaning = obj_
            obj_.original_tagname_ = 'rangeMeaning'
        super(CoordinateSystemAxisType, self).buildChildren(child_, node, nodeName_, True)
# end class CoordinateSystemAxisType


class AbstractCoordinateSystemType(IdentifiedObjectType):
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None, extensiontype_=None):
        self.original_tagname_ = None
        super(AbstractCoordinateSystemType, self).__init__(id, description, descriptionReference, identifier, name, remarks, extensiontype_, )
        self.aggregationType = _cast(None, aggregationType)
        if axis is None:
            self.axis = []
        else:
            self.axis = axis
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractCoordinateSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractCoordinateSystemType.subclass:
            return AbstractCoordinateSystemType.subclass(*args_, **kwargs_)
        else:
            return AbstractCoordinateSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_axis(self): return self.axis
    def set_axis(self, axis): self.axis = axis
    def add_axis(self, value): self.axis.append(value)
    def insert_axis_at(self, index, value): self.axis.insert(index, value)
    def replace_axis_at(self, index, value): self.axis[index] = value
    axisProp = property(get_axis, set_axis)
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    aggregationTypeProp = property(get_aggregationType, set_aggregationType)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.axis or
            super(AbstractCoordinateSystemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='AbstractCoordinateSystemType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCoordinateSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='AbstractCoordinateSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='AbstractCoordinateSystemType'):
        super(AbstractCoordinateSystemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCoordinateSystemType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.add('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='AbstractCoordinateSystemType', fromsubclass_=False, pretty_print=True):
        super(AbstractCoordinateSystemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for axis_ in self.axis:
            axis_.export(outfile, level, namespace_='gml:', name_='axis', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.add('aggregationType')
            self.aggregationType = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractCoordinateSystemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'axis':
            obj_ = CoordinateSystemAxisPropertyType.factory()
            obj_.build(child_)
            self.axis.append(obj_)
            obj_.original_tagname_ = 'axis'
        super(AbstractCoordinateSystemType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractCoordinateSystemType


class EllipsoidalCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        self.original_tagname_ = None
        super(EllipsoidalCSType, self).__init__(id, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EllipsoidalCSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EllipsoidalCSType.subclass:
            return EllipsoidalCSType.subclass(*args_, **kwargs_)
        else:
            return EllipsoidalCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(EllipsoidalCSType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='EllipsoidalCSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EllipsoidalCSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='EllipsoidalCSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='EllipsoidalCSType'):
        super(EllipsoidalCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EllipsoidalCSType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='EllipsoidalCSType', fromsubclass_=False, pretty_print=True):
        super(EllipsoidalCSType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EllipsoidalCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EllipsoidalCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EllipsoidalCSType


class StringExternalArray(AbstractStringArray):
    """Used to store explicit string values, i.e., values that are not
    double, boolean or integers. The datatype of the values will be
    identified by means of the HDF5 API."""
    subclass = None
    superclass = AbstractStringArray
    def __init__(self, Values=None):
        self.original_tagname_ = None
        super(StringExternalArray, self).__init__()
        self.Values = Values
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringExternalArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringExternalArray.subclass:
            return StringExternalArray.subclass(*args_, **kwargs_)
        else:
            return StringExternalArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Values(self): return self.Values
    def set_Values(self, Values): self.Values = Values
    ValuesProp = property(get_Values, set_Values)
    def hasContent_(self):
        if (
            self.Values is not None or
            super(StringExternalArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='StringExternalArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StringExternalArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='StringExternalArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='StringExternalArray'):
        super(StringExternalArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StringExternalArray')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='StringExternalArray', fromsubclass_=False, pretty_print=True):
        super(StringExternalArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Values is not None:
            self.Values.export(outfile, level, namespace_, name_='Values', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StringExternalArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Values':
            obj_ = ExternalDataset.factory()
            obj_.build(child_)
            self.Values = obj_
            obj_.original_tagname_ = 'Values'
        super(StringExternalArray, self).buildChildren(child_, node, nodeName_, True)
# end class StringExternalArray


class StringConstantArray(AbstractStringArray):
    """Represents an array of Boolean values where all values are
    identical. This an optimization for which an array of explicit
    Boolean values is not required."""
    subclass = None
    superclass = AbstractStringArray
    def __init__(self, Value=None, Count=None):
        self.original_tagname_ = None
        super(StringConstantArray, self).__init__()
        self.Value = Value
        self.validate_String2000(self.Value)
        self.Count = Count
        self.validate_PositiveLong(self.Count)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringConstantArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringConstantArray.subclass:
            return StringConstantArray.subclass(*args_, **kwargs_)
        else:
            return StringConstantArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    ValueProp = property(get_Value, set_Value)
    def get_Count(self): return self.Count
    def set_Count(self, Count): self.Count = Count
    CountProp = property(get_Count, set_Count)
    def validate_String2000(self, value):
        # Validate type String2000, a restriction on eml:AbstractString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String2000' % {"value" : value} )
    def validate_PositiveLong(self, value):
        # Validate type PositiveLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveLong' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Value is not None or
            self.Count is not None or
            super(StringConstantArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='StringConstantArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StringConstantArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='StringConstantArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='StringConstantArray'):
        super(StringConstantArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StringConstantArray')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='StringConstantArray', fromsubclass_=False, pretty_print=True):
        super(StringConstantArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), namespace_, eol_))
        if self.Count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCount>%s</%sCount>%s' % (namespace_, self.gds_format_integer(self.Count, input_name='Count'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StringConstantArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
            # validate type String2000
            self.validate_String2000(self.Value)
        elif nodeName_ == 'Count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Count')
            self.Count = ival_
            # validate type PositiveLong
            self.validate_PositiveLong(self.Count)
        super(StringConstantArray, self).buildChildren(child_, node, nodeName_, True)
# end class StringConstantArray


class IntegerRangeArray(AbstractIntegerArray):
    """Defines an array as a range of integers. The range is defined by an
    initial value and a count defining the size of the range."""
    subclass = None
    superclass = AbstractIntegerArray
    def __init__(self, Count=None, Value=None):
        self.original_tagname_ = None
        super(IntegerRangeArray, self).__init__()
        self.Count = Count
        self.validate_PositiveLong(self.Count)
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntegerRangeArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntegerRangeArray.subclass:
            return IntegerRangeArray.subclass(*args_, **kwargs_)
        else:
            return IntegerRangeArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Count(self): return self.Count
    def set_Count(self, Count): self.Count = Count
    CountProp = property(get_Count, set_Count)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    ValueProp = property(get_Value, set_Value)
    def validate_PositiveLong(self, value):
        # Validate type PositiveLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveLong' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Count is not None or
            self.Value is not None or
            super(IntegerRangeArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='IntegerRangeArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerRangeArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='IntegerRangeArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='IntegerRangeArray'):
        super(IntegerRangeArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerRangeArray')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='IntegerRangeArray', fromsubclass_=False, pretty_print=True):
        super(IntegerRangeArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCount>%s</%sCount>%s' % (namespace_, self.gds_format_integer(self.Count, input_name='Count'), namespace_, eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_integer(self.Value, input_name='Value'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IntegerRangeArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Count')
            self.Count = ival_
            # validate type PositiveLong
            self.validate_PositiveLong(self.Count)
        elif nodeName_ == 'Value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Value')
            self.Value = ival_
        super(IntegerRangeArray, self).buildChildren(child_, node, nodeName_, True)
# end class IntegerRangeArray


class IntegerLatticeArray(AbstractIntegerArray):
    """Represents an array of integers based on an origin and a multi-
    dimensional offset. The offset is based on a linearization of a
    multi-dimensional offset. If count(i) is the number of elements
    in the dimension i and offset(i) is the offset in the dimension
    i, then: globalOffsetInNDimension = startValue+ ni*offset(n) +
    n_1i*count(n)*offset(n-1) + .... +
    0i*count(n)*count(n-1)*....count(1)*offset(0)"""
    subclass = None
    superclass = AbstractIntegerArray
    def __init__(self, StartValue=None, Offset=None):
        self.original_tagname_ = None
        super(IntegerLatticeArray, self).__init__()
        self.StartValue = StartValue
        if Offset is None:
            self.Offset = []
        else:
            self.Offset = Offset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntegerLatticeArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntegerLatticeArray.subclass:
            return IntegerLatticeArray.subclass(*args_, **kwargs_)
        else:
            return IntegerLatticeArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartValue(self): return self.StartValue
    def set_StartValue(self, StartValue): self.StartValue = StartValue
    StartValueProp = property(get_StartValue, set_StartValue)
    def get_Offset(self): return self.Offset
    def set_Offset(self, Offset): self.Offset = Offset
    def add_Offset(self, value): self.Offset.append(value)
    def insert_Offset_at(self, index, value): self.Offset.insert(index, value)
    def replace_Offset_at(self, index, value): self.Offset[index] = value
    OffsetProp = property(get_Offset, set_Offset)
    def hasContent_(self):
        if (
            self.StartValue is not None or
            self.Offset or
            super(IntegerLatticeArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='IntegerLatticeArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerLatticeArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='IntegerLatticeArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='IntegerLatticeArray'):
        super(IntegerLatticeArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerLatticeArray')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='IntegerLatticeArray', fromsubclass_=False, pretty_print=True):
        super(IntegerLatticeArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StartValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartValue>%s</%sStartValue>%s' % (namespace_, self.gds_format_integer(self.StartValue, input_name='StartValue'), namespace_, eol_))
        for Offset_ in self.Offset:
            Offset_.export(outfile, level, namespace_, name_='Offset', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IntegerLatticeArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartValue':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StartValue')
            self.StartValue = ival_
        elif nodeName_ == 'Offset':
            obj_ = IntegerConstantArray.factory()
            obj_.build(child_)
            self.Offset.append(obj_)
            obj_.original_tagname_ = 'Offset'
        super(IntegerLatticeArray, self).buildChildren(child_, node, nodeName_, True)
# end class IntegerLatticeArray


class IntegerExternalArray(AbstractIntegerArray):
    """Array of integer values provided explicitly by an HDF5 dataset. The
    null value must be explicitly provided in the NullValue
    attribute of this class."""
    subclass = None
    superclass = AbstractIntegerArray
    def __init__(self, NullValue=None, Values=None):
        self.original_tagname_ = None
        super(IntegerExternalArray, self).__init__()
        self.NullValue = NullValue
        self.Values = Values
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntegerExternalArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntegerExternalArray.subclass:
            return IntegerExternalArray.subclass(*args_, **kwargs_)
        else:
            return IntegerExternalArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NullValue(self): return self.NullValue
    def set_NullValue(self, NullValue): self.NullValue = NullValue
    NullValueProp = property(get_NullValue, set_NullValue)
    def get_Values(self): return self.Values
    def set_Values(self, Values): self.Values = Values
    ValuesProp = property(get_Values, set_Values)
    def hasContent_(self):
        if (
            self.NullValue is not None or
            self.Values is not None or
            super(IntegerExternalArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='IntegerExternalArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerExternalArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='IntegerExternalArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='IntegerExternalArray'):
        super(IntegerExternalArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerExternalArray')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='IntegerExternalArray', fromsubclass_=False, pretty_print=True):
        super(IntegerExternalArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NullValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNullValue>%s</%sNullValue>%s' % (namespace_, self.gds_format_integer(self.NullValue, input_name='NullValue'), namespace_, eol_))
        if self.Values is not None:
            self.Values.export(outfile, level, namespace_, name_='Values', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IntegerExternalArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NullValue':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NullValue')
            self.NullValue = ival_
        elif nodeName_ == 'Values':
            obj_ = ExternalDataset.factory()
            obj_.build(child_)
            self.Values = obj_
            obj_.original_tagname_ = 'Values'
        super(IntegerExternalArray, self).buildChildren(child_, node, nodeName_, True)
# end class IntegerExternalArray


class IntegerConstantArray(AbstractIntegerArray):
    """Represents an array of integer values where all values are
    identical. This an optimization for which an array of explicit
    integer values is not required."""
    subclass = None
    superclass = AbstractIntegerArray
    def __init__(self, Value=None, Count=None):
        self.original_tagname_ = None
        super(IntegerConstantArray, self).__init__()
        self.Value = Value
        self.Count = Count
        self.validate_PositiveLong(self.Count)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntegerConstantArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntegerConstantArray.subclass:
            return IntegerConstantArray.subclass(*args_, **kwargs_)
        else:
            return IntegerConstantArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    ValueProp = property(get_Value, set_Value)
    def get_Count(self): return self.Count
    def set_Count(self, Count): self.Count = Count
    CountProp = property(get_Count, set_Count)
    def validate_PositiveLong(self, value):
        # Validate type PositiveLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveLong' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Value is not None or
            self.Count is not None or
            super(IntegerConstantArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='IntegerConstantArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerConstantArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='IntegerConstantArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='IntegerConstantArray'):
        super(IntegerConstantArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerConstantArray')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='IntegerConstantArray', fromsubclass_=False, pretty_print=True):
        super(IntegerConstantArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_integer(self.Value, input_name='Value'), namespace_, eol_))
        if self.Count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCount>%s</%sCount>%s' % (namespace_, self.gds_format_integer(self.Count, input_name='Count'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IntegerConstantArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Value')
            self.Value = ival_
        elif nodeName_ == 'Count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Count')
            self.Count = ival_
            # validate type PositiveLong
            self.validate_PositiveLong(self.Count)
        super(IntegerConstantArray, self).buildChildren(child_, node, nodeName_, True)
# end class IntegerConstantArray


class IntegerArrayFromBooleanMaskArray(AbstractIntegerArray):
    """One-dimensional array of integer values obtained from the true
    elements of the Boolean mask."""
    subclass = None
    superclass = AbstractIntegerArray
    def __init__(self, TotalIndexCount=None, Mask=None):
        self.original_tagname_ = None
        super(IntegerArrayFromBooleanMaskArray, self).__init__()
        self.TotalIndexCount = TotalIndexCount
        self.validate_PositiveLong(self.TotalIndexCount)
        self.Mask = Mask
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntegerArrayFromBooleanMaskArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntegerArrayFromBooleanMaskArray.subclass:
            return IntegerArrayFromBooleanMaskArray.subclass(*args_, **kwargs_)
        else:
            return IntegerArrayFromBooleanMaskArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TotalIndexCount(self): return self.TotalIndexCount
    def set_TotalIndexCount(self, TotalIndexCount): self.TotalIndexCount = TotalIndexCount
    TotalIndexCountProp = property(get_TotalIndexCount, set_TotalIndexCount)
    def get_Mask(self): return self.Mask
    def set_Mask(self, Mask): self.Mask = Mask
    MaskProp = property(get_Mask, set_Mask)
    def validate_PositiveLong(self, value):
        # Validate type PositiveLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveLong' % {"value" : value} )
    def hasContent_(self):
        if (
            self.TotalIndexCount is not None or
            self.Mask is not None or
            super(IntegerArrayFromBooleanMaskArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='IntegerArrayFromBooleanMaskArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerArrayFromBooleanMaskArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='IntegerArrayFromBooleanMaskArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='IntegerArrayFromBooleanMaskArray'):
        super(IntegerArrayFromBooleanMaskArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerArrayFromBooleanMaskArray')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='IntegerArrayFromBooleanMaskArray', fromsubclass_=False, pretty_print=True):
        super(IntegerArrayFromBooleanMaskArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TotalIndexCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTotalIndexCount>%s</%sTotalIndexCount>%s' % (namespace_, self.gds_format_integer(self.TotalIndexCount, input_name='TotalIndexCount'), namespace_, eol_))
        if self.Mask is not None:
            self.Mask.export(outfile, level, namespace_, name_='Mask', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IntegerArrayFromBooleanMaskArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TotalIndexCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TotalIndexCount')
            self.TotalIndexCount = ival_
            # validate type PositiveLong
            self.validate_PositiveLong(self.TotalIndexCount)
        elif nodeName_ == 'Mask':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Mask> element')
            self.Mask = obj_
            obj_.original_tagname_ = 'Mask'
        super(IntegerArrayFromBooleanMaskArray, self).buildChildren(child_, node, nodeName_, True)
# end class IntegerArrayFromBooleanMaskArray


class FloatingPointLatticeArray(AbstractFloatingPointArray):
    """Represents an array of doubles based on an origin and a multi-
    dimensional offset. The offset is based on a linearization of a
    multi-dimensional offset. If count(i) is the number of elements
    in the dimension i and offset(i) is the offset in the dimension
    i, then: globalOffsetInNDimension = startValue+ ni*offset(n) +
    n_1i*count(n)*offset(n-1) + .... +
    0i*count(n)*count(n-1)*....count(1)*offset(0)"""
    subclass = None
    superclass = AbstractFloatingPointArray
    def __init__(self, StartValue=None, Offset=None):
        self.original_tagname_ = None
        super(FloatingPointLatticeArray, self).__init__()
        self.StartValue = StartValue
        if Offset is None:
            self.Offset = []
        else:
            self.Offset = Offset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatingPointLatticeArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatingPointLatticeArray.subclass:
            return FloatingPointLatticeArray.subclass(*args_, **kwargs_)
        else:
            return FloatingPointLatticeArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartValue(self): return self.StartValue
    def set_StartValue(self, StartValue): self.StartValue = StartValue
    StartValueProp = property(get_StartValue, set_StartValue)
    def get_Offset(self): return self.Offset
    def set_Offset(self, Offset): self.Offset = Offset
    def add_Offset(self, value): self.Offset.append(value)
    def insert_Offset_at(self, index, value): self.Offset.insert(index, value)
    def replace_Offset_at(self, index, value): self.Offset[index] = value
    OffsetProp = property(get_Offset, set_Offset)
    def hasContent_(self):
        if (
            self.StartValue is not None or
            self.Offset or
            super(FloatingPointLatticeArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FloatingPointLatticeArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingPointLatticeArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FloatingPointLatticeArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FloatingPointLatticeArray'):
        super(FloatingPointLatticeArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingPointLatticeArray')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FloatingPointLatticeArray', fromsubclass_=False, pretty_print=True):
        super(FloatingPointLatticeArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StartValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartValue>%s</%sStartValue>%s' % (namespace_, self.gds_format_double(self.StartValue, input_name='StartValue'), namespace_, eol_))
        for Offset_ in self.Offset:
            Offset_.export(outfile, level, namespace_, name_='Offset', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FloatingPointLatticeArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'StartValue')
            self.StartValue = fval_
        elif nodeName_ == 'Offset':
            obj_ = FloatingPointConstantArray.factory()
            obj_.build(child_)
            self.Offset.append(obj_)
            obj_.original_tagname_ = 'Offset'
        super(FloatingPointLatticeArray, self).buildChildren(child_, node, nodeName_, True)
# end class FloatingPointLatticeArray


class FloatingPointExternalArray(AbstractFloatingPointArray):
    """An array of double values provided explicitly by an HDF5 dataset. By
    convention, the null value is NaN."""
    subclass = None
    superclass = AbstractFloatingPointArray
    def __init__(self, Values=None, extensiontype_=None):
        self.original_tagname_ = None
        super(FloatingPointExternalArray, self).__init__(extensiontype_, )
        self.Values = Values
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatingPointExternalArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatingPointExternalArray.subclass:
            return FloatingPointExternalArray.subclass(*args_, **kwargs_)
        else:
            return FloatingPointExternalArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Values(self): return self.Values
    def set_Values(self, Values): self.Values = Values
    ValuesProp = property(get_Values, set_Values)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Values is not None or
            super(FloatingPointExternalArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FloatingPointExternalArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingPointExternalArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FloatingPointExternalArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FloatingPointExternalArray'):
        super(FloatingPointExternalArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingPointExternalArray')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FloatingPointExternalArray', fromsubclass_=False, pretty_print=True):
        super(FloatingPointExternalArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Values is not None:
            self.Values.export(outfile, level, namespace_, name_='Values', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(FloatingPointExternalArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Values':
            obj_ = ExternalDataset.factory()
            obj_.build(child_)
            self.Values = obj_
            obj_.original_tagname_ = 'Values'
        super(FloatingPointExternalArray, self).buildChildren(child_, node, nodeName_, True)
# end class FloatingPointExternalArray


class FloatingPointConstantArray(AbstractFloatingPointArray):
    """Represents an array of double values where all values are identical.
    This an optimization for which an array of explicit double
    values is not required."""
    subclass = None
    superclass = AbstractFloatingPointArray
    def __init__(self, Value=None, Count=None):
        self.original_tagname_ = None
        super(FloatingPointConstantArray, self).__init__()
        self.Value = Value
        self.Count = Count
        self.validate_PositiveLong(self.Count)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatingPointConstantArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatingPointConstantArray.subclass:
            return FloatingPointConstantArray.subclass(*args_, **kwargs_)
        else:
            return FloatingPointConstantArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    ValueProp = property(get_Value, set_Value)
    def get_Count(self): return self.Count
    def set_Count(self, Count): self.Count = Count
    CountProp = property(get_Count, set_Count)
    def validate_PositiveLong(self, value):
        # Validate type PositiveLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveLong' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Value is not None or
            self.Count is not None or
            super(FloatingPointConstantArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FloatingPointConstantArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingPointConstantArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FloatingPointConstantArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FloatingPointConstantArray'):
        super(FloatingPointConstantArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingPointConstantArray')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FloatingPointConstantArray', fromsubclass_=False, pretty_print=True):
        super(FloatingPointConstantArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_double(self.Value, input_name='Value'), namespace_, eol_))
        if self.Count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCount>%s</%sCount>%s' % (namespace_, self.gds_format_integer(self.Count, input_name='Count'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FloatingPointConstantArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Value')
            self.Value = fval_
        elif nodeName_ == 'Count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Count')
            self.Count = ival_
            # validate type PositiveLong
            self.validate_PositiveLong(self.Count)
        super(FloatingPointConstantArray, self).buildChildren(child_, node, nodeName_, True)
# end class FloatingPointConstantArray


class FloatExternalArray(FloatingPointExternalArray):
    subclass = None
    superclass = FloatingPointExternalArray
    def __init__(self, Values=None):
        self.original_tagname_ = None
        super(FloatExternalArray, self).__init__(Values, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatExternalArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatExternalArray.subclass:
            return FloatExternalArray.subclass(*args_, **kwargs_)
        else:
            return FloatExternalArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(FloatExternalArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='FloatExternalArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatExternalArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='FloatExternalArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='FloatExternalArray'):
        super(FloatExternalArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FloatExternalArray')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='FloatExternalArray', fromsubclass_=False, pretty_print=True):
        super(FloatExternalArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FloatExternalArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FloatExternalArray, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FloatExternalArray


class DoubleExternalArray(FloatingPointExternalArray):
    subclass = None
    superclass = FloatingPointExternalArray
    def __init__(self, Values=None):
        self.original_tagname_ = None
        super(DoubleExternalArray, self).__init__(Values, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DoubleExternalArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DoubleExternalArray.subclass:
            return DoubleExternalArray.subclass(*args_, **kwargs_)
        else:
            return DoubleExternalArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DoubleExternalArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='DoubleExternalArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DoubleExternalArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='DoubleExternalArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='DoubleExternalArray'):
        super(DoubleExternalArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DoubleExternalArray')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='DoubleExternalArray', fromsubclass_=False, pretty_print=True):
        super(DoubleExternalArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DoubleExternalArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DoubleExternalArray, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DoubleExternalArray


class BooleanExternalArray(AbstractBooleanArray):
    """Array of Boolean values provided explicitly by an HDF5 dataset."""
    subclass = None
    superclass = AbstractBooleanArray
    def __init__(self, Values=None):
        self.original_tagname_ = None
        super(BooleanExternalArray, self).__init__()
        self.Values = Values
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BooleanExternalArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BooleanExternalArray.subclass:
            return BooleanExternalArray.subclass(*args_, **kwargs_)
        else:
            return BooleanExternalArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Values(self): return self.Values
    def set_Values(self, Values): self.Values = Values
    ValuesProp = property(get_Values, set_Values)
    def hasContent_(self):
        if (
            self.Values is not None or
            super(BooleanExternalArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='BooleanExternalArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BooleanExternalArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='BooleanExternalArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='BooleanExternalArray'):
        super(BooleanExternalArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BooleanExternalArray')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='BooleanExternalArray', fromsubclass_=False, pretty_print=True):
        super(BooleanExternalArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Values is not None:
            self.Values.export(outfile, level, namespace_, name_='Values', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BooleanExternalArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Values':
            obj_ = ExternalDataset.factory()
            obj_.build(child_)
            self.Values = obj_
            obj_.original_tagname_ = 'Values'
        super(BooleanExternalArray, self).buildChildren(child_, node, nodeName_, True)
# end class BooleanExternalArray


class BooleanConstantArray(AbstractBooleanArray):
    """Represents an array of Boolean values where all values are
    identical. This an optimization for which an array of explicit
    Boolean values is not required."""
    subclass = None
    superclass = AbstractBooleanArray
    def __init__(self, Value=None, Count=None):
        self.original_tagname_ = None
        super(BooleanConstantArray, self).__init__()
        self.Value = Value
        self.Count = Count
        self.validate_PositiveLong(self.Count)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BooleanConstantArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BooleanConstantArray.subclass:
            return BooleanConstantArray.subclass(*args_, **kwargs_)
        else:
            return BooleanConstantArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    ValueProp = property(get_Value, set_Value)
    def get_Count(self): return self.Count
    def set_Count(self, Count): self.Count = Count
    CountProp = property(get_Count, set_Count)
    def validate_PositiveLong(self, value):
        # Validate type PositiveLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveLong' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Value is not None or
            self.Count is not None or
            super(BooleanConstantArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='BooleanConstantArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BooleanConstantArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='BooleanConstantArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='BooleanConstantArray'):
        super(BooleanConstantArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BooleanConstantArray')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='BooleanConstantArray', fromsubclass_=False, pretty_print=True):
        super(BooleanConstantArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_boolean(self.Value, input_name='Value'), namespace_, eol_))
        if self.Count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCount>%s</%sCount>%s' % (namespace_, self.gds_format_integer(self.Count, input_name='Count'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BooleanConstantArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Value')
            self.Value = ival_
        elif nodeName_ == 'Count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Count')
            self.Count = ival_
            # validate type PositiveLong
            self.validate_PositiveLong(self.Count)
        super(BooleanConstantArray, self).buildChildren(child_, node, nodeName_, True)
# end class BooleanConstantArray


class BooleanArrayFromIndexArray(AbstractBooleanArray):
    """An array of Boolean values defined by specifying explicitly which
    indices in the array are either true or false. This class is
    used to represent very sparse true or false data."""
    subclass = None
    superclass = AbstractBooleanArray
    def __init__(self, Count=None, Indices=None, IndexIsTrue=None):
        self.original_tagname_ = None
        super(BooleanArrayFromIndexArray, self).__init__()
        self.Count = Count
        self.validate_PositiveLong(self.Count)
        self.Indices = Indices
        self.IndexIsTrue = IndexIsTrue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BooleanArrayFromIndexArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BooleanArrayFromIndexArray.subclass:
            return BooleanArrayFromIndexArray.subclass(*args_, **kwargs_)
        else:
            return BooleanArrayFromIndexArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Count(self): return self.Count
    def set_Count(self, Count): self.Count = Count
    CountProp = property(get_Count, set_Count)
    def get_Indices(self): return self.Indices
    def set_Indices(self, Indices): self.Indices = Indices
    IndicesProp = property(get_Indices, set_Indices)
    def get_IndexIsTrue(self): return self.IndexIsTrue
    def set_IndexIsTrue(self, IndexIsTrue): self.IndexIsTrue = IndexIsTrue
    IndexIsTrueProp = property(get_IndexIsTrue, set_IndexIsTrue)
    def validate_PositiveLong(self, value):
        # Validate type PositiveLong, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveLong' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Count is not None or
            self.Indices is not None or
            self.IndexIsTrue is not None or
            super(BooleanArrayFromIndexArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='BooleanArrayFromIndexArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BooleanArrayFromIndexArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='BooleanArrayFromIndexArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='BooleanArrayFromIndexArray'):
        super(BooleanArrayFromIndexArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BooleanArrayFromIndexArray')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='BooleanArrayFromIndexArray', fromsubclass_=False, pretty_print=True):
        super(BooleanArrayFromIndexArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCount>%s</%sCount>%s' % (namespace_, self.gds_format_integer(self.Count, input_name='Count'), namespace_, eol_))
        if self.Indices is not None:
            self.Indices.export(outfile, level, namespace_, name_='Indices', pretty_print=pretty_print)
        if self.IndexIsTrue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndexIsTrue>%s</%sIndexIsTrue>%s' % (namespace_, self.gds_format_boolean(self.IndexIsTrue, input_name='IndexIsTrue'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BooleanArrayFromIndexArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Count')
            self.Count = ival_
            # validate type PositiveLong
            self.validate_PositiveLong(self.Count)
        elif nodeName_ == 'Indices':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Indices> element')
            self.Indices = obj_
            obj_.original_tagname_ = 'Indices'
        elif nodeName_ == 'IndexIsTrue':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IndexIsTrue')
            self.IndexIsTrue = ival_
        super(BooleanArrayFromIndexArray, self).buildChildren(child_, node, nodeName_, True)
# end class BooleanArrayFromIndexArray


class VerticalDatumType(AbstractDatumType):
    subclass = None
    superclass = AbstractDatumType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, anchorDefinition=None, realizationEpoch=None):
        self.original_tagname_ = None
        super(VerticalDatumType, self).__init__(id, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, anchorDefinition, realizationEpoch, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalDatumType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalDatumType.subclass:
            return VerticalDatumType.subclass(*args_, **kwargs_)
        else:
            return VerticalDatumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(VerticalDatumType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VerticalDatumType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalDatumType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VerticalDatumType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VerticalDatumType'):
        super(VerticalDatumType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalDatumType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VerticalDatumType', fromsubclass_=False, pretty_print=True):
        super(VerticalDatumType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VerticalDatumType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VerticalDatumType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VerticalDatumType


class VerticalCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        self.original_tagname_ = None
        super(VerticalCSType, self).__init__(id, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalCSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalCSType.subclass:
            return VerticalCSType.subclass(*args_, **kwargs_)
        else:
            return VerticalCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(VerticalCSType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='VerticalCSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalCSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='VerticalCSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='VerticalCSType'):
        super(VerticalCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalCSType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='VerticalCSType', fromsubclass_=False, pretty_print=True):
        super(VerticalCSType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VerticalCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VerticalCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VerticalCSType


class SphericalCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        self.original_tagname_ = None
        super(SphericalCSType, self).__init__(id, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SphericalCSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SphericalCSType.subclass:
            return SphericalCSType.subclass(*args_, **kwargs_)
        else:
            return SphericalCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(SphericalCSType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='SphericalCSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SphericalCSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='SphericalCSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='SphericalCSType'):
        super(SphericalCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SphericalCSType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='SphericalCSType', fromsubclass_=False, pretty_print=True):
        super(SphericalCSType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SphericalCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SphericalCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SphericalCSType


class CartesianCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        self.original_tagname_ = None
        super(CartesianCSType, self).__init__(id, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CartesianCSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CartesianCSType.subclass:
            return CartesianCSType.subclass(*args_, **kwargs_)
        else:
            return CartesianCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(CartesianCSType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='prodml:', name_='CartesianCSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CartesianCSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='prodml:', name_='CartesianCSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='prodml:', name_='CartesianCSType'):
        super(CartesianCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CartesianCSType')
    def exportChildren(self, outfile, level, namespace_='prodml:', name_='CartesianCSType', fromsubclass_=False, pretty_print=True):
        super(CartesianCSType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CartesianCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CartesianCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CartesianCSType


GDSClassesMapping = {
    'APIGravity': APIGravityMeasure,
    'AbsoluteMinPres': PressureMeasure,
    'AbsolutePressure': PressureMeasureExt,
    'AbstractCRS': AbstractCRSType,
    'AbstractContextualObject': AbstractObject,
    'AbstractCoordinateOperation': AbstractCoordinateOperationType,
    'AbstractCoordinateSystem': AbstractCoordinateSystemType,
    'AbstractDQ_Element': AbstractDQ_Element_Type,
    'AbstractDQ_PositionalAccuracy': AbstractDQ_PositionalAccuracy_Type,
    'AbstractDQ_Result': AbstractDQ_Result_Type,
    'AbstractDataObject': AbstractObject,
    'AbstractDatum': AbstractDatumType,
    'AbstractEX_GeographicExtent': AbstractEX_GeographicExtent_Type,
    'AbstractGML': AbstractGMLType,
    'AbstractGeneralConversion': AbstractGeneralConversionType,
    'AbstractGeneralDerivedCRS': AbstractGeneralDerivedCRSType,
    'AbstractOperation': AbstractCoordinateOperationType,
    'AbstractSingleCRS': AbstractCRSType,
    'AbstractSingleOperation': AbstractCoordinateOperationType,
    'AbstractTimeObject': AbstractTimeObjectType,
    'AbstractTimePrimitive': AbstractTimePrimitiveType,
    'ActivityDescriptor': DataObjectReference,
    'Address': GeneralAddress,
    'Alert': ProductVolumeAlert,
    'Alias': NameStruct,
    'Aliases': ObjectAlias,
    'Approver': BusinessAssociate,
    'Atmosphere': PressureMeasure,
    'AttenuationMeasure': AbstractAttenuationMeasure,
    'AvgBoilingPoint': ThermodynamicTemperatureMeasure,
    'AvgDensity': MassPerVolumeMeasure,
    'AvgMolecularWeight': MolecularWeightMeasure,
    'BalanceDetail': ProductVolumeBalanceDetail,
    'BalanceSet': ProductVolumeBalanceSet,
    'Bsw': VolumePerVolumeMeasure,
    'BswPrevious': VolumePerVolumeMeasure,
    'BswStabilizedCrude': VolumePerVolumeMeasure,
    'BusinessUnit': ProductVolumeBusinessUnit,
    'CI_Address': CI_Address_Type,
    'CI_Citation': CI_Citation_Type,
    'CI_Contact': CI_Contact_Type,
    'CI_Date': CI_Date_Type,
    'CI_DateTypeCode': CodeListValue_Type,
    'CI_OnLineFunctionCode': CodeListValue_Type,
    'CI_OnlineResource': CI_OnlineResource_Type,
    'CI_PresentationFormCode': CodeListValue_Type,
    'CI_ResponsibleParty': CI_ResponsibleParty_Type,
    'CI_RoleCode': CodeListValue_Type,
    'CI_Series': CI_Series_Type,
    'CI_Telephone': CI_Telephone_Type,
    'Cable': AbstractCable,
    'Calibration': DasCalibration,
    'CalibrationDataPoints': DasCalibrationPoint,
    'CalibrationFacilityLength': LengthMeasure,
    'CalibrationOpticalPathDistance': LengthMeasure,
    'Capacity': VolumeMeasure,
    'CartesianCS': CartesianCSType,
    'ChangeLog': ProductFlowChangeLog,
    'ChokeRelative': LengthPerLengthMeasure,
    'ChokeSize': LengthMeasure,
    'CladdedDiameter': LengthMeasure,
    'Comment': DatedComment,
    'ComponentContent': ProductVolumeComponentContent,
    'Concentration': VolumePerVolumeMeasure,
    'ConnectedInstallation': FacilityIdentifierStruct,
    'Connection': FiberConnection,
    'ContextFacility': FacilityIdentifierStruct,
    'CoordinateSystemAxis': CoordinateSystemAxisType,
    'CoreDiameter': LengthMeasure,
    'CumulativeLength': AbstractIntegerArray,
    'Custom': DasCustom,
    'CustomUnitDictionary': DataObjectReference,
    'DQ_EvaluationMethodTypeCode': CodeListValue_Type,
    'DTimMax': EndpointQualifiedDateTime,
    'DTimMin': EndpointQualifiedDateTime,
    'DasInstrumentBox': DataObjectReference,
    'DataObject': DataObjectReference,
    'DateTime': AbstractDateTimeClass,
    'Deadband': GeneralMeasureType,
    'DefaultValue': AbstractActivityParameter,
    'Defect': FiberPathDefect,
    'Definition': DefinitionType,
    'Density': MassPerVolumeMeasureExt,
    'DensityFlowRate': MassPerTimeMeasure,
    'DensityStabilizedCrude': MassPerVolumeMeasure,
    'Destination': ProductVolumeDestination,
    'DowntimeReason': DatedComment,
    'EX_Extent': EX_Extent_Type,
    'EX_TemporalExtent': EX_TemporalExtent_Type,
    'EX_VerticalExtent': EX_VerticalExtent_Type,
    'Efficiency': VolumePerVolumeMeasure,
    'Elements': AbstractValueArray,
    'Ellipsoid': EllipsoidType,
    'EllipsoidalCS': EllipsoidalCSType,
    'Email': EmailQualifierStruct,
    'EndFrequency': FrequencyMeasure,
    'EndingBoilingPoint': ThermodynamicTemperatureMeasure,
    'EpcExternalPartReference': DataObjectReference,
    'Event': ProductVolumeBalanceEvent,
    'ExcessFiberRecovered': LengthMeasure,
    'ExistenceTime': EndpointQualifiedDateTime,
    'ExpectedFlowProduct': ProductFlowQualifierExpected,
    'ExpectedFlowProperty': ProductFlowExpectedUnitProperty,
    'ExpectedProperty': ProductFlowExpectedUnitProperty,
    'ExternalConnect': ProductFlowExternalReference,
    'ExternalFileProxy': ExternalDatasetPart,
    'Facility': FacilityIdentifierStruct,
    'FacilityAlias': NameStruct,
    'FacilityLengthEnd': LengthMeasure,
    'FacilityLengthStart': LengthMeasure,
    'FacilityMapping': FiberFacilityMapping,
    'FacilityParent': FacilityIdentifierStruct,
    'FacilityParent1': FacilityIdentifierStruct,
    'FacilityParent2': FacilityIdentifierStruct,
    'FailingRuleExtensions': ExtensionNameValue,
    'FailingRules': FailingRule,
    'Fbe': DasFbe,
    'FbeData': DasFbeData,
    'FbeDataArray': AbstractNumericArray,
    'FbeDataTime': DasTimeArray,
    'FiberFacility': AbstractFiberFacility,
    'FiberLength': LengthMeasure,
    'Field': NameStruct,
    'Flow': ProductVolumeFlow,
    'FlowRate': VolumePerTimeMeasureExt,
    'Frequency': FrequencyMeasure,
    'GasLiquidRatio': VolumePerVolumeMeasure,
    'GaugeLength': LengthMeasure,
    'GaugePressure': PressureMeasureExt,
    'GeodeticCRS': GeodeticCRSType,
    'GeodeticDatum': GeodeticDatumType,
    'GmlProjectedCrsDefinition': ProjectedCRSType,
    'GmlVerticalCrsDefinition': VerticalCRSType,
    'Gor': VolumePerVolumeMeasure,
    'GorMTD': VolumePerVolumeMeasure,
    'GraphicalInformation': AbstractGraphicalInformation,
    'GrossCalorificValueStd': EnergyPerVolumeMeasure,
    'GrossEnergyContentPerUnitMass': EnergyPerMassMeasure,
    'GrossEnergyContentPerUnitVolume': EnergyPerVolumeMeasure,
    'HcDewpoint': ThermodynamicTemperatureMeasure,
    'ISBN': CharacterString_PropertyType,
    'ISSN': CharacterString_PropertyType,
    'Indices': AbstractIntegerArray,
    'Installation': FacilityIdentifierStruct,
    'InstallingVendor': BusinessAssociate,
    'InstrumentBoxReference': DataObjectReference,
    'InstrumentCalibration': DtsCalibration,
    'InstrumentVendor': BusinessAssociate,
    'IntegerValue': IntegerQualifiedCount,
    'InternalOvenLocationFar': LengthMeasure,
    'InternalOvenLocationNear': LengthMeasure,
    'Inventory': FiberOpticalPathInventory,
    'IssuedBy': BusinessAssociate,
    'KValue': AmountOfSubstancePerAmountOfSubstanceMeasure,
    'Key': AbstractParameterKey,
    'LiquidComponent': FluidComponent,
    'LocalAuthorityCrsName': AuthorityQualifiedName,
    'Loss': DimensionlessMeasure,
    'MD_Identifier': MD_Identifier_Type,
    'Mask': AbstractBooleanArray,
    'Mass': MassMeasure,
    'MassFraction': MassPerMassMeasure,
    'MaximumFrequency': TimeMeasure,
    'MdBase': LengthMeasure,
    'MdBottom': MeasuredDepthCoord,
    'MdTop': LengthMeasure,
    'MeasureDataType': AbstractMeasureDataType,
    'MeasurementContact': BusinessAssociate,
    'MeasurementPressureTemperature': AbstractTemperaturePressure,
    'MinimumFrequency': FrequencyMeasure,
    'MoleAmt': AmountOfSubstanceMeasure,
    'MoleFraction': AmountOfSubstancePerAmountOfSubstanceMeasure,
    'MolePercent': AmountOfSubstancePerAmountOfSubstanceMeasure,
    'MolecularWeight': MolecularWeightMeasure,
    'Name': NameStruct,
    'NetEnergyContentPerUnitMass': EnergyPerMassMeasure,
    'NetEnergyContentPerUnitVolume': EnergyPerVolumeMeasure,
    'Network': ProductFlowNetwork,
    'Offset': IntegerConstantArray,
    'OneWayAttenuation': FiberOneWayAttenuation,
    'OperationTime': TimeMeasure,
    'Operator': BusinessAssociate,
    'OpticalPath': DataObjectReference,
    'OpticalPathDistanceEnd': LengthMeasure,
    'OpticalPathDistanceStart': LengthMeasure,
    'OpticalPathLength': LengthMeasure,
    'OpticalPathNetwork': FiberOpticalPathNetwork,
    'OpticalPathReference': DataObjectReference,
    'Otdr': FiberOTDR,
    'OutputDataRate': FrequencyMeasure,
    'OutsideDiameter': LengthMeasure,
    'OverStuffing': LengthMeasure,
    'Parameter': ParameterTemplate,
    'ParameterSet': ProductVolumeParameterSet,
    'Parent': DataObjectReference,
    'ParentTimeIndex': TimeIndex,
    'PatchCord': DtsPatchCord,
    'Period': ProductVolumePeriod,
    'PhoneNumber': PhoneNumberStruct,
    'Plan': ProductFlowNetworkPlan,
    'Port': ProductFlowPort,
    'PortDiff': ProductVolumePortDifference,
    'Pres': PressureMeasure,
    'PresDiff': PressureMeasure,
    'Pressure': PressureMeasure,
    'PressureRating': PressureMeasure,
    'PrimeMeridian': PrimeMeridianType,
    'Processed': DasProcessed,
    'Product': ProductVolumeProduct,
    'ProductFlowModel': DataObjectReference,
    'ProjectedCRS': ProjectedCRSType,
    'Properties': CommonPropertiesProductVolume,
    'PulseRate': FrequencyMeasure,
    'PulseWidth': TimeMeasure,
    'PumpActivity': FiberPumpActivity,
    'Raw': DasRaw,
    'RawData': DasRawData,
    'RawDataArray': AbstractNumericArray,
    'RawDataTime': DasTimeArray,
    'RawDataTriggerTime': DasTimeArray,
    'ReferenceCoilTemperature': ThermodynamicTemperatureMeasure,
    'ReferencedData': DataObjectReference,
    'Reflectance': DimensionlessMeasure,
    'RefractiveIndex': FiberRefractiveIndex,
    'RelatedFacility': ProductVolumeRelatedFacility,
    'RelatedFacilityObject': AbstractRelatedFacilityObject,
    'RelativePressure': PressureMeasure,
    'Role': NameStruct,
    'Rvp': PressureMeasure,
    'RvpStabilizedCrude': PressureMeasure,
    'Salinity': MassPerMassMeasure,
    'Segment': FiberOpticalPathSegment,
    'Sg': DimensionlessMeasure,
    'Share': VolumePerVolumeMeasure,
    'SimulatorTimeStep': AbstractIntegerArray,
    'SourceFlow': AbstractRefProductFlow,
    'SpatialSamplingInterval': LengthMeasure,
    'Spectra': DasSpectra,
    'SpectraData': DasSpectraData,
    'SpectraDataArray': AbstractNumericArray,
    'SpectraDataTime': DasTimeArray,
    'SphericalCS': SphericalCSType,
    'Splice': FiberSplice,
    'SpoolLength': LengthMeasure,
    'StartFrequency': FrequencyMeasure,
    'StartingBoilingPoint': ThermodynamicTemperatureMeasure,
    'StartupTime': TimeMeasure,
    'StringValue': KindQualifiedString,
    'SubUnit': ProductVolumeBusinessSubUnit,
    'Supplier': BusinessAssociate,
    'TagAlias': NameStruct,
    'TargetObject': DataObjectReference,
    'Temp': ThermodynamicTemperatureMeasure,
    'TempDiff': ThermodynamicTemperatureMeasure,
    'Temperature': ThermodynamicTemperatureMeasure,
    'Terminator': FiberTerminator,
    'Time': GeologicTime,
    'TimeArray': IntegerExternalArray,
    'TimeSeries': DataObjectReference,
    'Title': NameStruct,
    'Turnaround': FiberTurnaround,
    'TvdBase': LengthMeasure,
    'TvdBottom': WellVerticalDepthCoord,
    'TvdTop': LengthMeasure,
    'Tvp': PressureMeasure,
    'Unit': ProductFlowUnit,
    'Value': StringMeasure,
    'Values': ExternalDataset,
    'VaporComponent': FluidComponent,
    'VendorCode': BusinessAssociate,
    'VerticalCRS': VerticalCRSType,
    'VerticalCS': VerticalCSType,
    'VerticalDatum': VerticalDatumType,
    'Volume': VolumeMeasureExt,
    'WarmupTime': TimeMeasure,
    'WaterConcMass': MassPerMassMeasure,
    'WaterConcVol': VolumePerVolumeMeasure,
    'WaterDewpoint': ThermodynamicTemperatureMeasure,
    'WaveLength': LengthMeasure,
    'Wavelength': LengthMeasure,
    'WeightPercent': MassPerMassMeasure,
    'WellboreReference': DataObjectReference,
    'WobbeIndex': IsothermalCompressibilityMeasure,
    'Work': EnergyMeasure,
    'X': LengthPerLengthMeasure,
    'Y': LengthPerLengthMeasure,
    'Z': LengthPerLengthMeasure,
    'address': CI_Address_PropertyType,
    'administrativeArea': CharacterString_PropertyType,
    'alternateTitle': CharacterString_PropertyType,
    'anchorDefinition': CodeType,
    'applicationProfile': CharacterString_PropertyType,
    'authority': CI_Citation_PropertyType,
    'axis': CoordinateSystemAxisPropertyType,
    'axisAbbrev': CodeType,
    'axisDirection': CodeWithAuthorityType,
    'baseGeodeticCRS': GeodeticCRSPropertyType,
    'cartesianCS': CartesianCSPropertyType,
    'citedResponsibleParty': CI_ResponsibleParty_PropertyType,
    'city': CharacterString_PropertyType,
    'code': CharacterString_PropertyType,
    'collectiveTitle': CharacterString_PropertyType,
    'contactInfo': CI_Contact_PropertyType,
    'contactInstructions': CharacterString_PropertyType,
    'conversion': GeneralConversionPropertyType,
    'country': CharacterString_PropertyType,
    'date': Date_PropertyType,
    'dateTime': DateTime_PropertyType,
    'dateType': CI_DateTypeCode_PropertyType,
    'deliveryPoint': CharacterString_PropertyType,
    'description': CharacterString_PropertyType,
    'descriptionReference': ReferenceType,
    'edition': CharacterString_PropertyType,
    'editionDate': Date_PropertyType,
    'electronicMailAddress': CharacterString_PropertyType,
    'ellipsoid': EllipsoidPropertyType,
    'ellipsoidalCS': EllipsoidalCSPropertyType,
    'evaluationMethodDescription': CharacterString_PropertyType,
    'evaluationMethodType': DQ_EvaluationMethodTypeCode_PropertyType,
    'evaluationProcedure': CI_Citation_PropertyType,
    'extent': TM_Primitive_PropertyType,
    'extentTypeCode': Boolean_PropertyType,
    'facsimile': CharacterString_PropertyType,
    'function': CI_OnLineFunctionCode_PropertyType,
    'geodeticDatum': GeodeticDatumPropertyType,
    'geographicElement': EX_GeographicExtent_PropertyType,
    'greenwichLongitude': AngleType,
    'hoursOfService': CharacterString_PropertyType,
    'identifier': MD_Identifier_PropertyType,
    'individualName': CharacterString_PropertyType,
    'inverseFlattening': MeasureType,
    'issueIdentification': CharacterString_PropertyType,
    'linkage': URL_PropertyType,
    'maximumValue': Real_PropertyType,
    'measureDescription': CharacterString_PropertyType,
    'measureIdentification': MD_Identifier_PropertyType,
    'minimumValue': Real_PropertyType,
    'name': CharacterString_PropertyType,
    'nameOfMeasure': CharacterString_PropertyType,
    'onlineResource': CI_OnlineResource_PropertyType,
    'organisationName': CharacterString_PropertyType,
    'otherCitationDetails': CharacterString_PropertyType,
    'page': CharacterString_PropertyType,
    'phone': CI_Telephone_PropertyType,
    'positionName': CharacterString_PropertyType,
    'postalCode': CharacterString_PropertyType,
    'presentationForm': CI_PresentationFormCode_PropertyType,
    'primeMeridian': PrimeMeridianPropertyType,
    'protocol': CharacterString_PropertyType,
    'rangeMeaning': CodeWithAuthorityType,
    'relatedTime': RelatedTimeType,
    'result': DQ_Result_PropertyType,
    'role': CI_RoleCode_PropertyType,
    'semiMajorAxis': MeasureType,
    'semiMinorAxis': LengthType,
    'series': CI_Series_PropertyType,
    'sourceCRS': CRSPropertyType,
    'sphericalCS': SphericalCSPropertyType,
    'targetCRS': CRSPropertyType,
    'temporalElement': EX_TemporalExtent_PropertyType,
    'title': CharacterString_PropertyType,
    'verticalCRS': SC_CRS_PropertyType,
    'verticalCS': VerticalCSPropertyType,
    'verticalDatum': VerticalDatumPropertyType,
    'verticalElement': EX_VerticalExtent_PropertyType,
    'voice': CharacterString_PropertyType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DasAcquisition'
        rootClass = DasAcquisition
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DasAcquisition'
        rootClass = DasAcquisition
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DasAcquisition'
        rootClass = DasAcquisition
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:prodml="http://www.energistics.org/energyml/data/prodmlv2"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DasAcquisition'
        rootClass = DasAcquisition
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from DasAcquisition import *\n\n')
        sys.stdout.write('import DasAcquisition as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "APIGammaRayMeasure",
    "APIGammaRayMeasureExt",
    "APIGravityMeasure",
    "APIGravityMeasureExt",
    "APINeutronMeasure",
    "APINeutronMeasureExt",
    "AbsolutePressure",
    "AbsorbedDoseMeasure",
    "AbsorbedDoseMeasureExt",
    "AbstractActivityParameter",
    "AbstractAttenuationMeasure",
    "AbstractBooleanArray",
    "AbstractCRSType",
    "AbstractCable",
    "AbstractCoordinateOperationType",
    "AbstractCoordinateSystemType",
    "AbstractDQ_Element_Type",
    "AbstractDQ_PositionalAccuracy_Type",
    "AbstractDQ_Result_Type",
    "AbstractDateTimeClass",
    "AbstractDatumType",
    "AbstractDtsEquipment",
    "AbstractEX_GeographicExtent_Type",
    "AbstractFiberFacility",
    "AbstractFloatingPointArray",
    "AbstractFluidComponent",
    "AbstractGMLType",
    "AbstractGeneralConversionType",
    "AbstractGeneralDerivedCRSType",
    "AbstractGeodeticCrs",
    "AbstractGraphicalInformation",
    "AbstractIntegerArray",
    "AbstractMeasureDataType",
    "AbstractNumericArray",
    "AbstractObject",
    "AbstractObject_Type",
    "AbstractParameterKey",
    "AbstractPressureValue",
    "AbstractProjectedCrs",
    "AbstractRefProductFlow",
    "AbstractRelatedFacilityObject",
    "AbstractStringArray",
    "AbstractTemperaturePressure",
    "AbstractTimeObjectType",
    "AbstractTimePrimitiveType",
    "AbstractValueArray",
    "AbstractVerticalCrs",
    "Activity",
    "ActivityOfRadioactivityMeasure",
    "ActivityOfRadioactivityMeasureExt",
    "ActivityTemplate",
    "AmountOfSubstanceMeasure",
    "AmountOfSubstanceMeasureExt",
    "AmountOfSubstancePerAmountOfSubstanceMeasure",
    "AmountOfSubstancePerAmountOfSubstanceMeasureExt",
    "AmountOfSubstancePerAreaMeasure",
    "AmountOfSubstancePerAreaMeasureExt",
    "AmountOfSubstancePerTimeMeasure",
    "AmountOfSubstancePerTimeMeasureExt",
    "AmountOfSubstancePerTimePerAreaMeasure",
    "AmountOfSubstancePerTimePerAreaMeasureExt",
    "AmountOfSubstancePerVolumeMeasure",
    "AmountOfSubstancePerVolumeMeasureExt",
    "AnglePerLengthMeasure",
    "AnglePerLengthMeasureExt",
    "AnglePerVolumeMeasure",
    "AnglePerVolumeMeasureExt",
    "AngleType",
    "AngularAccelerationMeasure",
    "AngularAccelerationMeasureExt",
    "AngularVelocityMeasure",
    "AngularVelocityMeasureExt",
    "AreaMeasure",
    "AreaMeasureExt",
    "AreaPerAmountOfSubstanceMeasure",
    "AreaPerAmountOfSubstanceMeasureExt",
    "AreaPerAreaMeasure",
    "AreaPerAreaMeasureExt",
    "AreaPerCountMeasure",
    "AreaPerCountMeasureExt",
    "AreaPerMassMeasure",
    "AreaPerMassMeasureExt",
    "AreaPerTimeMeasure",
    "AreaPerTimeMeasureExt",
    "AreaPerVolumeMeasure",
    "AreaPerVolumeMeasureExt",
    "AttenuationPerFrequencyIntervalMeasure",
    "AttenuationPerFrequencyIntervalMeasureExt",
    "AuthorityQualifiedName",
    "BooleanArrayFromIndexArray",
    "BooleanConstantArray",
    "BooleanExternalArray",
    "Boolean_PropertyType",
    "BusinessAssociate",
    "CI_Address_PropertyType",
    "CI_Address_Type",
    "CI_Citation_PropertyType",
    "CI_Citation_Type",
    "CI_Contact_PropertyType",
    "CI_Contact_Type",
    "CI_DateTypeCode_PropertyType",
    "CI_Date_PropertyType",
    "CI_Date_Type",
    "CI_OnLineFunctionCode_PropertyType",
    "CI_OnlineResource_PropertyType",
    "CI_OnlineResource_Type",
    "CI_PresentationFormCode_PropertyType",
    "CI_ResponsibleParty_PropertyType",
    "CI_ResponsibleParty_Type",
    "CI_RoleCode_PropertyType",
    "CI_Series_PropertyType",
    "CI_Series_Type",
    "CI_Telephone_PropertyType",
    "CI_Telephone_Type",
    "CRSPropertyType",
    "CalibrationParameter",
    "CapacitanceMeasure",
    "CapacitanceMeasureExt",
    "CartesianCSPropertyType",
    "CartesianCSType",
    "CationExchangeCapacityMeasure",
    "CationExchangeCapacityMeasureExt",
    "CharacterString_PropertyType",
    "Citation",
    "CodeListValue_Type",
    "CodeType",
    "CodeWithAuthorityType",
    "CommonPropertiesProductVolume",
    "ConnectedNode",
    "CoordinateSystemAxisPropertyType",
    "CoordinateSystemAxisType",
    "CurveData",
    "CurveDefinition",
    "CustomData",
    "DQ_EvaluationMethodTypeCode_PropertyType",
    "DQ_Result_PropertyType",
    "DasAcquisition",
    "DasCalibration",
    "DasCalibrationPoint",
    "DasCustom",
    "DasExternalDatasetPart",
    "DasFbe",
    "DasFbeData",
    "DasInstrumentBox",
    "DasProcessed",
    "DasRaw",
    "DasRawData",
    "DasSpectra",
    "DasSpectraData",
    "DasTimeArray",
    "DataAssuranceRecord",
    "DataObjectParameter",
    "DataObjectReference",
    "DataTransferSpeedMeasure",
    "DataTransferSpeedMeasureExt",
    "DateTime_PropertyType",
    "Date_PropertyType",
    "DatedComment",
    "DefinitionBaseType",
    "DefinitionType",
    "DensityValue",
    "DiffusionCoefficientMeasure",
    "DiffusionCoefficientMeasureExt",
    "DiffusiveTimeOfFlightMeasure",
    "DiffusiveTimeOfFlightMeasureExt",
    "DigitalStorageMeasure",
    "DigitalStorageMeasureExt",
    "DimensionlessMeasure",
    "DimensionlessMeasureExt",
    "DipoleMomentMeasure",
    "DipoleMomentMeasureExt",
    "DoseEquivalentMeasure",
    "DoseEquivalentMeasureExt",
    "DoubleExternalArray",
    "DoubleQuantityParameter",
    "DtsCalibration",
    "DtsInstalledSystem",
    "DtsInstrumentBox",
    "DtsPatchCord",
    "DynamicViscosityMeasure",
    "DynamicViscosityMeasureExt",
    "EX_Extent_Type",
    "EX_GeographicExtent_PropertyType",
    "EX_TemporalExtent_PropertyType",
    "EX_TemporalExtent_Type",
    "EX_VerticalExtent_PropertyType",
    "EX_VerticalExtent_Type",
    "ElectricChargeMeasure",
    "ElectricChargeMeasureExt",
    "ElectricChargePerAreaMeasure",
    "ElectricChargePerAreaMeasureExt",
    "ElectricChargePerMassMeasure",
    "ElectricChargePerMassMeasureExt",
    "ElectricChargePerVolumeMeasure",
    "ElectricChargePerVolumeMeasureExt",
    "ElectricConductanceMeasure",
    "ElectricConductanceMeasureExt",
    "ElectricConductivityMeasure",
    "ElectricConductivityMeasureExt",
    "ElectricCurrentDensityMeasure",
    "ElectricCurrentDensityMeasureExt",
    "ElectricCurrentMeasure",
    "ElectricCurrentMeasureExt",
    "ElectricFieldStrengthMeasure",
    "ElectricFieldStrengthMeasureExt",
    "ElectricPotentialDifferenceMeasure",
    "ElectricPotentialDifferenceMeasureExt",
    "ElectricResistanceMeasure",
    "ElectricResistanceMeasureExt",
    "ElectricResistancePerLengthMeasure",
    "ElectricResistancePerLengthMeasureExt",
    "ElectricalResistivityMeasure",
    "ElectricalResistivityMeasureExt",
    "ElectromagneticMomentMeasure",
    "ElectromagneticMomentMeasureExt",
    "EllipsoidPropertyType",
    "EllipsoidType",
    "EllipsoidalCSPropertyType",
    "EllipsoidalCSType",
    "EmailQualifierStruct",
    "EndpointQualifiedDate",
    "EndpointQualifiedDateTime",
    "EnergyLengthPerAreaMeasure",
    "EnergyLengthPerAreaMeasureExt",
    "EnergyLengthPerTimeAreaTemperatureMeasure",
    "EnergyLengthPerTimeAreaTemperatureMeasureExt",
    "EnergyMeasure",
    "EnergyMeasureExt",
    "EnergyPerAreaMeasure",
    "EnergyPerAreaMeasureExt",
    "EnergyPerLengthMeasure",
    "EnergyPerLengthMeasureExt",
    "EnergyPerMassMeasure",
    "EnergyPerMassMeasureExt",
    "EnergyPerMassPerTimeMeasure",
    "EnergyPerMassPerTimeMeasureExt",
    "EnergyPerVolumeMeasure",
    "EnergyPerVolumeMeasureExt",
    "EpcExternalPartReference",
    "ExpectedFlowQualifier",
    "ExtensionNameValue",
    "ExternalDataset",
    "ExternalDatasetPart",
    "FacilityIdentifier",
    "FacilityIdentifierStruct",
    "FacilityParent",
    "FacilityUnitPort",
    "FailingRule",
    "FiberCommon",
    "FiberConnection",
    "FiberControlLine",
    "FiberConveyance",
    "FiberFacilityGeneric",
    "FiberFacilityMapping",
    "FiberFacilityMappingPart",
    "FiberFacilityPipeline",
    "FiberFacilityWell",
    "FiberOTDR",
    "FiberOTDRInstrumentBox",
    "FiberOneWayAttenuation",
    "FiberOpticalPath",
    "FiberOpticalPathInventory",
    "FiberOpticalPathNetwork",
    "FiberOpticalPathSegment",
    "FiberPathDefect",
    "FiberPumpActivity",
    "FiberRefractiveIndex",
    "FiberSplice",
    "FiberTerminator",
    "FiberTurnaround",
    "FloatExternalArray",
    "FloatingPointConstantArray",
    "FloatingPointExternalArray",
    "FloatingPointLatticeArray",
    "FlowRateValue",
    "FluidComponent",
    "FluidComponentCatalog",
    "ForceAreaMeasure",
    "ForceAreaMeasureExt",
    "ForceLengthPerLengthMeasure",
    "ForceLengthPerLengthMeasureExt",
    "ForceMeasure",
    "ForceMeasureExt",
    "ForcePerForceMeasure",
    "ForcePerForceMeasureExt",
    "ForcePerLengthMeasure",
    "ForcePerLengthMeasureExt",
    "ForcePerVolumeMeasure",
    "ForcePerVolumeMeasureExt",
    "FormationWater",
    "Frequency",
    "FrequencyIntervalMeasure",
    "FrequencyIntervalMeasureExt",
    "FrequencyMeasure",
    "FrequencyMeasureExt",
    "GaugePressure",
    "GeneralAddress",
    "GeneralConversionPropertyType",
    "GeneralMeasureType",
    "GeneralQualifiedMeasure",
    "GenericMeasure",
    "GeodeticCRSPropertyType",
    "GeodeticCRSType",
    "GeodeticCrs",
    "GeodeticDatumPropertyType",
    "GeodeticDatumType",
    "GeodeticEpsgCrs",
    "GeodeticGmlCrs",
    "GeodeticLocalAuthorityCrs",
    "GeodeticUnknownCrs",
    "GeodeticWktCrs",
    "GeographicContext",
    "GeologicTime",
    "GeologyFeature",
    "GraphicalInformationSet",
    "HeatCapacityMeasure",
    "HeatCapacityMeasureExt",
    "HeatFlowRateMeasure",
    "HeatFlowRateMeasureExt",
    "HeatTransferCoefficientMeasure",
    "HeatTransferCoefficientMeasureExt",
    "IdentifiedObjectType",
    "IlluminanceMeasure",
    "IlluminanceMeasureExt",
    "IndexRange",
    "IndexedObject",
    "InductanceMeasure",
    "InductanceMeasureExt",
    "Instrument",
    "IntegerArrayFromBooleanMaskArray",
    "IntegerConstantArray",
    "IntegerData",
    "IntegerExternalArray",
    "IntegerLatticeArray",
    "IntegerQualifiedCount",
    "IntegerQuantityParameter",
    "IntegerRangeArray",
    "InterventionConveyance",
    "IsothermalCompressibilityMeasure",
    "IsothermalCompressibilityMeasureExt",
    "JaggedArray",
    "KeywordValueStruct",
    "KindQualifiedString",
    "KinematicViscosityMeasure",
    "KinematicViscosityMeasureExt",
    "LengthMeasure",
    "LengthMeasureExt",
    "LengthPerLengthMeasure",
    "LengthPerLengthMeasureExt",
    "LengthPerMassMeasure",
    "LengthPerMassMeasureExt",
    "LengthPerPressureMeasure",
    "LengthPerPressureMeasureExt",
    "LengthPerTemperatureMeasure",
    "LengthPerTemperatureMeasureExt",
    "LengthPerTimeMeasure",
    "LengthPerTimeMeasureExt",
    "LengthPerVolumeMeasure",
    "LengthPerVolumeMeasureExt",
    "LengthType",
    "LightExposureMeasure",
    "LightExposureMeasureExt",
    "LinearAccelerationMeasure",
    "LinearAccelerationMeasureExt",
    "LinearThermalExpansionMeasure",
    "LinearThermalExpansionMeasureExt",
    "LiquidComposition",
    "LogarithmicPowerRatioMeasure",
    "LogarithmicPowerRatioMeasureExt",
    "LogarithmicPowerRatioPerLengthMeasure",
    "LogarithmicPowerRatioPerLengthMeasureExt",
    "LuminanceMeasure",
    "LuminanceMeasureExt",
    "LuminousEfficacyMeasure",
    "LuminousEfficacyMeasureExt",
    "LuminousFluxMeasure",
    "LuminousFluxMeasureExt",
    "LuminousIntensityMeasure",
    "LuminousIntensityMeasureExt",
    "MD_Identifier_PropertyType",
    "MD_Identifier_Type",
    "MagneticDipoleMomentMeasure",
    "MagneticDipoleMomentMeasureExt",
    "MagneticFieldStrengthMeasure",
    "MagneticFieldStrengthMeasureExt",
    "MagneticFluxDensityMeasure",
    "MagneticFluxDensityMeasureExt",
    "MagneticFluxDensityPerLengthMeasure",
    "MagneticFluxDensityPerLengthMeasureExt",
    "MagneticFluxMeasure",
    "MagneticFluxMeasureExt",
    "MagneticPermeabilityMeasure",
    "MagneticPermeabilityMeasureExt",
    "MagneticVectorPotentialMeasure",
    "MagneticVectorPotentialMeasureExt",
    "MassLengthMeasure",
    "MassLengthMeasureExt",
    "MassMeasure",
    "MassMeasureExt",
    "MassPerAreaMeasure",
    "MassPerAreaMeasureExt",
    "MassPerEnergyMeasure",
    "MassPerEnergyMeasureExt",
    "MassPerLengthMeasure",
    "MassPerLengthMeasureExt",
    "MassPerMassMeasure",
    "MassPerMassMeasureExt",
    "MassPerTimeMeasure",
    "MassPerTimeMeasureExt",
    "MassPerTimePerAreaMeasure",
    "MassPerTimePerAreaMeasureExt",
    "MassPerTimePerLengthMeasure",
    "MassPerTimePerLengthMeasureExt",
    "MassPerVolumeMeasure",
    "MassPerVolumeMeasureExt",
    "MassPerVolumePerLengthMeasure",
    "MassPerVolumePerLengthMeasureExt",
    "MassPerVolumePerPressureMeasure",
    "MassPerVolumePerPressureMeasureExt",
    "MassPerVolumePerTemperatureMeasure",
    "MassPerVolumePerTemperatureMeasureExt",
    "MdInterval",
    "MeasureOrQuantity",
    "MeasureType",
    "MeasuredDepthCoord",
    "MobilityMeasure",
    "MobilityMeasureExt",
    "MolarEnergyMeasure",
    "MolarEnergyMeasureExt",
    "MolarHeatCapacityMeasure",
    "MolarHeatCapacityMeasureExt",
    "MolarVolumeMeasure",
    "MolarVolumeMeasureExt",
    "MolecularWeightMeasure",
    "MolecularWeightMeasureExt",
    "MomentOfForceMeasure",
    "MomentOfForceMeasureExt",
    "MomentOfInertiaMeasure",
    "MomentOfInertiaMeasureExt",
    "MomentumMeasure",
    "MomentumMeasureExt",
    "NameStruct",
    "NaturalGas",
    "NormalizedPowerMeasure",
    "NormalizedPowerMeasureExt",
    "NorthSeaOffshore",
    "ObjectAlias",
    "ObjectParameterKey",
    "OffshoreLocation",
    "OverallComposition",
    "OwnershipBusinessAcct",
    "ParameterTemplate",
    "Parentfacility",
    "PermanentCable",
    "PermeabilityLengthMeasure",
    "PermeabilityLengthMeasureExt",
    "PermeabilityRockMeasure",
    "PermeabilityRockMeasureExt",
    "PermittivityMeasure",
    "PermittivityMeasureExt",
    "PersonName",
    "PhoneNumberStruct",
    "PlaneAngleMeasure",
    "PlaneAngleMeasureExt",
    "PlusFluidComponent",
    "PotentialDifferencePerPowerDropMeasure",
    "PotentialDifferencePerPowerDropMeasureExt",
    "PowerMeasure",
    "PowerMeasureExt",
    "PowerPerAreaMeasure",
    "PowerPerAreaMeasureExt",
    "PowerPerPowerMeasure",
    "PowerPerPowerMeasureExt",
    "PowerPerVolumeMeasure",
    "PowerPerVolumeMeasureExt",
    "PressureMeasure",
    "PressureMeasureExt",
    "PressurePerPressureMeasure",
    "PressurePerPressureMeasureExt",
    "PressurePerTimeMeasure",
    "PressurePerTimeMeasureExt",
    "PressurePerVolumeMeasure",
    "PressurePerVolumeMeasureExt",
    "PressureSquaredMeasure",
    "PressureSquaredMeasureExt",
    "PressureSquaredPerForceTimePerAreaMeasure",
    "PressureSquaredPerForceTimePerAreaMeasureExt",
    "PressureTimePerVolumeMeasure",
    "PressureTimePerVolumeMeasureExt",
    "PressureValue",
    "PrimeMeridianPropertyType",
    "PrimeMeridianType",
    "ProductFlowChangeLog",
    "ProductFlowExpectedUnitProperty",
    "ProductFlowExternalPort",
    "ProductFlowExternalReference",
    "ProductFlowModel",
    "ProductFlowNetwork",
    "ProductFlowNetworkPlan",
    "ProductFlowPort",
    "ProductFlowQualifierExpected",
    "ProductFlowUnit",
    "ProductVolume",
    "ProductVolumeAlert",
    "ProductVolumeBalanceDetail",
    "ProductVolumeBalanceEvent",
    "ProductVolumeBalanceSet",
    "ProductVolumeBusinessSubUnit",
    "ProductVolumeBusinessUnit",
    "ProductVolumeComponentContent",
    "ProductVolumeDestination",
    "ProductVolumeFacility",
    "ProductVolumeFlow",
    "ProductVolumeParameterSet",
    "ProductVolumeParameterValue",
    "ProductVolumePeriod",
    "ProductVolumePortDifference",
    "ProductVolumeProduct",
    "ProductVolumeRelatedFacility",
    "ProjectedCRSType",
    "ProjectedCrs",
    "ProjectedEpsgCrs",
    "ProjectedGmlCrs",
    "ProjectedLocalAuthorityCrs",
    "ProjectedUnknownCrs",
    "ProjectedWktCrs",
    "PropertyKind",
    "PropertyKindDictionary",
    "PseudoFluidComponent",
    "PureFluidComponent",
    "Qualifier",
    "QuantityOfLightMeasure",
    "QuantityOfLightMeasureExt",
    "RadianceMeasure",
    "RadianceMeasureExt",
    "RadiantIntensityMeasure",
    "RadiantIntensityMeasureExt",
    "Real_PropertyType",
    "ReciprocalAreaMeasure",
    "ReciprocalAreaMeasureExt",
    "ReciprocalElectricPotentialDifferenceMeasure",
    "ReciprocalElectricPotentialDifferenceMeasureExt",
    "ReciprocalForceMeasure",
    "ReciprocalForceMeasureExt",
    "ReciprocalLengthMeasure",
    "ReciprocalLengthMeasureExt",
    "ReciprocalMassMeasure",
    "ReciprocalMassMeasureExt",
    "ReciprocalMassTimeMeasure",
    "ReciprocalMassTimeMeasureExt",
    "ReciprocalPressureMeasure",
    "ReciprocalPressureMeasureExt",
    "ReciprocalTimeMeasure",
    "ReciprocalTimeMeasureExt",
    "ReciprocalVolumeMeasure",
    "ReciprocalVolumeMeasureExt",
    "ReferenceFlow",
    "ReferencePressure",
    "ReferenceTemperaturePressure",
    "ReferenceType",
    "RelatedTimeType",
    "RelativeCoordinate",
    "RelativePressure",
    "ReluctanceMeasure",
    "ReluctanceMeasureExt",
    "SC_CRS_PropertyType",
    "SecondDefiningParameter",
    "SecondMomentOfAreaMeasure",
    "SecondMomentOfAreaMeasureExt",
    "SignalingEventPerTimeMeasure",
    "SignalingEventPerTimeMeasureExt",
    "SolidAngleMeasure",
    "SolidAngleMeasureExt",
    "SpecificHeatCapacityMeasure",
    "SpecificHeatCapacityMeasureExt",
    "SphericalCSPropertyType",
    "SphericalCSType",
    "StartEndDate",
    "StartEndTime",
    "StockTankOil",
    "StringConstantArray",
    "StringData",
    "StringExternalArray",
    "StringMeasure",
    "StringOrRefType",
    "StringParameter",
    "TM_Primitive_PropertyType",
    "TemperatureIntervalMeasure",
    "TemperatureIntervalMeasureExt",
    "TemperatureIntervalPerLengthMeasure",
    "TemperatureIntervalPerLengthMeasureExt",
    "TemperatureIntervalPerPressureMeasure",
    "TemperatureIntervalPerPressureMeasureExt",
    "TemperatureIntervalPerTimeMeasure",
    "TemperatureIntervalPerTimeMeasureExt",
    "TemperaturePressure",
    "ThermalConductanceMeasure",
    "ThermalConductanceMeasureExt",
    "ThermalConductivityMeasure",
    "ThermalConductivityMeasureExt",
    "ThermalDiffusivityMeasure",
    "ThermalDiffusivityMeasureExt",
    "ThermalInsulanceMeasure",
    "ThermalInsulanceMeasureExt",
    "ThermalResistanceMeasure",
    "ThermalResistanceMeasureExt",
    "ThermodynamicTemperatureMeasure",
    "ThermodynamicTemperatureMeasureExt",
    "ThermodynamicTemperaturePerThermodynamicTemperatureMeasure",
    "ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt",
    "TimeIndex",
    "TimeIndexParameter",
    "TimeIndexParameterKey",
    "TimeIndices",
    "TimeMeasure",
    "TimeMeasureExt",
    "TimePerLengthMeasure",
    "TimePerLengthMeasureExt",
    "TimePerMassMeasure",
    "TimePerMassMeasureExt",
    "TimePerTimeMeasure",
    "TimePerTimeMeasureExt",
    "TimePerVolumeMeasure",
    "TimePerVolumeMeasureExt",
    "TimePrimitivePropertyType",
    "TimeSeries",
    "TimeSeriesParentage",
    "TvdInterval",
    "URL_PropertyType",
    "UnitlessMeasure",
    "VaporComposition",
    "VerticalCRSType",
    "VerticalCSPropertyType",
    "VerticalCSType",
    "VerticalCoordinateMeasure",
    "VerticalCoordinateMeasureExt",
    "VerticalCrs",
    "VerticalDatumPropertyType",
    "VerticalDatumType",
    "VerticalEpsgCrs",
    "VerticalGmlCrs",
    "VerticalLocalAuthorityCrs",
    "VerticalUnknownCrs",
    "VerticalWktCrs",
    "VolumeFlowRatePerVolumeFlowRateMeasure",
    "VolumeFlowRatePerVolumeFlowRateMeasureExt",
    "VolumeMeasure",
    "VolumeMeasureExt",
    "VolumePerAreaMeasure",
    "VolumePerAreaMeasureExt",
    "VolumePerLengthMeasure",
    "VolumePerLengthMeasureExt",
    "VolumePerMassMeasure",
    "VolumePerMassMeasureExt",
    "VolumePerPressureMeasure",
    "VolumePerPressureMeasureExt",
    "VolumePerRotationMeasure",
    "VolumePerRotationMeasureExt",
    "VolumePerTimeLengthMeasure",
    "VolumePerTimeLengthMeasureExt",
    "VolumePerTimeMeasure",
    "VolumePerTimeMeasureExt",
    "VolumePerTimePerAreaMeasure",
    "VolumePerTimePerAreaMeasureExt",
    "VolumePerTimePerLengthMeasure",
    "VolumePerTimePerLengthMeasureExt",
    "VolumePerTimePerPressureLengthMeasure",
    "VolumePerTimePerPressureLengthMeasureExt",
    "VolumePerTimePerPressureMeasure",
    "VolumePerTimePerPressureMeasureExt",
    "VolumePerTimePerTimeMeasure",
    "VolumePerTimePerTimeMeasureExt",
    "VolumePerTimePerVolumeMeasure",
    "VolumePerTimePerVolumeMeasureExt",
    "VolumePerVolumeMeasure",
    "VolumePerVolumeMeasureExt",
    "VolumeQualifiedMeasure",
    "VolumeValue",
    "VolumetricHeatTransferCoefficientMeasure",
    "VolumetricHeatTransferCoefficientMeasureExt",
    "VolumetricThermalExpansionMeasure",
    "VolumetricThermalExpansionMeasureExt",
    "WaveLength",
    "WellElevationCoord",
    "WellVerticalDepthCoord",
    "coordinateOperationAccuracy",
    "domainOfValidity",
    "secondDefiningParameter"
]
